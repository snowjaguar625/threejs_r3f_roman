{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nvar _lwoTree;\nvar LWOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LWOLoader, _Loader);\n  function LWOLoader(manager) {\n    var _this;\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, LWOLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LWOLoader).call(this, manager));\n    _this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n    return _this;\n  }\n  _createClass(LWOLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n      var modelName = url.split(path).pop().split('.')[0];\n      var loader = new FileLoader(this.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        // console.time( 'Total parsing: ' );\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        } // console.timeEnd( 'Total parsing: ' );\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(iffBuffer, path, modelName) {\n      _lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n      var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      return new LWOTreeParser(textureLoader).parse(modelName);\n    }\n  }]);\n  return LWOLoader;\n}(Loader); // Parse the lwoTree object\nvar LWOTreeParser = /*#__PURE__*/function () {\n  function LWOTreeParser(textureLoader) {\n    _classCallCheck(this, LWOTreeParser);\n    this.textureLoader = textureLoader;\n  }\n  _createClass(LWOTreeParser, [{\n    key: \"parse\",\n    value: function parse(modelName) {\n      this.materials = new MaterialParser(this.textureLoader).parse();\n      this.defaultLayerName = modelName;\n      this.meshes = this.parseLayers();\n      return {\n        materials: this.materials,\n        meshes: this.meshes\n      };\n    }\n  }, {\n    key: \"parseLayers\",\n    value: function parseLayers() {\n      // array of all meshes for building hierarchy\n      var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n      var finalMeshes = [];\n      var geometryParser = new GeometryParser();\n      var scope = this;\n      _lwoTree.layers.forEach(function (layer) {\n        var geometry = geometryParser.parse(layer.geometry, layer);\n        var mesh = scope.parseMesh(geometry, layer);\n        meshes[layer.number] = mesh;\n        if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n      });\n      this.applyPivots(finalMeshes);\n      return finalMeshes;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(geometry, layer) {\n      var mesh;\n      var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n      this.duplicateUVs(geometry, materials);\n      if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n      if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n      mesh.userData.pivot = layer.pivot;\n      return mesh;\n    } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  }, {\n    key: \"applyPivots\",\n    value: function applyPivots(meshes) {\n      meshes.forEach(function (mesh) {\n        mesh.traverse(function (child) {\n          var pivot = child.userData.pivot;\n          child.position.x += pivot[0];\n          child.position.y += pivot[1];\n          child.position.z += pivot[2];\n          if (child.parent) {\n            var parentPivot = child.parent.userData.pivot;\n            child.position.x -= parentPivot[0];\n            child.position.y -= parentPivot[1];\n            child.position.z -= parentPivot[2];\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getMaterials\",\n    value: function getMaterials(namesArray, type) {\n      var materials = [];\n      var scope = this;\n      namesArray.forEach(function (name, i) {\n        materials[i] = scope.getMaterialByName(name);\n      }); // convert materials to line or point mats if required\n\n      if (type === 'points' || type === 'lines') {\n        materials.forEach(function (mat, i) {\n          var spec = {\n            color: mat.color\n          };\n          if (type === 'points') {\n            spec.size = 0.1;\n            spec.map = mat.map;\n            spec.morphTargets = mat.morphTargets;\n            materials[i] = new PointsMaterial(spec);\n          } else if (type === 'lines') {\n            materials[i] = new LineBasicMaterial(spec);\n          }\n        });\n      } // if there is only one material, return that directly instead of array\n\n      var filtered = materials.filter(Boolean);\n      if (filtered.length === 1) return filtered[0];\n      return materials;\n    }\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      return this.materials.filter(function (m) {\n        return m.name === name;\n      })[0];\n    } // If the material has an aoMap, duplicate UVs\n  }, {\n    key: \"duplicateUVs\",\n    value: function duplicateUVs(geometry, materials) {\n      var duplicateUVs = false;\n      if (!Array.isArray(materials)) {\n        if (materials.aoMap) duplicateUVs = true;\n      } else {\n        materials.forEach(function (material) {\n          if (material.aoMap) duplicateUVs = true;\n        });\n      }\n      if (!duplicateUVs) return;\n      geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n  }]);\n  return LWOTreeParser;\n}();\nvar MaterialParser = /*#__PURE__*/function () {\n  function MaterialParser(textureLoader) {\n    _classCallCheck(this, MaterialParser);\n    this.textureLoader = textureLoader;\n  }\n  _createClass(MaterialParser, [{\n    key: \"parse\",\n    value: function parse() {\n      var materials = [];\n      this.textures = {};\n      for (var name in _lwoTree.materials) {\n        if (_lwoTree.format === 'LWO3') {\n          materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n        } else if (_lwoTree.format === 'LWO2') {\n          materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n        }\n      }\n      return materials;\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(materialData, name, textures) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var connections = this.parseConnections(materialData.connections, materialData.nodes);\n      var maps = this.parseTextureNodes(connections.maps);\n      this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n      var attributes = this.parseAttributes(connections.attributes, maps);\n      this.parseEnvMap(connections, maps, attributes);\n      params = Object.assign(maps, params);\n      params = Object.assign(params, attributes);\n      var materialType = this.getMaterialType(connections.attributes);\n      return new materialType(params);\n    }\n  }, {\n    key: \"parseMaterialLwo2\",\n    value: function parseMaterialLwo2(materialData, name\n    /*, textures*/) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var attributes = this.parseAttributes(materialData.attributes, {});\n      params = Object.assign(params, attributes);\n      return new MeshPhongMaterial(params);\n    } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n    // then switching mat FrontSide -> BackSide\n    // NB: this means that FrontSide and BackSide have been switched!\n  }, {\n    key: \"getSide\",\n    value: function getSide(attributes) {\n      if (!attributes.side) return BackSide;\n      switch (attributes.side) {\n        case 0:\n        case 1:\n          return BackSide;\n        case 2:\n          return FrontSide;\n        case 3:\n          return DoubleSide;\n      }\n    }\n  }, {\n    key: \"getSmooth\",\n    value: function getSmooth(attributes) {\n      if (!attributes.smooth) return true;\n      return !attributes.smooth;\n    }\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(connections, nodes) {\n      var materialConnections = {\n        maps: {}\n      };\n      var inputName = connections.inputName;\n      var inputNodeName = connections.inputNodeName;\n      var nodeName = connections.nodeName;\n      var scope = this;\n      inputName.forEach(function (name, index) {\n        if (name === 'Material') {\n          var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n          materialConnections.attributes = matNode.attributes;\n          materialConnections.envMap = matNode.fileName;\n          materialConnections.name = inputNodeName[index];\n        }\n      });\n      nodeName.forEach(function (name, index) {\n        if (name === materialConnections.name) {\n          materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n        }\n      });\n      return materialConnections;\n    }\n  }, {\n    key: \"getNodeByRefName\",\n    value: function getNodeByRefName(refName, nodes) {\n      for (var name in nodes) {\n        if (nodes[name].refName === refName) return nodes[name];\n      }\n    }\n  }, {\n    key: \"parseTextureNodes\",\n    value: function parseTextureNodes(textureNodes) {\n      var maps = {};\n      for (var name in textureNodes) {\n        var node = textureNodes[name];\n        var path = node.fileName;\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n        if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 0.5;\n            break;\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n          case 'Luminous':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n          case 'Luminous Color':\n            maps.emissive = 0x808080;\n            break;\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 0.5;\n            break;\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case 'Normal':\n            maps.normalMap = texture;\n            if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n            break;\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n      if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n      return maps;\n    } // maps can also be defined on individual material attributes, parse those here\n    // This occurs on Standard (Phong) surfaces\n  }, {\n    key: \"parseAttributeImageMaps\",\n    value: function parseAttributeImageMaps(attributes, textures, maps) {\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        if (attribute.maps) {\n          var mapData = attribute.maps[0];\n          var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n          if (!path) return;\n          var texture = this.loadTexture(path);\n          if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n          if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n          switch (name) {\n            case 'Color':\n              maps.map = texture;\n              break;\n            case 'Diffuse':\n              maps.aoMap = texture;\n              break;\n            case 'Roughness':\n              maps.roughnessMap = texture;\n              maps.roughness = 1;\n              break;\n            case 'Specular':\n              maps.specularMap = texture;\n              maps.specular = 0xffffff;\n              break;\n            case 'Luminosity':\n              maps.emissiveMap = texture;\n              maps.emissive = 0x808080;\n              break;\n            case 'Metallic':\n              maps.metalnessMap = texture;\n              maps.metalness = 1;\n              break;\n            case 'Transparency':\n            case 'Alpha':\n              maps.alphaMap = texture;\n              maps.transparent = true;\n              break;\n            case 'Normal':\n              maps.normalMap = texture;\n              break;\n            case 'Bump':\n              maps.bumpMap = texture;\n              break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseAttributes\",\n    value: function parseAttributes(attributes, maps) {\n      var params = {}; // don't use color data if color map is present\n\n      if (attributes.Color && !maps.map) {\n        params.color = new Color().fromArray(attributes.Color.value);\n      } else {\n        params.color = new Color();\n      }\n      if (attributes.Transparency && attributes.Transparency.value !== 0) {\n        params.opacity = 1 - attributes.Transparency.value;\n        params.transparent = true;\n      }\n      if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n      if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n      this.parsePhysicalAttributes(params, attributes, maps);\n      this.parseStandardAttributes(params, attributes, maps);\n      this.parsePhongAttributes(params, attributes, maps);\n      return params;\n    }\n  }, {\n    key: \"parsePhysicalAttributes\",\n    value: function parsePhysicalAttributes(params, attributes\n    /*, maps*/) {\n      if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n        params.clearcoat = attributes.Clearcoat.value;\n        if (attributes['Clearcoat Gloss']) {\n          params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n        }\n      }\n    }\n  }, {\n    key: \"parseStandardAttributes\",\n    value: function parseStandardAttributes(params, attributes, maps) {\n      if (attributes.Luminous) {\n        params.emissiveIntensity = attributes.Luminous.value;\n        if (attributes['Luminous Color'] && !maps.emissive) {\n          params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n        } else {\n          params.emissive = new Color(0x808080);\n        }\n      }\n      if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n      if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n    }\n  }, {\n    key: \"parsePhongAttributes\",\n    value: function parsePhongAttributes(params, attributes, maps) {\n      if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n      if (attributes.Reflection) {\n        params.reflectivity = attributes.Reflection.value;\n        params.combine = AddOperation;\n      }\n      if (attributes.Luminosity) {\n        params.emissiveIntensity = attributes.Luminosity.value;\n        if (!maps.emissiveMap && !maps.map) {\n          params.emissive = params.color;\n        } else {\n          params.emissive = new Color(0x808080);\n        }\n      } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n      if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n        if (attributes['Color Highlight']) {\n          params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n        } else {\n          params.specular = new Color().setScalar(attributes.Specular.value);\n        }\n      }\n      if (params.specular && attributes.Glossiness) {\n        params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n      }\n    }\n  }, {\n    key: \"parseEnvMap\",\n    value: function parseEnvMap(connections, maps, attributes) {\n      if (connections.envMap) {\n        var envMap = this.loadTexture(connections.envMap);\n        if (attributes.transparent && attributes.opacity < 0.999) {\n          envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n          if (attributes.reflectivity !== undefined) {\n            delete attributes.reflectivity;\n            delete attributes.combine;\n          }\n          if (attributes.metalness !== undefined) {\n            delete attributes.metalness;\n          }\n        } else {\n          envMap.mapping = EquirectangularReflectionMapping;\n        }\n        maps.envMap = envMap;\n      }\n    } // get texture defined at top level by its index\n  }, {\n    key: \"getTexturePathByIndex\",\n    value: function getTexturePathByIndex(index) {\n      var fileName = '';\n      if (!_lwoTree.textures) return fileName;\n      _lwoTree.textures.forEach(function (texture) {\n        if (texture.index === index) fileName = texture.fileName;\n      });\n      return fileName;\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(path) {\n      if (!path) return null;\n      var texture = this.textureLoader.load(path, undefined, undefined, function () {\n        console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n      });\n      return texture;\n    } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  }, {\n    key: \"getWrappingType\",\n    value: function getWrappingType(num) {\n      switch (num) {\n        case 0:\n          console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n          return ClampToEdgeWrapping;\n        case 1:\n          return RepeatWrapping;\n        case 2:\n          return MirroredRepeatWrapping;\n        case 3:\n          return ClampToEdgeWrapping;\n      }\n    }\n  }, {\n    key: \"getMaterialType\",\n    value: function getMaterialType(nodeData) {\n      if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n      if (nodeData.Roughness) return MeshStandardMaterial;\n      return MeshPhongMaterial;\n    }\n  }]);\n  return MaterialParser;\n}();\nvar GeometryParser = /*#__PURE__*/function () {\n  function GeometryParser() {\n    _classCallCheck(this, GeometryParser);\n  }\n  _createClass(GeometryParser, [{\n    key: \"parse\",\n    value: function parse(geoData, layer) {\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n      var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n      geometry.setIndex(indices);\n      this.parseGroups(geometry, geoData);\n      geometry.computeVertexNormals();\n      this.parseUVs(geometry, layer, indices);\n      this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n      geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\n      // geometry = geometry.toNonIndexed()\n      // geometry.userData = userData;\n\n      return geometry;\n    } // split quads into tris\n  }, {\n    key: \"splitIndices\",\n    value: function splitIndices(indices, polygonDimensions) {\n      var remappedIndices = [];\n      var i = 0;\n      polygonDimensions.forEach(function (dim) {\n        if (dim < 4) {\n          for (var k = 0; k < dim; k++) {\n            remappedIndices.push(indices[i + k]);\n          }\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n        } else if (dim > 4) {\n          for (var _k = 1; _k < dim - 1; _k++) {\n            remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\n          }\n          console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n        }\n        i += dim;\n      });\n      return remappedIndices;\n    } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  }, {\n    key: \"parseGroups\",\n    value: function parseGroups(geometry, geoData) {\n      var tags = _lwoTree.tags;\n      var matNames = [];\n      var elemSize = 3;\n      if (geoData.type === 'lines') elemSize = 2;\n      if (geoData.type === 'points') elemSize = 1;\n      var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n      var indexNum = 0; // create new indices in numerical order\n\n      var indexPairs = {}; // original indices mapped to numerical indices\n\n      var prevMaterialIndex;\n      var materialIndex;\n      var prevStart = 0;\n      var currentCount = 0;\n      for (var i = 0; i < remappedIndices.length; i += 2) {\n        materialIndex = remappedIndices[i + 1];\n        if (i === 0) matNames[indexNum] = tags[materialIndex];\n        if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n        if (materialIndex !== prevMaterialIndex) {\n          var currentIndex = void 0;\n          if (indexPairs[tags[prevMaterialIndex]]) {\n            currentIndex = indexPairs[tags[prevMaterialIndex]];\n          } else {\n            currentIndex = indexNum;\n            indexPairs[tags[prevMaterialIndex]] = indexNum;\n            matNames[indexNum] = tags[prevMaterialIndex];\n            indexNum++;\n          }\n          geometry.addGroup(prevStart, currentCount, currentIndex);\n          prevStart += currentCount;\n          prevMaterialIndex = materialIndex;\n          currentCount = 0;\n        }\n        currentCount += elemSize;\n      } // the loop above doesn't add the last group, do that here.\n\n      if (geometry.groups.length > 0) {\n        var _currentIndex;\n        if (indexPairs[tags[materialIndex]]) {\n          _currentIndex = indexPairs[tags[materialIndex]];\n        } else {\n          _currentIndex = indexNum;\n          indexPairs[tags[materialIndex]] = indexNum;\n          matNames[indexNum] = tags[materialIndex];\n        }\n        geometry.addGroup(prevStart, currentCount, _currentIndex);\n      } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n      geometry.userData.matNames = matNames;\n    }\n  }, {\n    key: \"splitMaterialIndices\",\n    value: function splitMaterialIndices(polygonDimensions, indices) {\n      var remappedIndices = [];\n      polygonDimensions.forEach(function (dim, i) {\n        if (dim <= 3) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n        } else {\n          // ignore > 4 for now\n          for (var k = 0; k < dim - 2; k++) {\n            remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n          }\n        }\n      });\n      return remappedIndices;\n    } // UV maps:\n    // 1: are defined via index into an array of points, not into a geometry\n    // - the geometry is also defined by an index into this array, but the indexes may not match\n    // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n    // \twith preference given to the first map encountered\n    // 3: UV maps can be partial - that is, defined for only a part of the geometry\n    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n    // UV maps are defined as partially VMAP and partially VMAD\n    // VMADs are currently not supported\n  }, {\n    key: \"parseUVs\",\n    value: function parseUVs(geometry, layer) {\n      // start by creating a UV map set to zero for the whole geometry\n      var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n        return 0;\n      });\n      var _loop = function _loop(name) {\n        var uvs = layer.uvs[name].uvs;\n        var uvIndices = layer.uvs[name].uvIndices;\n        uvIndices.forEach(function (i, j) {\n          remappedUVs[i * 2] = uvs[j * 2];\n          remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n        });\n      };\n      for (var name in layer.uvs) {\n        _loop(name);\n      }\n      geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(geometry, layer) {\n      var num = 0;\n      var _loop2 = function _loop2(name) {\n        var remappedPoints = geometry.attributes.position.array.slice();\n        if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n        var morphPoints = layer.morphTargets[name].points;\n        var morphIndices = layer.morphTargets[name].indices;\n        var type = layer.morphTargets[name].type;\n        morphIndices.forEach(function (i, j) {\n          if (type === 'relative') {\n            remappedPoints[i * 3] += morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n          } else {\n            remappedPoints[i * 3] = morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n          }\n        });\n        geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n        geometry.morphAttributes.position[num].name = name;\n        num++;\n      };\n      for (var name in layer.morphTargets) {\n        _loop2(name);\n      }\n      geometry.morphTargetsRelative = false;\n    }\n  }]);\n  return GeometryParser;\n}(); // ************** UTILITY FUNCTIONS **************\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\nexport { LWOLoader };","map":null,"metadata":{},"sourceType":"module"}