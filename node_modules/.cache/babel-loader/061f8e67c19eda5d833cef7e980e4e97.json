{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { Vector2, WebGLRenderTarget, UniformsUtils, ShaderMaterial, AdditiveBlending } from 'three';\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\nvar BloomPass = /*#__PURE__*/function (_Pass) {\n  _inherits(BloomPass, _Pass);\n  function BloomPass() {\n    var _this;\n    var strength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var kernelSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n    var sigma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n    var resolution = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 256;\n    _classCallCheck(this, BloomPass);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BloomPass).call(this)); // render targets\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetX\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetY\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"materialCombine\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"materialConvolution\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"fsQuad\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"combineUniforms\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"convolutionUniforms\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"blurX\", new Vector2(0.001953125, 0.0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"blurY\", new Vector2(0.0, 0.001953125));\n    _this.renderTargetX = new WebGLRenderTarget(resolution, resolution);\n    _this.renderTargetX.texture.name = 'BloomPass.x';\n    _this.renderTargetY = new WebGLRenderTarget(resolution, resolution);\n    _this.renderTargetY.texture.name = 'BloomPass.y'; // combine material\n\n    _this.combineUniforms = UniformsUtils.clone(CombineShader.uniforms);\n    _this.combineUniforms['strength'].value = strength;\n    _this.materialCombine = new ShaderMaterial({\n      uniforms: _this.combineUniforms,\n      vertexShader: CombineShader.vertexShader,\n      fragmentShader: CombineShader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true\n    }); // convolution material\n\n    if (ConvolutionShader === undefined) console.error('BloomPass relies on ConvolutionShader');\n    var convolutionShader = ConvolutionShader;\n    _this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n    _this.convolutionUniforms['uImageIncrement'].value = _this.blurX;\n    _this.convolutionUniforms['cKernel'].value = ConvolutionShader.buildKernel(sigma);\n    _this.materialConvolution = new ShaderMaterial({\n      uniforms: _this.convolutionUniforms,\n      vertexShader: convolutionShader.vertexShader,\n      fragmentShader: convolutionShader.fragmentShader,\n      defines: {\n        KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n        KERNEL_SIZE_INT: kernelSize.toFixed(0)\n      }\n    });\n    _this.needsSwap = false;\n    _this.fsQuad = new FullScreenQuad(_this.materialConvolution);\n    return _this;\n  }\n  _createClass(BloomPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render quad with blured scene into texture (convolution pass 1)\n\n      this.fsQuad.material = this.materialConvolution;\n      this.convolutionUniforms['tDiffuse'].value = readBuffer.texture;\n      this.convolutionUniforms['uImageIncrement'].value = this.blurX;\n      renderer.setRenderTarget(this.renderTargetX);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)\n\n      this.convolutionUniforms['tDiffuse'].value = this.renderTargetX.texture;\n      this.convolutionUniforms['uImageIncrement'].value = this.blurY;\n      renderer.setRenderTarget(this.renderTargetY);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture\n\n      this.fsQuad.material = this.materialCombine;\n      this.combineUniforms['tDiffuse'].value = this.renderTargetY.texture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  }]);\n  return BloomPass;\n}(Pass);\nvar CombineShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    strength: {\n      value: 1.0\n    }\n  },\n  vertexShader: /* glsl */\"\\n  varying vec2 vUv;\\n  void main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n  }\",\n  fragmentShader: /* glsl */\"\\n  uniform float strength;\\n  uniform sampler2D tDiffuse;\\n  varying vec2 vUv;\\n  void main() {\\n    vec4 texel = texture2D( tDiffuse, vUv );\\n    gl_FragColor = strength * texel;\\n  }\"\n};\nexport { BloomPass };","map":null,"metadata":{},"sourceType":"module"}