{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, Vector3, Matrix4 } from 'three';\nimport { gunzipSync } from 'fflate';\nimport { Volume } from '../misc/Volume.js';\nvar NRRDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(NRRDLoader, _Loader);\n  function NRRDLoader(manager) {\n    _classCallCheck(this, NRRDLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(NRRDLoader).call(this, manager));\n  }\n  _createClass(NRRDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n      var _data = data;\n      var _dataPointer = 0;\n      var _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n      var _littleEndian = true;\n      var headerObject = {};\n      function scan(type, chunks) {\n        if (chunks === undefined || chunks === null) {\n          chunks = 1;\n        }\n        var _chunkSize = 1;\n        var _array_type = Uint8Array;\n        switch (type) {\n          // 1 byte data types\n          case 'uchar':\n            break;\n          case 'schar':\n            _array_type = Int8Array;\n            break;\n          // 2 byte data types\n\n          case 'ushort':\n            _array_type = Uint16Array;\n            _chunkSize = 2;\n            break;\n          case 'sshort':\n            _array_type = Int16Array;\n            _chunkSize = 2;\n            break;\n          // 4 byte data types\n\n          case 'uint':\n            _array_type = Uint32Array;\n            _chunkSize = 4;\n            break;\n          case 'sint':\n            _array_type = Int32Array;\n            _chunkSize = 4;\n            break;\n          case 'float':\n            _array_type = Float32Array;\n            _chunkSize = 4;\n            break;\n          case 'complex':\n            _array_type = Float64Array;\n            _chunkSize = 8;\n            break;\n          case 'double':\n            _array_type = Float64Array;\n            _chunkSize = 8;\n            break;\n        } // increase the data pointer in-place\n\n        var _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize)); // if required, flip the endianness of the bytes\n\n        if (_nativeLittleEndian != _littleEndian) {\n          // we need to flip here since the format doesn't match the native endianness\n          _bytes = flipEndianness(_bytes, _chunkSize);\n        }\n        if (chunks == 1) {\n          // if only one chunk was requested, just return one value\n          return _bytes[0];\n        } // return the byte array\n\n        return _bytes;\n      } //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n      function flipEndianness(array, chunkSize) {\n        var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        for (var _i2 = 0; _i2 < array.byteLength; _i2 += chunkSize) {\n          for (var j = _i2 + chunkSize - 1, k = _i2; j > k; j--, k++) {\n            var tmp = u8[k];\n            u8[k] = u8[j];\n            u8[j] = tmp;\n          }\n        }\n        return array;\n      } //parse the header\n\n      function parseHeader(header) {\n        var data, field, fn, i, l, m, _i, _len;\n        var lines = header.split(/\\r?\\n/);\n        for (_i = 0, _len = lines.length; _i < _len; _i++) {\n          l = lines[_i];\n          if (l.match(/NRRD\\d+/)) {\n            headerObject.isNrrd = true;\n          } else if (l.match(/^#/)) ;else if (m = l.match(/(.*):(.*)/)) {\n            field = m[1].trim();\n            data = m[2].trim();\n            fn = _fieldFunctions[field];\n            if (fn) {\n              fn.call(headerObject, data);\n            } else {\n              headerObject[field] = data;\n            }\n          }\n        }\n        if (!headerObject.isNrrd) {\n          throw new Error('Not an NRRD file');\n        }\n        if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n          throw new Error('Bzip is not supported');\n        }\n        if (!headerObject.vectors) {\n          //if no space direction is set, let's use the identity\n          headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]; //apply spacing if defined\n\n          if (headerObject.spacings) {\n            for (i = 0; i <= 2; i++) {\n              if (!isNaN(headerObject.spacings[i])) {\n                headerObject.vectors[i].multiplyScalar(headerObject.spacings[i]);\n              }\n            }\n          }\n        }\n      } //parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n\n      function parseDataAsText(data, start, end) {\n        var number = '';\n        start = start || 0;\n        end = end || data.length;\n        var value; //length of the result is the product of the sizes\n\n        var lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n          return previous * current;\n        }, 1);\n        var base = 10;\n        if (headerObject.encoding === 'hex') {\n          base = 16;\n        }\n        var result = new headerObject.__array(lengthOfTheResult);\n        var resultIndex = 0;\n        var parsingFunction = parseInt;\n        if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n          parsingFunction = parseFloat;\n        }\n        for (var _i3 = start; _i3 < end; _i3++) {\n          value = data[_i3]; //if value is not a space\n\n          if ((value < 9 || value > 13) && value !== 32) {\n            number += String.fromCharCode(value);\n          } else {\n            if (number !== '') {\n              result[resultIndex] = parsingFunction(number, base);\n              resultIndex++;\n            }\n            number = '';\n          }\n        }\n        if (number !== '') {\n          result[resultIndex] = parsingFunction(number, base);\n          resultIndex++;\n        }\n        return result;\n      }\n      var _bytes = scan('uchar', data.byteLength);\n      var _length = _bytes.length;\n      var _header = null;\n      var _data_start = 0;\n      var i;\n      for (i = 1; i < _length; i++) {\n        if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n          // we found two line breaks in a row\n          // now we know what the header is\n          _header = this.parseChars(_bytes, 0, i - 2); // this is were the data starts\n\n          _data_start = i + 1;\n          break;\n        }\n      } // parse the header\n\n      parseHeader(_header);\n      _data = _bytes.subarray(_data_start); // the data without header\n\n      if (headerObject.encoding.substring(0, 2) === 'gz') {\n        // we need to decompress the datastream\n        // here we start the unzipping and get a typed Uint8Array back\n        _data = gunzipSync(new Uint8Array(_data)); // eslint-disable-line no-undef\n      } else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {\n        _data = parseDataAsText(_data);\n      } else if (headerObject.encoding === 'raw') {\n        //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n        var _copy = new Uint8Array(_data.length);\n        for (var _i4 = 0; _i4 < _data.length; _i4++) {\n          _copy[_i4] = _data[_i4];\n        }\n        _data = _copy;\n      } // .. let's use the underlying array buffer\n\n      _data = _data.buffer;\n      var volume = new Volume();\n      volume.header = headerObject; //\n      // parse the (unzipped) data to a datastream of the correct type\n      //\n\n      volume.data = new headerObject.__array(_data); // get the min and max intensities\n\n      var min_max = volume.computeMinMax();\n      var min = min_max[0];\n      var max = min_max[1]; // attach the scalar range to the volume\n\n      volume.windowLow = min;\n      volume.windowHigh = max; // get the image dimensions\n\n      volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n      volume.xLength = volume.dimensions[0];\n      volume.yLength = volume.dimensions[1];\n      volume.zLength = volume.dimensions[2]; // spacing\n\n      var spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n      var spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n      var spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n      volume.spacing = [spacingX, spacingY, spacingZ]; // Create IJKtoRAS matrix\n\n      volume.matrix = new Matrix4();\n      var _spaceX = 1;\n      var _spaceY = 1;\n      var _spaceZ = 1;\n      if (headerObject.space == 'left-posterior-superior') {\n        _spaceX = -1;\n        _spaceY = -1;\n      } else if (headerObject.space === 'left-anterior-superior') {\n        _spaceX = -1;\n      }\n      if (!headerObject.vectors) {\n        volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n      } else {\n        var v = headerObject.vectors;\n        volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n      }\n      volume.inverseMatrix = new Matrix4();\n      volume.inverseMatrix.copy(volume.matrix).invert();\n      volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs); // .. and set the default threshold\n      // only if the threshold was not already set\n\n      if (volume.lowerThreshold === -Infinity) {\n        volume.lowerThreshold = min;\n      }\n      if (volume.upperThreshold === Infinity) {\n        volume.upperThreshold = max;\n      }\n      return volume;\n    }\n  }, {\n    key: \"parseChars\",\n    value: function parseChars(array, start, end) {\n      // without borders, use the whole array\n      if (start === undefined) {\n        start = 0;\n      }\n      if (end === undefined) {\n        end = array.length;\n      }\n      var output = ''; // create and append the chars\n\n      var i = 0;\n      for (i = start; i < end; ++i) {\n        output += String.fromCharCode(array[i]);\n      }\n      return output;\n    }\n  }]);\n  return NRRDLoader;\n}(Loader);\nvar _fieldFunctions = {\n  type: function type(data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array;\n        break;\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array;\n        break;\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array;\n        break;\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array;\n        break;\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array;\n        break;\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array;\n        break;\n      case 'float':\n        this.__array = Float32Array;\n        break;\n      case 'double':\n        this.__array = Float64Array;\n        break;\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data);\n    }\n    return this.type = data;\n  },\n  endian: function endian(data) {\n    return this.endian = data;\n  },\n  encoding: function encoding(data) {\n    return this.encoding = data;\n  },\n  dimension: function dimension(data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function sizes(data) {\n    var i;\n    return this.sizes = function () {\n      var _ref = data.split(/\\s+/);\n      var _results = [];\n      for (var _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n        _results.push(parseInt(i, 10));\n      }\n      return _results;\n    }();\n  },\n  space: function space(data) {\n    return this.space = data;\n  },\n  'space origin': function spaceOrigin(data) {\n    return this.space_origin = data.split('(')[1].split(')')[0].split(',');\n  },\n  'space directions': function spaceDirections(data) {\n    var f, v;\n    var parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      var _results = [];\n      for (var _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n        _results.push(function () {\n          var _ref = v.slice(1, -1).split(/,/);\n          var _results2 = [];\n          for (var _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n            _results2.push(parseFloat(f));\n          }\n          return _results2;\n        }());\n      }\n      return _results;\n    }();\n  },\n  spacings: function spacings(data) {\n    var f;\n    var parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      var _results = [];\n      for (var _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n        _results.push(parseFloat(f));\n      }\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };","map":null,"metadata":{},"sourceType":"module"}