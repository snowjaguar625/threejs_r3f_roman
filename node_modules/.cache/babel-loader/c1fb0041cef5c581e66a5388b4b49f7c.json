{"ast":null,"code":"import { BufferGeometry, Vector3, Quaternion, BufferAttribute, Raycaster } from 'three';\nvar RollerCoasterGeometry = function RollerCoasterGeometry(curve, divisions) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var normals = [];\n  var colors = [];\n  var color1 = [1, 1, 1];\n  var color2 = [1, 1, 0];\n  var up = new Vector3(0, 1, 0);\n  var forward = new Vector3();\n  var right = new Vector3();\n  var quaternion = new Quaternion();\n  var prevQuaternion = new Quaternion();\n  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\n  var point = new Vector3();\n  var prevPoint = new Vector3();\n  prevPoint.copy(curve.getPointAt(0)); // shapes\n\n  var step = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];\n  var PI2 = Math.PI * 2;\n  var sides = 5;\n  var tube1 = [];\n  for (var i = 0; i < sides; i++) {\n    var angle = i / sides * PI2;\n    tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));\n  }\n  var sides = 6;\n  var tube2 = [];\n  for (var _i = 0; _i < sides; _i++) {\n    var angle = _i / sides * PI2;\n    tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));\n  }\n  var vector = new Vector3();\n  var normal = new Vector3();\n  function drawShape(shape, color) {\n    normal.set(0, 0, -1).applyQuaternion(quaternion);\n    for (var j = 0; j < shape.length; j++) {\n      vector.copy(shape[j]);\n      vector.applyQuaternion(quaternion);\n      vector.add(point);\n      vertices.push(vector.x, vector.y, vector.z);\n      normals.push(normal.x, normal.y, normal.z);\n      colors.push(color[0], color[1], color[2]);\n    }\n    normal.set(0, 0, 1).applyQuaternion(quaternion);\n    for (var _j = shape.length - 1; _j >= 0; _j--) {\n      vector.copy(shape[_j]);\n      vector.applyQuaternion(quaternion);\n      vector.add(point);\n      vertices.push(vector.x, vector.y, vector.z);\n      normals.push(normal.x, normal.y, normal.z);\n      colors.push(color[0], color[1], color[2]);\n    }\n  }\n  var vector1 = new Vector3();\n  var vector2 = new Vector3();\n  var vector3 = new Vector3();\n  var vector4 = new Vector3();\n  var normal1 = new Vector3();\n  var normal2 = new Vector3();\n  var normal3 = new Vector3();\n  var normal4 = new Vector3();\n  function extrudeShape(shape, offset, color) {\n    for (var j = 0, jl = shape.length; j < jl; j++) {\n      var point1 = shape[j];\n      var point2 = shape[(j + 1) % jl];\n      vector1.copy(point1).add(offset);\n      vector1.applyQuaternion(quaternion);\n      vector1.add(point);\n      vector2.copy(point2).add(offset);\n      vector2.applyQuaternion(quaternion);\n      vector2.add(point);\n      vector3.copy(point2).add(offset);\n      vector3.applyQuaternion(prevQuaternion);\n      vector3.add(prevPoint);\n      vector4.copy(point1).add(offset);\n      vector4.applyQuaternion(prevQuaternion);\n      vector4.add(prevPoint);\n      vertices.push(vector1.x, vector1.y, vector1.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector4.x, vector4.y, vector4.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector3.x, vector3.y, vector3.z);\n      vertices.push(vector4.x, vector4.y, vector4.z); //\n\n      normal1.copy(point1);\n      normal1.applyQuaternion(quaternion);\n      normal1.normalize();\n      normal2.copy(point2);\n      normal2.applyQuaternion(quaternion);\n      normal2.normalize();\n      normal3.copy(point2);\n      normal3.applyQuaternion(prevQuaternion);\n      normal3.normalize();\n      normal4.copy(point1);\n      normal4.applyQuaternion(prevQuaternion);\n      normal4.normalize();\n      normals.push(normal1.x, normal1.y, normal1.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal3.x, normal3.y, normal3.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n    }\n  }\n  var offset = new Vector3();\n  for (var _i2 = 1; _i2 <= divisions; _i2++) {\n    point.copy(curve.getPointAt(_i2 / divisions));\n    up.set(0, 1, 0);\n    forward.subVectors(point, prevPoint).normalize();\n    right.crossVectors(up, forward).normalize();\n    up.crossVectors(forward, right);\n    var angle = Math.atan2(forward.x, forward.z);\n    quaternion.setFromAxisAngle(up, angle);\n    if (_i2 % 2 === 0) {\n      drawShape(step, color2);\n    }\n    extrudeShape(tube1, offset.set(0, -0.125, 0), color2);\n    extrudeShape(tube2, offset.set(0.2, 0, 0), color1);\n    extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);\n    prevPoint.copy(point);\n    prevQuaternion.copy(quaternion);\n  } // console.log( vertices.length );\n\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n  this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));\n  this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\n};\nRollerCoasterGeometry.prototype = Object.create(BufferGeometry.prototype);\nvar RollerCoasterLiftersGeometry = function RollerCoasterLiftersGeometry(curve, divisions) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var normals = [];\n  var quaternion = new Quaternion();\n  var up = new Vector3(0, 1, 0);\n  var point = new Vector3();\n  var tangent = new Vector3(); // shapes\n\n  var tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];\n  var tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];\n  var tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];\n  var vector1 = new Vector3();\n  var vector2 = new Vector3();\n  var vector3 = new Vector3();\n  var vector4 = new Vector3();\n  var normal1 = new Vector3();\n  var normal2 = new Vector3();\n  var normal3 = new Vector3();\n  var normal4 = new Vector3();\n  function extrudeShape(shape, fromPoint, toPoint) {\n    for (var j = 0, jl = shape.length; j < jl; j++) {\n      var point1 = shape[j];\n      var point2 = shape[(j + 1) % jl];\n      vector1.copy(point1);\n      vector1.applyQuaternion(quaternion);\n      vector1.add(fromPoint);\n      vector2.copy(point2);\n      vector2.applyQuaternion(quaternion);\n      vector2.add(fromPoint);\n      vector3.copy(point2);\n      vector3.applyQuaternion(quaternion);\n      vector3.add(toPoint);\n      vector4.copy(point1);\n      vector4.applyQuaternion(quaternion);\n      vector4.add(toPoint);\n      vertices.push(vector1.x, vector1.y, vector1.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector4.x, vector4.y, vector4.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector3.x, vector3.y, vector3.z);\n      vertices.push(vector4.x, vector4.y, vector4.z); //\n\n      normal1.copy(point1);\n      normal1.applyQuaternion(quaternion);\n      normal1.normalize();\n      normal2.copy(point2);\n      normal2.applyQuaternion(quaternion);\n      normal2.normalize();\n      normal3.copy(point2);\n      normal3.applyQuaternion(quaternion);\n      normal3.normalize();\n      normal4.copy(point1);\n      normal4.applyQuaternion(quaternion);\n      normal4.normalize();\n      normals.push(normal1.x, normal1.y, normal1.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal3.x, normal3.y, normal3.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n    }\n  }\n  var fromPoint = new Vector3();\n  var toPoint = new Vector3();\n  for (var i = 1; i <= divisions; i++) {\n    point.copy(curve.getPointAt(i / divisions));\n    tangent.copy(curve.getTangentAt(i / divisions));\n    var angle = Math.atan2(tangent.x, tangent.z);\n    quaternion.setFromAxisAngle(up, angle); //\n\n    if (point.y > 10) {\n      fromPoint.set(-0.75, -0.35, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(0.75, -0.35, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube1, fromPoint, toPoint);\n      fromPoint.set(-0.7, -0.3, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(-0.7, -point.y, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube2, fromPoint, toPoint);\n      fromPoint.set(0.7, -0.3, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(0.7, -point.y, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube3, fromPoint, toPoint);\n    } else {\n      fromPoint.set(0, -0.2, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(0, -point.y, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube3, fromPoint, toPoint);\n    }\n  }\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n  this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));\n};\nRollerCoasterLiftersGeometry.prototype = Object.create(BufferGeometry.prototype);\nvar RollerCoasterShadowGeometry = function RollerCoasterShadowGeometry(curve, divisions) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var up = new Vector3(0, 1, 0);\n  var forward = new Vector3();\n  var quaternion = new Quaternion();\n  var prevQuaternion = new Quaternion();\n  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\n  var point = new Vector3();\n  var prevPoint = new Vector3();\n  prevPoint.copy(curve.getPointAt(0));\n  prevPoint.y = 0;\n  var vector1 = new Vector3();\n  var vector2 = new Vector3();\n  var vector3 = new Vector3();\n  var vector4 = new Vector3();\n  for (var i = 1; i <= divisions; i++) {\n    point.copy(curve.getPointAt(i / divisions));\n    point.y = 0;\n    forward.subVectors(point, prevPoint);\n    var angle = Math.atan2(forward.x, forward.z);\n    quaternion.setFromAxisAngle(up, angle);\n    vector1.set(-0.3, 0, 0);\n    vector1.applyQuaternion(quaternion);\n    vector1.add(point);\n    vector2.set(0.3, 0, 0);\n    vector2.applyQuaternion(quaternion);\n    vector2.add(point);\n    vector3.set(0.3, 0, 0);\n    vector3.applyQuaternion(prevQuaternion);\n    vector3.add(prevPoint);\n    vector4.set(-0.3, 0, 0);\n    vector4.applyQuaternion(prevQuaternion);\n    vector4.add(prevPoint);\n    vertices.push(vector1.x, vector1.y, vector1.z);\n    vertices.push(vector2.x, vector2.y, vector2.z);\n    vertices.push(vector4.x, vector4.y, vector4.z);\n    vertices.push(vector2.x, vector2.y, vector2.z);\n    vertices.push(vector3.x, vector3.y, vector3.z);\n    vertices.push(vector4.x, vector4.y, vector4.z);\n    prevPoint.copy(point);\n    prevQuaternion.copy(quaternion);\n  }\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n};\nRollerCoasterShadowGeometry.prototype = Object.create(BufferGeometry.prototype);\nvar SkyGeometry = function SkyGeometry() {\n  BufferGeometry.call(this);\n  var vertices = [];\n  for (var i = 0; i < 100; i++) {\n    var x = Math.random() * 800 - 400;\n    var y = Math.random() * 50 + 50;\n    var z = Math.random() * 800 - 400;\n    var size = Math.random() * 40 + 20;\n    vertices.push(x - size, y, z - size);\n    vertices.push(x + size, y, z - size);\n    vertices.push(x - size, y, z + size);\n    vertices.push(x + size, y, z - size);\n    vertices.push(x + size, y, z + size);\n    vertices.push(x - size, y, z + size);\n  }\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n};\nSkyGeometry.prototype = Object.create(BufferGeometry.prototype);\nvar TreesGeometry = function TreesGeometry(landscape) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var colors = [];\n  var raycaster = new Raycaster();\n  raycaster.ray.direction.set(0, -1, 0);\n  for (var i = 0; i < 2000; i++) {\n    var x = Math.random() * 500 - 250;\n    var z = Math.random() * 500 - 250;\n    raycaster.ray.origin.set(x, 50, z);\n    var intersections = raycaster.intersectObject(landscape);\n    if (intersections.length === 0) continue;\n    var y = intersections[0].point.y;\n    var height = Math.random() * 5 + 0.5;\n    var angle = Math.random() * Math.PI * 2;\n    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\n    vertices.push(x, y + height, z);\n    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\n    angle += Math.PI / 2;\n    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\n    vertices.push(x, y + height, z);\n    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\n    var random = Math.random() * 0.1;\n    for (var j = 0; j < 6; j++) {\n      colors.push(0.2 + random, 0.4 + random, 0);\n    }\n  }\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n  this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\n};\nTreesGeometry.prototype = Object.create(BufferGeometry.prototype);\nexport { RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry };","map":null,"metadata":{},"sourceType":"module"}