{"ast":null,"code":"import _assertThisInitialized from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { createToken, Lexer, CstParser } from 'chevrotain';\nvar VRMLLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VRMLLoader, _Loader);\n  function VRMLLoader(manager) {\n    _classCallCheck(this, VRMLLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(VRMLLoader).call(this, manager));\n  }\n  _createClass(VRMLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, path) {\n      var nodeMap = {};\n      function generateVRMLTree(data) {\n        // create lexer, parser and visitor\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n        var lexingResult = lexer.lex(data);\n        parser.input = lexingResult.tokens; // parsing\n\n        var cstOutput = parser.vrml();\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\n        } // actions\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n      function createTokens() {\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n        var RouteIdentifier = createToken({\n          name: 'RouteIdentifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: 'Identifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform',\n        // grouping nodes\n        'Inline', 'LOD', 'Switch',\n        // special groups\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo',\n        // common nodes\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor',\n        // sensors\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere',\n        // geometries\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate',\n        // geometric properties\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform',\n        // appearance\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator',\n        // interpolators\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint',\n        // bindable nodes\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ]; //\n\n        var Version = createToken({\n          name: 'Version',\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: 'NodeName',\n          pattern: new RegExp(nodeTypes.join('|')),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: 'DEF',\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: 'USE',\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: 'ROUTE',\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: 'TO',\n          pattern: /TO/,\n          longer_alt: Identifier\n        }); //\n\n        var StringLiteral = createToken({\n          name: 'StringLiteral',\n          pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n        });\n        var HexLiteral = createToken({\n          name: 'HexLiteral',\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: 'NumberLiteral',\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: 'TrueLiteral',\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: 'FalseLiteral',\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: 'NullLiteral',\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: 'LSquare',\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: 'RSquare',\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: 'LCurly',\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: 'RCurly',\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: 'Comment',\n          pattern: /#.*/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n        var WhiteSpace = createToken({\n          name: 'WhiteSpace',\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED // eslint-disable-line no-undef\n        });\n\n        var tokens = [WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n      function createVisitor(BaseVRMLVisitor) {\n        // the visitor is created dynmaically based on the given base class\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function vrml(ctx) {\n            var data = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data.nodes.push(this.visit(node));\n            }\n            if (ctx.route) {\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\n                var route = ctx.route[_i];\n                data.routes.push(this.visit(route));\n              }\n            }\n            return data;\n          },\n          version: function version(ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function node(ctx) {\n            var data = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n            if (ctx.field) {\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data.fields.push(this.visit(field));\n              }\n            } // DEF\n\n            if (ctx.def) {\n              data.DEF = this.visit(ctx.def[0]);\n            }\n            return data;\n          },\n          field: function field(ctx) {\n            var data = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result; // SFValue\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            } // MFValue\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n            data.type = result.type;\n            data.values = result.values;\n            return data;\n          },\n          def: function def(ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function use(ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function singleFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function multiFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          route: function route(ctx) {\n            var data = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data;\n          }\n        });\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n          if (ctx.node) {\n            field.type = 'node';\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n          if (ctx.use) {\n            field.type = 'use';\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\n              var use = ctx.use[_i2];\n              field.values.push(scope.visit(use));\n            }\n          }\n          if (ctx.StringLiteral) {\n            field.type = 'string';\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\n              var stringLiteral = ctx.StringLiteral[_i3];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n            }\n          }\n          if (ctx.NumberLiteral) {\n            field.type = 'number';\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\n              var numberLiteral = ctx.NumberLiteral[_i4];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n          if (ctx.HexLiteral) {\n            field.type = 'hex';\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\n              var hexLiteral = ctx.HexLiteral[_i5];\n              field.values.push(hexLiteral.image);\n            }\n          }\n          if (ctx.TrueLiteral) {\n            field.type = 'boolean';\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\n              var trueLiteral = ctx.TrueLiteral[_i6];\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\n            }\n          }\n          if (ctx.FalseLiteral) {\n            field.type = 'boolean';\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\n              var falseLiteral = ctx.FalseLiteral[_i7];\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\n            }\n          }\n          if (ctx.NullLiteral) {\n            field.type = 'null';\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n          return field;\n        }\n        return new VRMLToASTVisitor();\n      }\n      function parseTree(tree) {\n        // console.log( JSON.stringify( tree, null, 2 ) );\n        var nodes = tree.nodes;\n        var scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        } // second iteration: build nodes\n\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\n          var _node = nodes[_i8];\n          var object = getNode(_node);\n          if (object instanceof Object3D) scene.add(object);\n          if (_node.name === 'WorldInfo') scene.userData.worldInfo = object;\n        }\n        return scene;\n      }\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          if (field.type === 'node') {\n            var fieldValues = field.values;\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n      function getNode(node) {\n        // handle case where a node refers to a different one\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n        if (node.build !== undefined) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      } // node builder\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n        switch (nodeName) {\n          case 'Group':\n          case 'Transform':\n          case 'Collision':\n            build = buildGroupingNode(node);\n            break;\n          case 'Background':\n            build = buildBackgroundNode(node);\n            break;\n          case 'Shape':\n            build = buildShapeNode(node);\n            break;\n          case 'Appearance':\n            build = buildAppearanceNode(node);\n            break;\n          case 'Material':\n            build = buildMaterialNode(node);\n            break;\n          case 'ImageTexture':\n            build = buildImageTextureNode(node);\n            break;\n          case 'PixelTexture':\n            build = buildPixelTextureNode(node);\n            break;\n          case 'TextureTransform':\n            build = buildTextureTransformNode(node);\n            break;\n          case 'IndexedFaceSet':\n            build = buildIndexedFaceSetNode(node);\n            break;\n          case 'IndexedLineSet':\n            build = buildIndexedLineSetNode(node);\n            break;\n          case 'PointSet':\n            build = buildPointSetNode(node);\n            break;\n          case 'Box':\n            build = buildBoxNode(node);\n            break;\n          case 'Cone':\n            build = buildConeNode(node);\n            break;\n          case 'Cylinder':\n            build = buildCylinderNode(node);\n            break;\n          case 'Sphere':\n            build = buildSphereNode(node);\n            break;\n          case 'ElevationGrid':\n            build = buildElevationGridNode(node);\n            break;\n          case 'Extrusion':\n            build = buildExtrusionNode(node);\n            break;\n          case 'Color':\n          case 'Coordinate':\n          case 'Normal':\n          case 'TextureCoordinate':\n            build = buildGeometricNode(node);\n            break;\n          case 'WorldInfo':\n            build = buildWorldInfoNode(node);\n            break;\n          case 'Anchor':\n          case 'Billboard':\n          case 'Inline':\n          case 'LOD':\n          case 'Switch':\n          case 'AudioClip':\n          case 'DirectionalLight':\n          case 'PointLight':\n          case 'Script':\n          case 'Sound':\n          case 'SpotLight':\n          case 'CylinderSensor':\n          case 'PlaneSensor':\n          case 'ProximitySensor':\n          case 'SphereSensor':\n          case 'TimeSensor':\n          case 'TouchSensor':\n          case 'VisibilitySensor':\n          case 'Text':\n          case 'FontStyle':\n          case 'MovieTexture':\n          case 'ColorInterpolator':\n          case 'CoordinateInterpolator':\n          case 'NormalInterpolator':\n          case 'OrientationInterpolator':\n          case 'PositionInterpolator':\n          case 'ScalarInterpolator':\n          case 'Fog':\n          case 'NavigationInfo':\n          case 'Viewpoint':\n            // node not supported yet\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n            break;\n        }\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n          build.name = node.DEF;\n        }\n        return build;\n      }\n      function buildGroupingNode(node) {\n        var object = new Group(); //\n\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'bboxCenter':\n              // field not supported\n              break;\n            case 'bboxSize':\n              // field not supported\n              break;\n            case 'center':\n              // field not supported\n              break;\n            case 'children':\n              parseFieldChildren(fieldValues, object);\n              break;\n            case 'collide':\n              // field not supported\n              break;\n            case 'rotation':\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n            case 'scale':\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'scaleOrientation':\n              // field not supported\n              break;\n            case 'translation':\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'proxy':\n              // field not supported\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return object;\n      }\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'groundAngle':\n              groundAngle = fieldValues;\n              break;\n            case 'groundColor':\n              groundColor = fieldValues;\n              break;\n            case 'backUrl':\n              // field not supported\n              break;\n            case 'bottomUrl':\n              // field not supported\n              break;\n            case 'frontUrl':\n              // field not supported\n              break;\n            case 'leftUrl':\n              // field not supported\n              break;\n            case 'rightUrl':\n              // field not supported\n              break;\n            case 'topUrl':\n              // field not supported\n              break;\n            case 'skyAngle':\n              skyAngle = fieldValues;\n              break;\n            case 'skyColor':\n              skyColor = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var radius = 10000; // sky\n\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        } // ground\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        } // render background group first\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n      function buildShapeNode(node) {\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n        var material = new MeshBasicMaterial({\n          color: 0x000000\n        });\n        var geometry;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'appearance':\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n              break;\n            case 'geometry':\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build 3D object\n\n        var object;\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n          if (type === 'points') {\n            // points\n            var pointsMaterial = new PointsMaterial({\n              color: 0xffffff\n            });\n            if (geometry.attributes.color !== undefined) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === 'line') {\n            // lines\n            var lineMaterial = new LineBasicMaterial({\n              color: 0xffffff\n            });\n            if (geometry.attributes.color !== undefined) {\n              lineMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            // consider meshes\n            // check \"solid\" hint (it's placed in the geometry but affects the material)\n            if (geometry._solid !== undefined) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            } // check for vertex colors\n\n            if (geometry.attributes.color !== undefined) {\n              material.vertexColors = true;\n            }\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n          object.visible = false;\n        }\n        return object;\n      }\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'material':\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n                material = new MeshBasicMaterial({\n                  color: 0x000000\n                });\n              }\n              break;\n            case 'texture':\n              var textureNode = fieldValues[0];\n              if (textureNode !== null) {\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                  material.map = getNode(textureNode);\n                }\n              }\n              break;\n            case 'textureTransform':\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // only apply texture transform data if a texture was defined\n\n        if (material.map) {\n          // respect VRML lighting model\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1; // ignore transparency\n\n                break;\n              case TEXTURE_TYPE.RGB:\n                material.color.set(0xffffff); // ignore material color\n\n                break;\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(0xffffff); // ignore material color\n\n                material.opacity = 1; // ignore transparency\n\n                break;\n            }\n            delete material.map.__type;\n          } // apply texture transform\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n        return material;\n      }\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'ambientIntensity':\n              // field not supported\n              break;\n            case 'diffuseColor':\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'emissiveColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'shininess':\n              materialData.shininess = fieldValues[0];\n              break;\n            case 'specularColor':\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case 'transparency':\n              materialData.transparency = fieldValues[0];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return materialData;\n      }\n      function parseHexColor(hex, textureType, color) {\n        var value;\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n            value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = 1;\n            break;\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n            value = parseInt('0x' + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt('0x' + hex.substring(4, 6));\n            break;\n          case TEXTURE_TYPE.RGB:\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = 1;\n            break;\n          case TEXTURE_TYPE.RGBA:\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = parseInt('0x' + hex.substring(8, 10));\n            break;\n        }\n      }\n      function getTextureType(num_components) {\n        var type;\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n        return type;\n      }\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'image':\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var textureType = getTextureType(num_components);\n              var _data = new Uint8Array(4 * width * height);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n                var stride = k * 4;\n                _data[stride + 0] = color.r;\n                _data[stride + 1] = color.g;\n                _data[stride + 2] = color.b;\n                _data[stride + 3] = color.a;\n              }\n              texture = new DataTexture(_data, width, height);\n              texture.needsUpdate = true;\n              texture.__type = textureType; // needed for material modifications\n\n              break;\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'url':\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'center':\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n            case 'rotation':\n              transformData.rotation = fieldValues[0];\n              break;\n            case 'scale':\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n            case 'translation':\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return transformData;\n      }\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'title':\n              worldInfo.title = fieldValues[0];\n              break;\n            case 'info':\n              worldInfo.info = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        return worldInfo;\n      }\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n          solid = true,\n          creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n          normalPerVertex = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'coord':\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case 'normal':\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n            case 'convex':\n              // field not supported\n              break;\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n            case 'normalIndex':\n              normalIndex = fieldValues;\n              break;\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n            case 'texCoordIndex':\n              texCoordIndex = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        if (coordIndex === undefined) {\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\n          return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n        }\n\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n              var _triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceColors);\n            }\n          }\n        }\n        if (normal) {\n          if (normalPerVertex === true) {\n            // consider vertex normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            // consider face normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n              var _triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceNormals);\n            }\n          }\n        } else {\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n        if (texCoord) {\n          // texture coordinates are always defined on vertex level\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'coord':\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build lines\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              var _expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, _expandedLineColors); // compute data on vertex level\n            }\n          }\n        } //\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        geometry._type = 'line';\n        return geometry;\n      }\n      function buildPointSetNode(node) {\n        var color, coord;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'coord':\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n        geometry._type = 'points';\n        return geometry;\n      }\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'size':\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n      function buildConeNode(node) {\n        var radius = 1,\n          height = 2,\n          openEnded = false;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'bottom':\n              openEnded = !fieldValues[0];\n              break;\n            case 'bottomRadius':\n              radius = fieldValues[0];\n              break;\n            case 'height':\n              height = fieldValues[0];\n              break;\n            case 'side':\n              // field not supported\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n      function buildCylinderNode(node) {\n        var radius = 1,\n          height = 2;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'bottom':\n              // field not supported\n              break;\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n            case 'height':\n              height = fieldValues[0];\n              break;\n            case 'side':\n              // field not supported\n              break;\n            case 'top':\n              // field not supported\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case 'normal':\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case 'height':\n              height = fieldValues;\n              break;\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n            case 'xDimension':\n              xDimension = fieldValues[0];\n              break;\n            case 'xSpacing':\n              xSpacing = fieldValues[0];\n              break;\n            case 'zDimension':\n              zDimension = fieldValues[0];\n              break;\n            case 'zSpacing':\n              zSpacing = fieldValues[0];\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // vertex data\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\n          for (var j = 0; j < xDimension; j++) {\n            // compute a row major index\n            var index = _i9 * xDimension + j; // vertices\n\n            var x = xSpacing * _i9;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z); // colors\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            } // normals\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            } // uvs\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        } // indices\n\n        var indices = [];\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\n          for (var _j = 0; _j < zDimension - 1; _j++) {\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n            var a = _i10 + _j * xDimension;\n            var _b = _i10 + (_j + 1) * xDimension;\n            var c = _i10 + 1 + (_j + 1) * xDimension;\n            var d = _i10 + 1 + _j * xDimension; // faces\n\n            if (ccw === true) {\n              indices.push(a, c, _b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, _b, c);\n              indices.push(c, d, a);\n            }\n          }\n        } //\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute; // color attribute\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\n                var _index = _i11 + _j2 * (xDimension - 1);\n                var _r = color[_index * 3 + 0];\n                var _g = color[_index * 3 + 1];\n                var _b2 = color[_index * 3 + 2]; // one color per quad\n\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n              }\n            }\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        } // normal attribute\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\n                var _index2 = _i12 + _j3 * (xDimension - 1);\n                var _xn = normal[_index2 * 3 + 0];\n                var _yn = normal[_index2 * 3 + 1];\n                var _zn = normal[_index2 * 3 + 2]; // one normal per quad\n\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n              }\n            }\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        } // build geometry\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute);\n        geometry.setAttribute('uv', uvAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case 'beginCap':\n              beginCap = fieldValues[0];\n              break;\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n            case 'convex':\n              // field not supported\n              break;\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n            case 'crossSection':\n              crossSection = fieldValues;\n              break;\n            case 'endCap':\n              endCap = fieldValues[0];\n              break;\n            case 'orientation':\n              orientation = fieldValues;\n              break;\n            case 'scale':\n              scale = fieldValues;\n              break;\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n            case 'spine':\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n              break;\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, _i13);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1]; // scale\n\n            vertex.multiply(scaling); // rotate\n\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion); // translate\n\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        } // indices\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\n            var a = _j4 + _i14 * crossSectionCount;\n            var b = _j4 + 1 + _i14 * crossSectionCount;\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = _i14 * crossSectionCount;\n              d = (_i14 + 1) * crossSectionCount;\n            }\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        } // triangulate cap\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\n            contour.push(new Vector2(crossSection[_i15], crossSection[_i15 + 1]));\n          }\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\n            var face = faces[_i16];\n            capIndices.push(face[0], face[1], face[2]);\n          } // begin cap\n\n          if (beginCap === true) {\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\n              } else {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\n              }\n            }\n          } // end cap\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\n              }\n            }\n          }\n        }\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\n        // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      } // helper functions\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n        // any side effects\n\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n      function parseFieldChildren(children, owner) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n      function triangulateFaceIndex(index, ccw) {\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\n        // perform a simple triangulation\n\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n        return indices;\n      }\n      function triangulateFaceData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      function flattenData(data, index) {\n        var flattenData = [];\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          flattenData.push(x, y, z);\n        }\n        return flattenData;\n      }\n      function expandLineIndex(index) {\n        var indices = [];\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n        return indices;\n      }\n      function expandLineData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          if (itemSize === 2) {\n            uvA.fromArray(data, a * itemSize);\n            uvB.fromArray(data, b * itemSize);\n            uvC.fromArray(data, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data, a * itemSize);\n            vB.fromArray(data, b * itemSize);\n            vC.fromArray(data, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n        return new Float32BufferAttribute(array, itemSize);\n      }\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n          index2 = 0;\n        for (var i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n      var ab = new Vector3();\n      var cb = new Vector3();\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {}; // prepare face and raw vertex normals\n\n        for (var i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        } // compute vertex normals and build final geometry\n\n        var normals = [];\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\n          var _face = faces[_i19];\n          var nA = weightedNormal(vertexNormals[_face.a], _face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[_face.b], _face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[_face.c], _face.normal, creaseAngle);\n          vA.fromArray(coord, _face.a * 3);\n          vB.fromArray(coord, _face.b * 3);\n          vC.fromArray(coord, _face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n        return new Float32BufferAttribute(normals, 3);\n      }\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (var i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n        return normal.normalize();\n      }\n      function toColorArray(colors) {\n        var array = [];\n        for (var i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n        return array;\n      }\n      /**\n       * Vertically paints the faces interpolating between the\n       * specified colors at the specified angels. This is used for the Background\n       * node, but could be applied to other nodes with multiple faces as well.\n       *\n       * When used with the Background node, default is directionIsDown is true if\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n       *\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n       * is linear along the Y axis in any case.\n       *\n       * You must specify one more color than you have angles at the beginning of the colors array.\n       * This is the color of the Zenith (the top of the shape).\n       *\n       * @param {BufferGeometry} geometry\n       * @param {number} radius\n       * @param {array} angles\n       * @param {array} colors\n       * @param {boolean} topDown - Whether to work top down or bottom up.\n       */\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        // compute threshold values\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n        for (var i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        } // generate vertex colors\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\n          var index = indices.getX(_i20);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA = void 0,\n            thresholdIndexB = void 0;\n          var t = 1;\n          for (var j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n            if (topDown === true) {\n              // interpolation for sky color\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              // interpolation for ground color\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n        geometry.setAttribute('color', colorAttribute);\n      } //\n\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n      if (data.indexOf('#VRML V2.0') === -1) {\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n      } // create JSON representing the tree structure of the VRML asset\n\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n      var scene = parseTree(tree);\n      return scene;\n    }\n  }]);\n  return VRMLLoader;\n}(Loader);\nvar VRMLLexer = /*#__PURE__*/function () {\n  function VRMLLexer(tokens) {\n    _classCallCheck(this, VRMLLexer);\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n  _createClass(VRMLLexer, [{\n    key: \"lex\",\n    value: function lex(inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\n      }\n      return lexingResult;\n    }\n  }]);\n  return VRMLLexer;\n}();\nvar VRMLParser = /*#__PURE__*/function (_CstParser) {\n  _inherits(VRMLParser, _CstParser);\n  function VRMLParser(tokenVocabulary) {\n    var _this;\n    _classCallCheck(this, VRMLParser);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VRMLParser).call(this, tokenVocabulary));\n    var $ = _assertThisInitialized(_assertThisInitialized(_this));\n    var Version = tokenVocabulary['Version'];\n    var LCurly = tokenVocabulary['LCurly'];\n    var RCurly = tokenVocabulary['RCurly'];\n    var LSquare = tokenVocabulary['LSquare'];\n    var RSquare = tokenVocabulary['RSquare'];\n    var Identifier = tokenVocabulary['Identifier'];\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    var StringLiteral = tokenVocabulary['StringLiteral'];\n    var HexLiteral = tokenVocabulary['HexLiteral'];\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\n    var NullLiteral = tokenVocabulary['NullLiteral'];\n    var DEF = tokenVocabulary['DEF'];\n    var USE = tokenVocabulary['USE'];\n    var ROUTE = tokenVocabulary['ROUTE'];\n    var TO = tokenVocabulary['TO'];\n    var NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function ALT() {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function ALT() {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    _this.performSelfAnalysis();\n    return _this;\n  }\n  return VRMLParser;\n}(CstParser);\nvar Face = function Face(a, b, c) {\n  _classCallCheck(this, Face);\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = new Vector3();\n};\nvar TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":null,"metadata":{},"sourceType":"module"}