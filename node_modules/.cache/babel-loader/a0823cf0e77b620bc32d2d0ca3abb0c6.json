{"ast":null,"code":"import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );',\n    //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;',\n    // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));',\n    // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function reset() {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n\n  setAdaptive: function setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\nexport { AdaptiveToneMappingPass };","map":null,"metadata":{},"sourceType":"module"}