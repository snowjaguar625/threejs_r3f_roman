{"ast":null,"code":"import _objectSpread from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Loader, FileLoader, ShapePath } from 'three';\nvar FontLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(FontLoader, _Loader);\n  function FontLoader(manager) {\n    _classCallCheck(this, FontLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(FontLoader).call(this, manager));\n  }\n  _createClass(FontLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (response) {\n        if (typeof response !== 'string') throw new Error('unsupported data type');\n        var json = JSON.parse(response);\n        var font = _this.parse(json);\n        if (onLoad) onLoad(font);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(json) {\n      return new Font(json);\n    }\n  }]);\n  return FontLoader;\n}(Loader);\nvar Font = /*#__PURE__*/function () {\n  function Font(data) {\n    _classCallCheck(this, Font);\n    _defineProperty(this, \"data\", void 0);\n    this.data = data;\n  }\n  _createClass(Font, [{\n    key: \"generateShapes\",\n    value: function generateShapes(text) {\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var _options = arguments.length > 2 ? arguments[2] : undefined;\n      var shapes = [];\n      var options = _objectSpread({\n        letterSpacing: 0,\n        lineHeight: 1\n      }, _options);\n      var paths = createPaths(text, size, this.data, options);\n      for (var p = 0, pl = paths.length; p < pl; p++) {\n        Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n      }\n      return shapes;\n    }\n  }]);\n  return Font;\n}();\n_defineProperty(Font, \"isFont\", void 0);\n_defineProperty(Font, \"type\", void 0);\nfunction createPaths(text, size, data, options) {\n  var chars = Array.from(text);\n  var scale = size / data.resolution;\n  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  var paths = [];\n  var offsetX = 0,\n    offsetY = 0;\n  for (var i = 0; i < chars.length; i++) {\n    var char = chars[i];\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      var ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  var glyph = data.glyphs[char] || data.glyphs['?'];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n  var path = new ShapePath();\n  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n    for (var i = 0, l = outline.length; i < l;) {\n      var action = outline[i++];\n      switch (action) {\n        case 'm':\n          // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case 'l':\n          // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case 'q':\n          // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case 'b':\n          // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path: path\n  };\n}\nexport { Font, FontLoader };","map":null,"metadata":{},"sourceType":"module"}