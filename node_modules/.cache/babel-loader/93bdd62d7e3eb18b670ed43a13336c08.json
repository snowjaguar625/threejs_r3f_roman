{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Frustum, Vector3 } from 'three';\n\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nvar SelectionBox = function () {\n  var frustum = new Frustum();\n  var center = new Vector3();\n  var tmpPoint = new Vector3();\n  var vecNear = new Vector3();\n  var vecTopLeft = new Vector3();\n  var vecTopRight = new Vector3();\n  var vecDownRight = new Vector3();\n  var vecDownLeft = new Vector3();\n  var vecFarTopLeft = new Vector3();\n  var vecFarTopRight = new Vector3();\n  var vecFarDownRight = new Vector3();\n  var vecFarDownLeft = new Vector3();\n  var vectemp1 = new Vector3();\n  var vectemp2 = new Vector3();\n  var vectemp3 = new Vector3();\n  var SelectionBox = /*#__PURE__*/function () {\n    function SelectionBox(camera, scene, deep) {\n      _classCallCheck(this, SelectionBox);\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n    _createClass(SelectionBox, [{\n      key: \"select\",\n      value: function select(startPoint, endPoint) {\n        this.startPoint = startPoint || this.startPoint;\n        this.endPoint = endPoint || this.endPoint;\n        this.collection = [];\n        this.updateFrustum(this.startPoint, this.endPoint);\n        this.searchChildInFrustum(frustum, this.scene);\n        return this.collection;\n      }\n    }, {\n      key: \"updateFrustum\",\n      value: function updateFrustum(startPoint, endPoint) {\n        startPoint = startPoint || this.startPoint;\n        endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n        if (startPoint.x === endPoint.x) {\n          endPoint.x += Number.EPSILON;\n        }\n        if (startPoint.y === endPoint.y) {\n          endPoint.y += Number.EPSILON;\n        }\n        this.camera.updateProjectionMatrix();\n        this.camera.updateMatrixWorld();\n        if (this.camera.isPerspectiveCamera) {\n          tmpPoint.copy(startPoint);\n          tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n          tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n          endPoint.x = Math.max(startPoint.x, endPoint.x);\n          endPoint.y = Math.min(startPoint.y, endPoint.y);\n          vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n          vecTopLeft.copy(tmpPoint);\n          vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n          vecDownRight.copy(endPoint);\n          vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n          vecTopLeft.unproject(this.camera);\n          vecTopRight.unproject(this.camera);\n          vecDownRight.unproject(this.camera);\n          vecDownLeft.unproject(this.camera);\n          vectemp1.copy(vecTopLeft).sub(vecNear);\n          vectemp2.copy(vecTopRight).sub(vecNear);\n          vectemp3.copy(vecDownRight).sub(vecNear);\n          vectemp1.normalize();\n          vectemp2.normalize();\n          vectemp3.normalize();\n          vectemp1.multiplyScalar(this.deep);\n          vectemp2.multiplyScalar(this.deep);\n          vectemp3.multiplyScalar(this.deep);\n          vectemp1.add(vecNear);\n          vectemp2.add(vecNear);\n          vectemp3.add(vecNear);\n          var planes = frustum.planes;\n          planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n          planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n          planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n          planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n          planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n          planes[5].normal.multiplyScalar(-1);\n        } else if (this.camera.isOrthographicCamera) {\n          var left = Math.min(startPoint.x, endPoint.x);\n          var top = Math.max(startPoint.y, endPoint.y);\n          var right = Math.max(startPoint.x, endPoint.x);\n          var down = Math.min(startPoint.y, endPoint.y);\n          vecTopLeft.set(left, top, -1);\n          vecTopRight.set(right, top, -1);\n          vecDownRight.set(right, down, -1);\n          vecDownLeft.set(left, down, -1);\n          vecFarTopLeft.set(left, top, 1);\n          vecFarTopRight.set(right, top, 1);\n          vecFarDownRight.set(right, down, 1);\n          vecFarDownLeft.set(left, down, 1);\n          vecTopLeft.unproject(this.camera);\n          vecTopRight.unproject(this.camera);\n          vecDownRight.unproject(this.camera);\n          vecDownLeft.unproject(this.camera);\n          vecFarTopLeft.unproject(this.camera);\n          vecFarTopRight.unproject(this.camera);\n          vecFarDownRight.unproject(this.camera);\n          vecFarDownLeft.unproject(this.camera);\n          var planes = frustum.planes;\n          planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n          planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n          planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n          planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n          planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n          planes[5].normal.multiplyScalar(-1);\n        } else {\n          console.error('THREE.SelectionBox: Unsupported camera type.');\n        }\n      }\n    }, {\n      key: \"searchChildInFrustum\",\n      value: function searchChildInFrustum(frustum, object) {\n        if (object.isMesh || object.isLine || object.isPoints) {\n          if (object.material !== undefined) {\n            if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n            center.copy(object.geometry.boundingSphere.center);\n            center.applyMatrix4(object.matrixWorld);\n            if (frustum.containsPoint(center)) {\n              this.collection.push(object);\n            }\n          }\n        }\n        if (object.children.length > 0) {\n          for (var x = 0; x < object.children.length; x++) {\n            this.searchChildInFrustum(frustum, object.children[x]);\n          }\n        }\n      }\n    }]);\n    return SelectionBox;\n  }();\n  return SelectionBox;\n}();\nexport { SelectionBox };","map":null,"metadata":{},"sourceType":"module"}