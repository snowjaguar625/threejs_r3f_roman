{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader } from 'three';\nimport { parse as _parse } from 'opentype.js';\n\n/**\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\nvar TTFLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(TTFLoader, _Loader);\n  function TTFLoader(manager) {\n    var _this;\n    _classCallCheck(this, TTFLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TTFLoader).call(this, manager));\n    _this.reversed = false;\n    return _this;\n  }\n  _createClass(TTFLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(_parse(buffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(arraybuffer) {\n      function convert(font, reversed) {\n        var round = Math.round;\n        var glyphs = {};\n        var scale = 100000 / ((font.unitsPerEm || 2048) * 72);\n        var glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n        var unicodes = Object.keys(glyphIndexMap);\n        for (var i = 0; i < unicodes.length; i++) {\n          var unicode = unicodes[i];\n          var glyph = font.glyphs.glyphs[glyphIndexMap[unicode]];\n          if (unicode !== undefined) {\n            (function () {\n              var token = {\n                ha: round(glyph.advanceWidth * scale),\n                x_min: round(glyph.xMin * scale),\n                x_max: round(glyph.xMax * scale),\n                o: ''\n              };\n              if (reversed) {\n                glyph.path.commands = reverseCommands(glyph.path.commands);\n              }\n              glyph.path.commands.forEach(function (command) {\n                if (command.type.toLowerCase() === 'c') {\n                  command.type = 'b';\n                }\n                token.o += command.type.toLowerCase() + ' ';\n                if (command.x !== undefined && command.y !== undefined) {\n                  token.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' ';\n                }\n                if (command.x1 !== undefined && command.y1 !== undefined) {\n                  token.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' ';\n                }\n                if (command.x2 !== undefined && command.y2 !== undefined) {\n                  token.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' ';\n                }\n              });\n              glyphs[String.fromCodePoint(glyph.unicode)] = token;\n            })();\n          }\n        }\n        return {\n          glyphs: glyphs,\n          familyName: font.getEnglishName('fullName'),\n          ascender: round(font.ascender * scale),\n          descender: round(font.descender * scale),\n          underlinePosition: font.tables.post.underlinePosition,\n          underlineThickness: font.tables.post.underlineThickness,\n          boundingBox: {\n            xMin: font.tables.head.xMin,\n            xMax: font.tables.head.xMax,\n            yMin: font.tables.head.yMin,\n            yMax: font.tables.head.yMax\n          },\n          resolution: 1000,\n          original_font_information: font.tables.name\n        };\n      }\n      function reverseCommands(commands) {\n        var paths = [];\n        var path;\n        commands.forEach(function (c) {\n          if (c.type.toLowerCase() === 'm') {\n            path = [c];\n            paths.push(path);\n          } else if (c.type.toLowerCase() !== 'z') {\n            path.push(c);\n          }\n        });\n        var reversed = [];\n        paths.forEach(function (p) {\n          var result = {\n            type: 'm',\n            x: p[p.length - 1].x,\n            y: p[p.length - 1].y\n          };\n          reversed.push(result);\n          for (var i = p.length - 1; i > 0; i--) {\n            var command = p[i];\n            var _result = {\n              type: command.type\n            };\n            if (command.x2 !== undefined && command.y2 !== undefined) {\n              _result.x1 = command.x2;\n              _result.y1 = command.y2;\n              _result.x2 = command.x1;\n              _result.y2 = command.y1;\n            } else if (command.x1 !== undefined && command.y1 !== undefined) {\n              _result.x1 = command.x1;\n              _result.y1 = command.y1;\n            }\n            _result.x = p[i - 1].x;\n            _result.y = p[i - 1].y;\n            reversed.push(_result);\n          }\n        });\n        return reversed;\n      }\n      return convert(_parse(arraybuffer), this.reversed); // eslint-disable-line no-undef\n    }\n  }]);\n  return TTFLoader;\n}(Loader);\nexport { TTFLoader };","map":null,"metadata":{},"sourceType":"module"}