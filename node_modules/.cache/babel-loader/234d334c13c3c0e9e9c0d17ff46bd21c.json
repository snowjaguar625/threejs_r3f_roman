{"ast":null,"code":"import { Vector3, Matrix3, Box3, Matrix4, Ray, MathUtils } from 'three';\nvar a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n};\n\nvar b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n};\n\nvar R = [[], [], []];\nvar AbsR = [[], [], []];\nvar t = [];\nvar xAxis = new Vector3();\nvar yAxis = new Vector3();\nvar zAxis = new Vector3();\nvar v1 = new Vector3();\nvar size = new Vector3();\nvar closestPoint = new Vector3();\nvar rotationMatrix = new Matrix3();\nvar aabb = new Box3();\nvar matrix = new Matrix4();\nvar inverse = new Matrix4();\nvar localRay = new Ray(); // OBB\n\nfunction OBB() {\n  var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n  var halfSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n  var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Matrix3();\n  this.center = center;\n  this.halfSize = halfSize;\n  this.rotation = rotation;\n}\nObject.assign(OBB.prototype, {\n  set: function set(center, halfSize, rotation) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n    return this;\n  },\n  copy: function copy(obb) {\n    this.center.copy(obb.center);\n    this.halfSize.copy(obb.halfSize);\n    this.rotation.copy(obb.rotation);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  getSize: function getSize(result) {\n    return result.copy(this.halfSize).multiplyScalar(2);\n  },\n  /**\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.1.4)\n   */\n  clampPoint: function clampPoint(point, result) {\n    var halfSize = this.halfSize;\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // start at the center position of the OBB\n\n    result.copy(this.center); // project the target onto the OBB axes and walk towards that point\n\n    var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\n    result.add(xAxis.multiplyScalar(x));\n    var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\n    result.add(yAxis.multiplyScalar(y));\n    var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\n    result.add(zAxis.multiplyScalar(z));\n    return result;\n  },\n  containsPoint: function containsPoint(point) {\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // project v1 onto each axis and check if these points lie inside the OBB\n\n    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\n  },\n  intersectsBox3: function intersectsBox3(box3) {\n    return this.intersectsOBB(obb.fromBox3(box3));\n  },\n  intersectsSphere: function intersectsSphere(sphere) {\n    // find the point on the OBB closest to the sphere center\n    this.clampPoint(sphere.center, closestPoint); // if that point is inside the sphere, the OBB and sphere intersect\n\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  },\n  /**\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n   * by Christer Ericson (chapter 4.4.1)\n   *\n   */\n  intersectsOBB: function intersectsOBB(obb) {\n    var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.EPSILON;\n    // prepare data structures (the code uses the same nomenclature like the reference)\n    a.c = this.center;\n    a.e[0] = this.halfSize.x;\n    a.e[1] = this.halfSize.y;\n    a.e[2] = this.halfSize.z;\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n    b.c = obb.center;\n    b.e[0] = obb.halfSize.x;\n    b.e[1] = obb.halfSize.y;\n    b.e[2] = obb.halfSize.z;\n    obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2]); // compute rotation matrix expressing b in a's coordinate frame\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j]);\n      }\n    } // compute translation vector\n\n    v1.subVectors(b.c, a.c); // bring translation into a's coordinate frame\n\n    t[0] = v1.dot(a.u[0]);\n    t[1] = v1.dot(a.u[1]);\n    t[2] = v1.dot(a.u[2]); // compute common subexpressions. Add in an epsilon term to\n    // counteract arithmetic errors when two edges are parallel and\n    // their cross product is (near) null\n\n    for (var _i = 0; _i < 3; _i++) {\n      for (var _j = 0; _j < 3; _j++) {\n        AbsR[_i][_j] = Math.abs(R[_i][_j]) + epsilon;\n      }\n    }\n    var ra, rb; // test axes L = A0, L = A1, L = A2\n\n    for (var _i2 = 0; _i2 < 3; _i2++) {\n      ra = a.e[_i2];\n      rb = b.e[0] * AbsR[_i2][0] + b.e[1] * AbsR[_i2][1] + b.e[2] * AbsR[_i2][2];\n      if (Math.abs(t[_i2]) > ra + rb) return false;\n    } // test axes L = B0, L = B1, L = B2\n\n    for (var _i3 = 0; _i3 < 3; _i3++) {\n      ra = a.e[0] * AbsR[0][_i3] + a.e[1] * AbsR[1][_i3] + a.e[2] * AbsR[2][_i3];\n      rb = b.e[_i3];\n      if (Math.abs(t[0] * R[0][_i3] + t[1] * R[1][_i3] + t[2] * R[2][_i3]) > ra + rb) return false;\n    } // test axis L = A0 x B0\n\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false; // test axis L = A0 x B1\n\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false; // test axis L = A0 x B2\n\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false; // test axis L = A1 x B0\n\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false; // test axis L = A1 x B1\n\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false; // test axis L = A1 x B2\n\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false; // test axis L = A2 x B0\n\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false; // test axis L = A2 x B1\n\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false; // test axis L = A2 x B2\n\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false; // since no separating axis is found, the OBBs must be intersecting\n\n    return true;\n  },\n  /**\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.2.3)\n   */\n  intersectsPlane: function intersectsPlane(plane) {\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n    var r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis)); // compute distance of the OBB's center from the plane\n\n    var d = plane.normal.dot(this.center) - plane.constant; // Intersection occurs when distance d falls within [-r,+r] interval\n\n    return Math.abs(d) <= r;\n  },\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\n   */\n  intersectRay: function intersectRay(ray, result) {\n    // the idea is to perform the intersection test in the local space\n    // of the OBB.\n    this.getSize(size);\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size); // create a 4x4 transformation matrix\n\n    matrix4FromRotationMatrix(matrix, this.rotation);\n    matrix.setPosition(this.center); // transform ray to the local space of the OBB\n\n    inverse.copy(matrix).invert();\n    localRay.copy(ray).applyMatrix4(inverse); // perform ray <-> AABB intersection test\n\n    if (localRay.intersectBox(aabb, result)) {\n      // transform the intersection point back to world space\n      return result.applyMatrix4(matrix);\n    } else {\n      return null;\n    }\n  },\n  /**\n   * Performs a ray/OBB intersection test. Returns either true or false if\n   * there is a intersection or not.\n   */\n  intersectsRay: function intersectsRay(ray) {\n    return this.intersectRay(ray, v1) !== null;\n  },\n  fromBox3: function fromBox3(box3) {\n    box3.getCenter(this.center);\n    box3.getSize(this.halfSize).multiplyScalar(0.5);\n    this.rotation.identity();\n    return this;\n  },\n  equals: function equals(obb) {\n    return obb.center.equals(this.center) && obb.halfSize.equals(this.halfSize) && obb.rotation.equals(this.rotation);\n  },\n  applyMatrix4: function applyMatrix4(matrix) {\n    var e = matrix.elements;\n    var sx = v1.set(e[0], e[1], e[2]).length();\n    var sy = v1.set(e[4], e[5], e[6]).length();\n    var sz = v1.set(e[8], e[9], e[10]).length();\n    var det = matrix.determinant();\n    if (det < 0) sx = -sx;\n    rotationMatrix.setFromMatrix4(matrix);\n    var invSX = 1 / sx;\n    var invSY = 1 / sy;\n    var invSZ = 1 / sz;\n    rotationMatrix.elements[0] *= invSX;\n    rotationMatrix.elements[1] *= invSX;\n    rotationMatrix.elements[2] *= invSX;\n    rotationMatrix.elements[3] *= invSY;\n    rotationMatrix.elements[4] *= invSY;\n    rotationMatrix.elements[5] *= invSY;\n    rotationMatrix.elements[6] *= invSZ;\n    rotationMatrix.elements[7] *= invSZ;\n    rotationMatrix.elements[8] *= invSZ;\n    this.rotation.multiply(rotationMatrix);\n    this.halfSize.x *= sx;\n    this.halfSize.y *= sy;\n    this.halfSize.z *= sz;\n    v1.setFromMatrixPosition(matrix);\n    this.center.add(v1);\n    return this;\n  }\n});\nfunction matrix4FromRotationMatrix(matrix4, matrix3) {\n  var e = matrix4.elements;\n  var me = matrix3.elements;\n  e[0] = me[0];\n  e[1] = me[1];\n  e[2] = me[2];\n  e[3] = 0;\n  e[4] = me[3];\n  e[5] = me[4];\n  e[6] = me[5];\n  e[7] = 0;\n  e[8] = me[6];\n  e[9] = me[7];\n  e[10] = me[8];\n  e[11] = 0;\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = 0;\n  e[15] = 1;\n}\nvar obb = new OBB();\nexport { OBB };","map":null,"metadata":{},"sourceType":"module"}