{"ast":null,"code":"import _defineProperty from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar aabb = /* @__PURE__ */new Box3();\nvar aabb2 = /* @__PURE__ */new Box3();\nvar tempMatrix = /* @__PURE__ */new Matrix4();\nvar obb = /* @__PURE__ */new OrientedBox();\nvar obb2 = /* @__PURE__ */new OrientedBox();\nvar temp = /* @__PURE__ */new Vector3();\nvar temp1 = /* @__PURE__ */new Vector3();\nvar temp2 = /* @__PURE__ */new Vector3();\nvar temp3 = /* @__PURE__ */new Vector3();\nvar temp4 = /* @__PURE__ */new Vector3();\nvar tempBox = /* @__PURE__ */new Box3();\nvar trianglePool = /* @__PURE__ */new PrimitivePool(function () {\n  return new ExtendedTriangle();\n});\nexport var MeshBVH = /*#__PURE__*/function () {\n  _createClass(MeshBVH, null, [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (options.isBufferGeometry) {\n        console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.serialize(arguments[0], {\n          cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result;\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice()\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array\n        };\n      }\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (typeof options === 'boolean') {\n        console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.deserialize(arguments[0], arguments[1], {\n          setIndex: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n      options = _objectSpread({\n        setIndex: true\n      }, options);\n      var index = data.index,\n        roots = data.roots;\n      var bvh = new MeshBVH(geometry, _objectSpread({}, options, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n      return bvh;\n    }\n  }]);\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, MeshBVH);\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null\n    }, SKIP_GENERATION, false), options);\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n    this._roots = null;\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n  }\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n      }\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i];\n            var x = posAttr.getX(index);\n            var y = posAttr.getY(index);\n            var z = posAttr.getZ(index);\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6];\n\n          // the identifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var forceChildren = force;\n          var includesLeft = false;\n          var includesRight = false;\n          if (nodeIndices) {\n            // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            if (!forceChildren) {\n              includesLeft = nodeIndices.has(offsetLeft);\n              includesRight = nodeIndices.has(offsetRight);\n              forceChildren = !includesLeft && !includesRight;\n            }\n          } else {\n            includesLeft = true;\n            includesRight = true;\n          }\n          var traverseLeft = forceChildren || includesLeft;\n          var traverseRight = forceChildren || includesRight;\n          var leftChange = false;\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceChildren);\n          }\n          var rightChange = false;\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceChildren);\n          }\n          var didChange = leftChange || rightChange;\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n      _traverse(0);\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    } /* Core Cast Functions */\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        setBuffer(roots[i]);\n        _raycast(0, geometry, materialSide, ray, intersects);\n        clearBuffer();\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        setBuffer(roots[i]);\n        var result = _raycastFirst(0, geometry, materialSide, ray);\n        clearBuffer();\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n      var _iterator = _createForOfIteratorHelper(this._roots),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n      var triangle = trianglePool.getPrimitive();\n      var _callbacks = callbacks,\n        boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n        intersectsBounds = _callbacks.intersectsBounds,\n        intersectsRange = _callbacks.intersectsRange,\n        intersectsTriangle = _callbacks.intersectsTriangle;\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n      var result = false;\n      var byteOffset = 0;\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n          if (result) {\n            break;\n          }\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      trianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n      // than an approach that walks down the tree (see bvhcast.js file for more info).\n      var intersectsRanges = callbacks.intersectsRanges,\n        intersectsTriangles = callbacks.intersectsTriangles;\n      var indexAttr = this.geometry.index;\n      var positionAttr = this.geometry.attributes.position;\n      var otherIndexAttr = otherBvh.geometry.index;\n      var otherPositionAttr = otherBvh.geometry.attributes.position;\n      tempMatrix.copy(matrixToLocal).invert();\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n              triangle.needsUpdate = true;\n              if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n          return false;\n        };\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n      otherBvh.getBoundingBox(aabb2);\n      aabb2.applyMatrix4(matrixToLocal);\n      var result = this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return aabb2.intersectsBox(box);\n        },\n        intersectsRange: function intersectsRange(offset1, count1, contained, depth1, nodeIndex1, box) {\n          aabb.copy(box);\n          aabb.applyMatrix4(tempMatrix);\n          return otherBvh.shapecast({\n            intersectsBounds: function intersectsBounds(box) {\n              return aabb.intersectsBox(box);\n            },\n            intersectsRange: function intersectsRange(offset2, count2, contained, depth2, nodeIndex2) {\n              return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n            }\n          });\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      return result;\n    } /* Derived Cast Functions */\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      var tempTarget1 = temp1;\n      var tempTargetDest1 = temp2;\n      var tempTarget2 = null;\n      var tempTargetDest2 = null;\n      if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n      }\n      var closestDistance = Infinity;\n      var closestDistanceTriIndex = null;\n      var closestDistanceOtherTriIndex = null;\n      tempMatrix.copy(geometryToBvh).invert();\n      obb2.matrix.copy(tempMatrix);\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n            return true;\n          }\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast({\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box);\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                    if (dist < closestDistance) {\n                      tempTargetDest1.copy(tempTarget1);\n                      if (tempTargetDest2) {\n                        tempTargetDest2.copy(tempTarget2);\n                      }\n                      closestDistance = dist;\n                      closestDistanceTriIndex = i / 3;\n                      closestDistanceOtherTriIndex = i2 / 3;\n                    }\n\n                    // stop traversal if we find a point that's under the given threshold\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i / 3;\n                  closestDistanceOtherTriIndex = i2 / 3;\n                }\n\n                // stop traversal if we find a point that's under the given threshold\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      if (closestDistance === Infinity) return null;\n      if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n      target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n      if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n      }\n      return target1;\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      var closestDistanceTriIndex = null;\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri, triIndex) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n          if (distSq < closestDistanceSq) {\n            temp1.copy(temp);\n            closestDistanceSq = distSq;\n            closestDistanceTriIndex = triIndex;\n          }\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      if (closestDistanceSq === Infinity) return null;\n      var closestDistance = Math.sqrt(closestDistanceSq);\n      if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n      target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n      return target;\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }]);\n  return MeshBVH;\n}();","map":null,"metadata":{},"sourceType":"module"}