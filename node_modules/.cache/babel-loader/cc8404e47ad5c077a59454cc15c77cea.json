{"ast":null,"code":"import _slicedToArray from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { Vector3, Plane, Line3, Sphere, Box3, Triangle } from 'three';\nimport { Capsule } from './Capsule.js';\nvar Octree = function () {\n  var _v1 = new Vector3();\n  var _v2 = new Vector3();\n  var _plane = new Plane();\n  var _line1 = new Line3();\n  var _line2 = new Line3();\n  var _sphere = new Sphere();\n  var _capsule = new Capsule();\n  function Octree(box) {\n    this.triangles = [];\n    this.box = box;\n    this.subTrees = [];\n  }\n  Object.assign(Octree.prototype, {\n    addTriangle: function addTriangle(triangle) {\n      if (!this.bounds) this.bounds = new Box3();\n      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n      this.triangles.push(triangle);\n      return this;\n    },\n    calcBox: function calcBox() {\n      this.box = this.bounds.clone(); // offset small ammount to account for regular grid\n\n      this.box.min.x -= 0.01;\n      this.box.min.y -= 0.01;\n      this.box.min.z -= 0.01;\n      return this;\n    },\n    split: function split(level) {\n      if (!this.box) return;\n      var subTrees = [],\n        halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5),\n        box,\n        v,\n        triangle;\n      for (var x = 0; x < 2; x++) {\n        for (var y = 0; y < 2; y++) {\n          for (var z = 0; z < 2; z++) {\n            box = new Box3();\n            v = _v1.set(x, y, z);\n            box.min.copy(this.box.min).add(v.multiply(halfsize));\n            box.max.copy(box.min).add(halfsize);\n            subTrees.push(new Octree(box));\n          }\n        }\n      }\n      while (triangle = this.triangles.pop()) {\n        for (var i = 0; i < subTrees.length; i++) {\n          if (subTrees[i].box.intersectsTriangle(triangle)) {\n            subTrees[i].triangles.push(triangle);\n          }\n        }\n      }\n      for (var _i = 0; _i < subTrees.length; _i++) {\n        var len = subTrees[_i].triangles.length;\n        if (len > 8 && level < 16) {\n          subTrees[_i].split(level + 1);\n        }\n        if (len != 0) {\n          this.subTrees.push(subTrees[_i]);\n        }\n      }\n      return this;\n    },\n    build: function build() {\n      this.calcBox();\n      this.split(0);\n      return this;\n    },\n    getRayTriangles: function getRayTriangles(ray, triangles) {\n      for (var i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!ray.intersectsBox(subTree.box)) continue;\n        if (subTree.triangles.length > 0) {\n          for (var j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getRayTriangles(ray, triangles);\n        }\n      }\n      return triangles;\n    },\n    triangleCapsuleIntersect: function triangleCapsuleIntersect(capsule, triangle) {\n      var point1, point2, line1, line2;\n      triangle.getPlane(_plane);\n      var d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n      var d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n        return false;\n      }\n      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n      var intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n      if (triangle.containsPoint(intersectPoint)) {\n        return {\n          normal: _plane.normal.clone(),\n          point: intersectPoint.clone(),\n          depth: Math.abs(Math.min(d1, d2))\n        };\n      }\n      var r2 = capsule.radius * capsule.radius;\n      line1 = _line1.set(capsule.start, capsule.end);\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n      for (var i = 0; i < lines.length; i++) {\n        line2 = _line2.set(lines[i][0], lines[i][1]);\n        var _capsule$lineLineMini = capsule.lineLineMinimumPoints(line1, line2);\n        var _capsule$lineLineMini2 = _slicedToArray(_capsule$lineLineMini, 2);\n        point1 = _capsule$lineLineMini2[0];\n        point2 = _capsule$lineLineMini2[1];\n        if (point1.distanceToSquared(point2) < r2) {\n          return {\n            normal: point1.clone().sub(point2).normalize(),\n            point: point2.clone(),\n            depth: capsule.radius - point1.distanceTo(point2)\n          };\n        }\n      }\n      return false;\n    },\n    triangleSphereIntersect: function triangleSphereIntersect(sphere, triangle) {\n      triangle.getPlane(_plane);\n      if (!sphere.intersectsPlane(_plane)) return false;\n      var depth = Math.abs(_plane.distanceToSphere(sphere));\n      var r2 = sphere.radius * sphere.radius - depth * depth;\n      var plainPoint = _plane.projectPoint(sphere.center, _v1);\n      if (triangle.containsPoint(sphere.center)) {\n        return {\n          normal: _plane.normal.clone(),\n          point: plainPoint.clone(),\n          depth: Math.abs(_plane.distanceToSphere(sphere))\n        };\n      }\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n      for (var i = 0; i < lines.length; i++) {\n        _line1.set(lines[i][0], lines[i][1]);\n        _line1.closestPointToPoint(plainPoint, true, _v2);\n        var d = _v2.distanceToSquared(sphere.center);\n        if (d < r2) {\n          return {\n            normal: sphere.center.clone().sub(_v2).normalize(),\n            point: _v2.clone(),\n            depth: sphere.radius - Math.sqrt(d)\n          };\n        }\n      }\n      return false;\n    },\n    getSphereTriangles: function getSphereTriangles(sphere, triangles) {\n      for (var i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!sphere.intersectsBox(subTree.box)) continue;\n        if (subTree.triangles.length > 0) {\n          for (var j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getSphereTriangles(sphere, triangles);\n        }\n      }\n    },\n    getCapsuleTriangles: function getCapsuleTriangles(capsule, triangles) {\n      for (var i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!capsule.intersectsBox(subTree.box)) continue;\n        if (subTree.triangles.length > 0) {\n          for (var j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getCapsuleTriangles(capsule, triangles);\n        }\n      }\n    },\n    sphereIntersect: function sphereIntersect(sphere) {\n      _sphere.copy(sphere);\n      var triangles = [],\n        result,\n        hit = false;\n      this.getSphereTriangles(sphere, triangles);\n      for (var i = 0; i < triangles.length; i++) {\n        if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n          hit = true;\n          _sphere.center.add(result.normal.multiplyScalar(result.depth));\n        }\n      }\n      if (hit) {\n        var collisionVector = _sphere.center.clone().sub(sphere.center);\n        var depth = collisionVector.length();\n        return {\n          normal: collisionVector.normalize(),\n          depth: depth\n        };\n      }\n      return false;\n    },\n    capsuleIntersect: function capsuleIntersect(capsule) {\n      _capsule.copy(capsule);\n      var triangles = [],\n        result,\n        hit = false;\n      this.getCapsuleTriangles(_capsule, triangles);\n      for (var i = 0; i < triangles.length; i++) {\n        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n          hit = true;\n          _capsule.translate(result.normal.multiplyScalar(result.depth));\n        }\n      }\n      if (hit) {\n        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n        var depth = collisionVector.length();\n        return {\n          normal: collisionVector.normalize(),\n          depth: depth\n        };\n      }\n      return false;\n    },\n    rayIntersect: function rayIntersect(ray) {\n      if (ray.direction.length() === 0) return;\n      var triangles = [],\n        triangle,\n        position,\n        distance = 1e100,\n        result;\n      this.getRayTriangles(ray, triangles);\n      for (var i = 0; i < triangles.length; i++) {\n        result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n        if (result) {\n          var newdistance = result.sub(ray.origin).length();\n          if (distance > newdistance) {\n            position = result.clone().add(ray.origin);\n            distance = newdistance;\n            triangle = triangles[i];\n          }\n        }\n      }\n      return distance < 1e100 ? {\n        distance: distance,\n        triangle: triangle,\n        position: position\n      } : false;\n    },\n    fromGraphNode: function fromGraphNode(group) {\n      var _this = this;\n      group.traverse(function (obj) {\n        if (obj.type === 'Mesh') {\n          obj.updateMatrix();\n          obj.updateWorldMatrix();\n          var geometry,\n            isTemp = false;\n          if (obj.geometry.index) {\n            isTemp = true;\n            geometry = obj.geometry.clone().toNonIndexed();\n          } else {\n            geometry = obj.geometry;\n          }\n          var positions = geometry.attributes.position.array;\n          var transform = obj.matrixWorld;\n          for (var i = 0; i < positions.length; i += 9) {\n            var v1 = new Vector3(positions[i], positions[i + 1], positions[i + 2]);\n            var v2 = new Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);\n            var v3 = new Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);\n            v1.applyMatrix4(transform);\n            v2.applyMatrix4(transform);\n            v3.applyMatrix4(transform);\n            _this.addTriangle(new Triangle(v1, v2, v3));\n          }\n          if (isTemp) {\n            geometry.dispose();\n          }\n        }\n      });\n      this.build();\n      return this;\n    }\n  });\n  return Octree;\n}();\nexport { Octree };","map":null,"metadata":{},"sourceType":"module"}