{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { PerspectiveCamera, ShaderMaterial, Scene, OrthographicCamera, WebGLRenderTarget, UniformsUtils, Mesh, PlaneGeometry } from 'three';\nimport { BokehDepthShader, BokehShader2 } from '../shaders/BokehShader2.js';\nvar CinematicCamera = /*#__PURE__*/function (_PerspectiveCamera) {\n  _inherits(CinematicCamera, _PerspectiveCamera);\n  function CinematicCamera(fov, aspect, near, far) {\n    var _this;\n    _classCallCheck(this, CinematicCamera);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CinematicCamera).call(this, fov, aspect, near, far));\n    _this.type = 'CinematicCamera';\n    _this.postprocessing = {\n      enabled: true\n    };\n    _this.shaderSettings = {\n      rings: 3,\n      samples: 4\n    };\n    var depthShader = BokehDepthShader;\n    _this.materialDepth = new ShaderMaterial({\n      uniforms: depthShader.uniforms,\n      vertexShader: depthShader.vertexShader,\n      fragmentShader: depthShader.fragmentShader\n    });\n    _this.materialDepth.uniforms['mNear'].value = near;\n    _this.materialDepth.uniforms['mFar'].value = far; // In case of cinematicCamera, having a default lens set is important\n\n    _this.setLens();\n    _this.initPostProcessing();\n    return _this;\n  } // providing fnumber and coc(Circle of Confusion) as extra arguments\n  _createClass(CinematicCamera, [{\n    key: \"setLens\",\n    value: function setLens(focalLength, filmGauge, fNumber, coc) {\n      // In case of cinematicCamera, having a default lens set is important\n      if (focalLength === undefined) focalLength = 35;\n      if (filmGauge !== undefined) this.filmGauge = filmGauge;\n      this.setFocalLength(focalLength); // if fnumber and coc are not provided, cinematicCamera tries to act as a basic PerspectiveCamera\n\n      if (fNumber === undefined) fNumber = 8;\n      if (coc === undefined) coc = 0.019;\n      this.fNumber = fNumber;\n      this.coc = coc; // fNumber is focalLength by aperture\n\n      this.aperture = focalLength / this.fNumber; // hyperFocal is required to calculate depthOfField when a lens tries to focus at a distance with given fNumber and focalLength\n\n      this.hyperFocal = focalLength * focalLength / (this.aperture * this.coc);\n    }\n  }, {\n    key: \"linearize\",\n    value: function linearize(depth) {\n      var zfar = this.far;\n      var znear = this.near;\n      return -zfar * znear / (depth * (zfar - znear) - zfar);\n    }\n  }, {\n    key: \"smoothstep\",\n    value: function smoothstep(near, far, depth) {\n      var x = this.saturate((depth - near) / (far - near));\n      return x * x * (3 - 2 * x);\n    }\n  }, {\n    key: \"saturate\",\n    value: function saturate(x) {\n      return Math.max(0, Math.min(1, x));\n    } // function for focusing at a distance from the camera\n  }, {\n    key: \"focusAt\",\n    value: function focusAt(focusDistance) {\n      if (focusDistance === undefined) focusDistance = 20;\n      var focalLength = this.getFocalLength(); // distance from the camera (normal to frustrum) to focus on\n\n      this.focus = focusDistance; // the nearest point from the camera which is in focus (unused)\n\n      this.nearPoint = this.hyperFocal * this.focus / (this.hyperFocal + (this.focus - focalLength)); // the farthest point from the camera which is in focus (unused)\n\n      this.farPoint = this.hyperFocal * this.focus / (this.hyperFocal - (this.focus - focalLength)); // the gap or width of the space in which is everything is in focus (unused)\n\n      this.depthOfField = this.farPoint - this.nearPoint; // Considering minimum distance of focus for a standard lens (unused)\n\n      if (this.depthOfField < 0) this.depthOfField = 0;\n      this.sdistance = this.smoothstep(this.near, this.far, this.focus);\n      this.ldistance = this.linearize(1 - this.sdistance);\n      this.postprocessing.bokeh_uniforms['focalDepth'].value = this.ldistance;\n    }\n  }, {\n    key: \"initPostProcessing\",\n    value: function initPostProcessing() {\n      if (this.postprocessing.enabled) {\n        this.postprocessing.scene = new Scene();\n        this.postprocessing.camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -10000, 10000);\n        this.postprocessing.scene.add(this.postprocessing.camera);\n        this.postprocessing.rtTextureDepth = new WebGLRenderTarget(window.innerWidth, window.innerHeight);\n        this.postprocessing.rtTextureColor = new WebGLRenderTarget(window.innerWidth, window.innerHeight);\n        var bokeh_shader = BokehShader2;\n        this.postprocessing.bokeh_uniforms = UniformsUtils.clone(bokeh_shader.uniforms);\n        this.postprocessing.bokeh_uniforms['tColor'].value = this.postprocessing.rtTextureColor.texture;\n        this.postprocessing.bokeh_uniforms['tDepth'].value = this.postprocessing.rtTextureDepth.texture;\n        this.postprocessing.bokeh_uniforms['manualdof'].value = 0;\n        this.postprocessing.bokeh_uniforms['shaderFocus'].value = 0;\n        this.postprocessing.bokeh_uniforms['fstop'].value = 2.8;\n        this.postprocessing.bokeh_uniforms['showFocus'].value = 1;\n        this.postprocessing.bokeh_uniforms['focalDepth'].value = 0.1; //console.log( this.postprocessing.bokeh_uniforms[ \"focalDepth\" ].value );\n\n        this.postprocessing.bokeh_uniforms['znear'].value = this.near;\n        this.postprocessing.bokeh_uniforms['zfar'].value = this.near;\n        this.postprocessing.bokeh_uniforms['textureWidth'].value = window.innerWidth;\n        this.postprocessing.bokeh_uniforms['textureHeight'].value = window.innerHeight;\n        this.postprocessing.materialBokeh = new ShaderMaterial({\n          uniforms: this.postprocessing.bokeh_uniforms,\n          vertexShader: bokeh_shader.vertexShader,\n          fragmentShader: bokeh_shader.fragmentShader,\n          defines: {\n            RINGS: this.shaderSettings.rings,\n            SAMPLES: this.shaderSettings.samples,\n            DEPTH_PACKING: 1\n          }\n        });\n        this.postprocessing.quad = new Mesh(new PlaneGeometry(window.innerWidth, window.innerHeight), this.postprocessing.materialBokeh);\n        this.postprocessing.quad.position.z = -500;\n        this.postprocessing.scene.add(this.postprocessing.quad);\n      }\n    }\n  }, {\n    key: \"renderCinematic\",\n    value: function renderCinematic(scene, renderer) {\n      if (this.postprocessing.enabled) {\n        var currentRenderTarget = renderer.getRenderTarget();\n        renderer.clear(); // Render scene into texture\n\n        scene.overrideMaterial = null;\n        renderer.setRenderTarget(this.postprocessing.rtTextureColor);\n        renderer.clear();\n        renderer.render(scene, this); // Render depth into texture\n\n        scene.overrideMaterial = this.materialDepth;\n        renderer.setRenderTarget(this.postprocessing.rtTextureDepth);\n        renderer.clear();\n        renderer.render(scene, this); // Render bokeh composite\n\n        renderer.setRenderTarget(null);\n        renderer.render(this.postprocessing.scene, this.postprocessing.camera);\n        renderer.setRenderTarget(currentRenderTarget);\n      }\n    }\n  }]);\n  return CinematicCamera;\n}(PerspectiveCamera);\nexport { CinematicCamera };","map":null,"metadata":{},"sourceType":"module"}