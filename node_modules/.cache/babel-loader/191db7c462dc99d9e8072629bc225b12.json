{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from 'three';\nvar OBJExporter = /*#__PURE__*/function () {\n  function OBJExporter() {\n    _classCallCheck(this, OBJExporter);\n    _defineProperty(this, \"output\", void 0);\n    _defineProperty(this, \"indexVertex\", void 0);\n    _defineProperty(this, \"indexVertexUvs\", void 0);\n    _defineProperty(this, \"indexNormals\", void 0);\n    _defineProperty(this, \"vertex\", void 0);\n    _defineProperty(this, \"color\", void 0);\n    _defineProperty(this, \"normal\", void 0);\n    _defineProperty(this, \"uv\", void 0);\n    _defineProperty(this, \"face\", void 0);\n    this.output = '';\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n  _createClass(OBJExporter, [{\n    key: \"parse\",\n    value: function parse(object) {\n      var _this = this;\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          _this.parseMesh(child);\n        }\n        if (child instanceof Line && child.isLine) {\n          _this.parseLine(child);\n        }\n        if (child instanceof Points && child.isPoints) {\n          _this.parsePoints(child);\n        }\n      });\n      return this.output;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(mesh) {\n      var nbVertex = 0;\n      var nbNormals = 0;\n      var nbVertexUvs = 0;\n      var geometry = mesh.geometry;\n      var normalMatrixWorld = new Matrix3();\n      if (!geometry.isBufferGeometry) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n      var vertices = geometry.getAttribute('position');\n      var normals = geometry.getAttribute('normal');\n      var uvs = geometry.getAttribute('uv');\n      var indices = geometry.getIndex(); // name of the mesh object\n\n      this.output += \"o \".concat(mesh.name, \"\\n\"); // name of the mesh material\n\n      if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n        this.output += \"usemtl \".concat(mesh.material.name, \"\\n\");\n      } // vertices\n\n      if (vertices !== undefined) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.x = vertices.getX(i);\n          this.vertex.y = vertices.getY(i);\n          this.vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          this.vertex.applyMatrix4(mesh.matrixWorld); // transform the vertex to export format\n\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n        }\n      } // uvs\n\n      if (uvs !== undefined) {\n        for (var _i = 0, _l = uvs.count; _i < _l; _i++, nbVertexUvs++) {\n          this.uv.x = uvs.getX(_i);\n          this.uv.y = uvs.getY(_i); // transform the uv to export format\n\n          this.output += \"vt \".concat(this.uv.x, \" \").concat(this.uv.y, \"\\n\");\n        }\n      } // normals\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (var _i2 = 0, _l2 = normals.count; _i2 < _l2; _i2++, nbNormals++) {\n          this.normal.x = normals.getX(_i2);\n          this.normal.y = normals.getY(_i2);\n          this.normal.z = normals.getZ(_i2); // transform the normal to world space\n\n          this.normal.applyMatrix3(normalMatrixWorld).normalize(); // transform the normal to export format\n\n          this.output += \"vn \".concat(this.normal.x, \" \").concat(this.normal.y, \" \").concat(this.normal.z, \"\\n\");\n        }\n      } // faces\n\n      if (indices !== null) {\n        for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n          for (var m = 0; m < 3; m++) {\n            var j = indices.getX(_i3 + m) + 1;\n            this.face[m] = this.indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + j : '').concat(normals ? \"/\".concat(this.indexNormals + j) : '') : '');\n          } // transform the face to export format\n\n          this.output += \"f \".concat(this.face.join(' '), \"\\n\");\n        }\n      } else {\n        for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n          for (var _m = 0; _m < 3; _m++) {\n            var _j = _i4 + _m + 1;\n            this.face[_m] = this.indexVertex + _j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + _j : '').concat(normals ? \"/\".concat(this.indexNormals + _j) : '') : '');\n          } // transform the face to export format\n\n          this.output += \"f \".concat(this.face.join(' '), \"\\n\");\n        }\n      } // update index\n\n      this.indexVertex += nbVertex;\n      this.indexVertexUvs += nbVertexUvs;\n      this.indexNormals += nbNormals;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(line) {\n      var nbVertex = 0;\n      var geometry = line.geometry;\n      var type = line.type;\n      if (geometry.isBufferGeometry) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      } // shortcuts\n\n      var vertices = geometry.getAttribute('position'); // name of the line object\n\n      this.output += \"o \".concat(line.name, \"\\n\");\n      if (vertices !== undefined) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.x = vertices.getX(i);\n          this.vertex.y = vertices.getY(i);\n          this.vertex.z = vertices.getZ(i); // transform the vertex to world space\n\n          this.vertex.applyMatrix4(line.matrixWorld); // transform the vertex to export format\n\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n        }\n      }\n      if (type === 'Line') {\n        this.output += 'l ';\n        for (var j = 1, _l5 = vertices.count; j <= _l5; j++) {\n          this.output += \"\".concat(this.indexVertex + j, \" \");\n        }\n        this.output += '\\n';\n      }\n      if (type === 'LineSegments') {\n        for (var _j2 = 1, k = _j2 + 1, _l6 = vertices.count; _j2 < _l6; _j2 += 2, k = _j2 + 1) {\n          this.output += \"l \".concat(this.indexVertex + _j2, \" \").concat(this.indexVertex + k, \"\\n\");\n        }\n      } // update index\n\n      this.indexVertex += nbVertex;\n    }\n  }, {\n    key: \"parsePoints\",\n    value: function parsePoints(points) {\n      var nbVertex = 0;\n      var geometry = points.geometry;\n      if (!geometry.isBufferGeometry) {\n        throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n      var vertices = geometry.getAttribute('position');\n      var colors = geometry.getAttribute('color');\n      this.output += \"o \".concat(points.name, \"\\n\");\n      if (vertices !== undefined) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.fromBufferAttribute(vertices, i);\n          this.vertex.applyMatrix4(points.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z);\n          if (colors !== undefined && colors instanceof BufferAttribute) {\n            this.color.fromBufferAttribute(colors, i);\n            this.output += \" \".concat(this.color.r, \" \").concat(this.color.g, \" \").concat(this.color.b);\n          }\n          this.output += '\\n';\n        }\n      }\n      this.output += 'p ';\n      for (var j = 1, _l7 = vertices.count; j <= _l7; j++) {\n        this.output += \"\".concat(this.indexVertex + j, \" \");\n      }\n      this.output += '\\n'; // update index\n\n      this.indexVertex += nbVertex;\n    }\n  }]);\n  return OBJExporter;\n}();\nexport { OBJExporter };","map":null,"metadata":{},"sourceType":"module"}