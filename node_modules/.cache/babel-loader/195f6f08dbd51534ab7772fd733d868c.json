{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Object3D, Matrix4, Vector3, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, Quaternion, BufferGeometry, BufferAttribute } from 'three';\nvar CCDIKHelper = /*#__PURE__*/function (_Object3D) {\n  _inherits(CCDIKHelper, _Object3D);\n  function CCDIKHelper(mesh) {\n    var _this;\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, CCDIKHelper);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CCDIKHelper).call(this));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_m\", new Matrix4());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_v\", new Vector3());\n    _this.root = mesh;\n    _this.iks = iks;\n    _this.matrix.copy(mesh.matrixWorld);\n    _this.matrixAutoUpdate = false;\n    _this.sphereGeometry = new SphereGeometry(0.25, 16, 8);\n    _this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    function createLineGeometry(ik) {\n      var geometry = new BufferGeometry();\n      var vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n    for (var i = 0, il = iks.length; i < il; i++) {\n      var ik = iks[i];\n      _this.add(createTargetMesh());\n      _this.add(createEffectorMesh());\n      for (var j = 0, jl = ik.links.length; j < jl; j++) {\n        _this.add(createLinkMesh());\n      }\n      _this.add(createLine(ik));\n    }\n    return _this;\n  }\n  _createClass(CCDIKHelper, [{\n    key: \"_getPosition\",\n    value: function _getPosition(bone, matrixWorldInv) {\n      return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n    }\n  }, {\n    key: \"_setPositionOfBoneToAttributeArray\",\n    value: function _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n      var v = this._getPosition(bone, matrixWorldInv);\n      array[index * 3 + 0] = v.x;\n      array[index * 3 + 1] = v.y;\n      array[index * 3 + 2] = v.z;\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      var mesh = this.root;\n      if (this.visible) {\n        var offset = 0;\n        var iks = this.iks;\n        var bones = mesh.skeleton.bones;\n        this._m.copy(mesh.matrixWorld).invert();\n        for (var i = 0, il = iks.length; i < il; i++) {\n          var ik = iks[i];\n          var targetBone = bones[ik.target];\n          var effectorBone = bones[ik.effector];\n          var targetMesh = this.children[offset++];\n          var effectorMesh = this.children[offset++];\n          targetMesh.position.copy(this._getPosition(targetBone, this._m));\n          effectorMesh.position.copy(this._getPosition(effectorBone, this._m));\n          for (var j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = ik.links[j];\n            var linkBone = bones[link.index];\n            var linkMesh = this.children[offset++];\n            linkMesh.position.copy(this._getPosition(linkBone, this._m));\n          }\n          var line = this.children[offset++];\n          var array = line.geometry.attributes.position.array;\n          this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);\n          this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);\n          for (var _j = 0, _jl = ik.links.length; _j < _jl; _j++) {\n            var _link = ik.links[_j];\n            var _linkBone = bones[_link.index];\n            this._setPositionOfBoneToAttributeArray(array, _j + 2, _linkBone, this._m);\n          }\n          line.geometry.attributes.position.needsUpdate = true;\n        }\n      }\n      this.matrix.copy(mesh.matrixWorld);\n      _get(_getPrototypeOf(CCDIKHelper.prototype), \"updateMatrixWorld\", this).call(this, force);\n    }\n  }]);\n  return CCDIKHelper;\n}(Object3D);\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\nvar CCDIKSolver = /*#__PURE__*/function () {\n  function CCDIKSolver(mesh, iks) {\n    _classCallCheck(this, CCDIKSolver);\n    _defineProperty(this, \"q\", new Quaternion());\n    _defineProperty(this, \"targetPos\", new Vector3());\n    _defineProperty(this, \"targetVec\", new Vector3());\n    _defineProperty(this, \"effectorPos\", new Vector3());\n    _defineProperty(this, \"effectorVec\", new Vector3());\n    _defineProperty(this, \"linkPos\", new Vector3());\n    _defineProperty(this, \"invLinkQ\", new Quaternion());\n    _defineProperty(this, \"linkScale\", new Vector3());\n    _defineProperty(this, \"axis\", new Vector3());\n    _defineProperty(this, \"vector\", new Vector3());\n    this.mesh = mesh;\n    this.iks = iks;\n    var bones = this.mesh.skeleton.bones;\n    for (var i = 0, il = this.iks.length; i < il; i++) {\n      var ik = this.iks[i];\n      var effector = bones[ik.effector];\n      var links = ik.links;\n      var link0 = void 0,\n        link1 = void 0;\n      link0 = effector;\n      for (var j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n        if (link0.parent !== link1) {\n          console.warn(\"THREE.CCDIKSolver: bone \".concat(link0.name, \" is not the child of bone \").concat(link1.name));\n        }\n        link0 = link1;\n      }\n    }\n  }\n  _createClass(CCDIKSolver, [{\n    key: \"update\",\n    value: function update() {\n      var bones = this.mesh.skeleton.bones;\n      var iks = this.iks; // for reference overhead reduction in loop\n\n      var math = Math;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var effector = bones[ik.effector];\n        var target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n        // because it calls updateMatrixWorld( true ) inside.\n\n        this.targetPos.setFromMatrixPosition(target.matrixWorld);\n        var links = ik.links;\n        var iteration = ik.iteration !== undefined ? ik.iteration : 1;\n        for (var j = 0; j < iteration; j++) {\n          var rotated = false;\n          for (var k = 0, kl = links.length; k < kl; k++) {\n            var link = bones[links[k].index]; // skip this link and following links.\n            // this skip is used for MMD performance optimization.\n\n            if (links[k].enabled === false) break;\n            var limitation = links[k].limitation;\n            var rotationMin = links[k].rotationMin;\n            var rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n            // because they call updateMatrixWorld( true ) inside.\n\n            link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);\n            this.invLinkQ.invert();\n            this.effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n            this.effectorVec.subVectors(this.effectorPos, this.linkPos);\n            this.effectorVec.applyQuaternion(this.invLinkQ);\n            this.effectorVec.normalize();\n            this.targetVec.subVectors(this.targetPos, this.linkPos);\n            this.targetVec.applyQuaternion(this.invLinkQ);\n            this.targetVec.normalize();\n            var angle = this.targetVec.dot(this.effectorVec);\n            if (angle > 1.0) {\n              angle = 1.0;\n            } else if (angle < -1.0) {\n              angle = -1.0;\n            }\n            angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n            // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n            if (angle < 1e-5) continue;\n            if (ik.minAngle !== undefined && angle < ik.minAngle) {\n              angle = ik.minAngle;\n            }\n            if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n              angle = ik.maxAngle;\n            }\n            this.axis.crossVectors(this.effectorVec, this.targetVec);\n            this.axis.normalize();\n            this.q.setFromAxisAngle(this.axis, angle);\n            link.quaternion.multiply(this.q); // TODO: re-consider the limitation specification\n\n            if (limitation !== undefined) {\n              var c = link.quaternion.w;\n              if (c > 1.0) c = 1.0;\n              var c2 = math.sqrt(1 - c * c);\n              link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n            }\n            if (rotationMin !== undefined) {\n              link.rotation.setFromVector3(link.rotation.toVector3(this.vector).max(rotationMin));\n            }\n            if (rotationMax !== undefined) {\n              link.rotation.setFromVector3(link.rotation.toVector3(this.vector).min(rotationMax));\n            }\n            link.updateMatrixWorld(true);\n            rotated = true;\n          }\n          if (!rotated) break;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"createHelper\",\n    value: function createHelper() {\n      return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n    }\n  }]);\n  return CCDIKSolver;\n}();\nexport { CCDIKHelper, CCDIKSolver };","map":null,"metadata":{},"sourceType":"module"}