{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes);\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  (0, forEach_1.default)(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexports.augmentTokenTypes = augmentTokenTypes;\nfunction expandCategories(tokenTypes) {\n  var result = (0, clone_1.default)(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n  while (searching) {\n    categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = (0, difference_1.default)(categories, result);\n    result = result.concat(newCategories);\n    if ((0, isEmpty_1.default)(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nexports.expandCategories = expandCategories;\nfunction assignTokenDefaultProps(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n    }\n    // CATEGORIES? : TokenType | TokenType[]\n    if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)\n    // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\nfunction assignCategoriesTokensProp(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    (0, forEach_1.default)(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\nfunction assignCategoriesMapProp(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  (0, forEach_1.default)(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  (0, forEach_1.default)(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!(0, includes_1.default)(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\nfunction hasShortKeyProperty(tokType) {\n  return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.hasShortKeyProperty = hasShortKeyProperty;\nfunction hasCategoriesProperty(tokType) {\n  return (0, has_1.default)(tokType, \"CATEGORIES\");\n}\nexports.hasCategoriesProperty = hasCategoriesProperty;\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return (0, has_1.default)(tokType, \"categoryMatches\");\n}\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return (0, has_1.default)(tokType, \"categoryMatchesMap\");\n}\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\nfunction isTokenType(tokType) {\n  return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.isTokenType = isTokenType;","map":null,"metadata":{},"sourceType":"script"}