{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\nvar AssimpLoader = function AssimpLoader(manager) {\n  Loader.call(this, manager);\n};\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new Vector3();\n      this.quaternion = new Quaternion();\n      this.scale = new Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n        for (var j = 0; j < this.length * this.fps; j++) {\n          for (var i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n        for (var i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n        this.init();\n      };\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n        for (var i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n        this.init();\n      };\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n        for (var i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n        t.init();\n        return t;\n      };\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n        for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n        for (var i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n        return null;\n      }\n      return find(root, target.name);\n    };\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n      this.setTime = function (time) {\n        this.time = time;\n        for (var i = 0; i < this.tracks.length; i++) {\n          this.tracks[i].setTime(time);\n        }\n      };\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n        for (var i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n        return n;\n      };\n    };\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n    function markBones(scene) {\n      for (var i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n        for (var k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n      for (var i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n      return rootBone;\n    }\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n      for (var i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n      for (var _i = 0; _i < 4; _i++) {\n        sum += pairs[_i].w * pairs[_i].w;\n      }\n      sum = Math.sqrt(sum);\n      for (var _i2 = 0; _i2 < 4; _i2++) {\n        pairs[_i2].w = pairs[_i2].w / sum;\n        indexes[_i2] = pairs[_i2].i;\n        weights[_i2] = pairs[_i2].w;\n      }\n    }\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n      for (var i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n      return undefined;\n    }\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n        for (var i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n        var skeleton = new Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\n        }\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\n        }\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        }\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        }\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\n        }\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\n        }\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n          for (var i = 0; i < this.mBones.length; i++) {\n            for (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n          for (var _i3 in bones) {\n            sortWeights(bones[_i3], weights[_i3]);\n          }\n          var _weights = [];\n          var _bones = [];\n          for (var _i4 = 0; _i4 < weights.length; _i4++) {\n            for (var _j = 0; _j < 4; _j++) {\n              if (weights[_i4] && bones[_i4]) {\n                _weights.push(weights[_i4][_j]);\n                _bones.push(bones[_i4][_j]);\n              } else {\n                _weights.push(0);\n                _bones.push(0);\n              }\n            }\n          }\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n        var mesh;\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n        if (this.mBones.length > 0) {\n          mesh = new SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.toTHREE = function () {\n        return new Vector3(this.x, this.y, this.z);\n      };\n    }\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n      this.toTHREE = function () {\n        return new Color(this.r, this.g, this.b);\n      };\n    }\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n      this.toTHREE = function () {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n    function aiString() {\n      this.data = [];\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n        for (var i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n        for (var _i5 = 0; _i5 < this.mMeshes.length; _i5++) {\n          o.add(scene.mMeshes[this.mMeshes[_i5]].toTHREE(scene));\n        }\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new Color(r, g, b);\n      };\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n        return textureLoader.load(path);\n      };\n    }\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n      this.toTHREE = function () {\n        var mat = new MeshPhongMaterial();\n        for (var i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n          }\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n      for (var i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n        function t(t) {\n          t.mTime /= tps;\n        }\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n        for (var i = 0; i < length; i += 0.05) {\n          var matrix = new Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (var _i6 = 0; _i6 < o.nodeToBoneMap[this.mNodeName].length; _i6++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][_i6];\n            tracks.push(t2);\n          }\n        }\n        return tracks;\n      };\n    }\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n        for (var i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n          for (var j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n        if (root.mName == name) {\n          return root;\n        }\n        for (var i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n        return null;\n      };\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n        for (var i in this.mMeshes) {\n          this.mMeshes[i].hookupSkeletons(this);\n        }\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n      this.toTHREE = function () {\n        var m = new Matrix4();\n        for (var i = 0; i < 4; ++i) {\n          for (var i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n        return m;\n      };\n    }\n    var littleEndian = true;\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n      for (var i = 0; i < 4; ++i) {\n        for (var i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n      return m;\n    }\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiVertexWeight(stream);\n      }\n    }\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiVectorKey(stream);\n      }\n    }\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiQuatKey(stream);\n      }\n    }\n    function ReadBounds(stream, T\n    /*p*/, n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n        for (var i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n      if (node.mNumChildren) {\n        node.mChildren = [];\n        for (var _i7 = 0; _i7 < node.mNumChildren; ++_i7) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[_i7] = node2;\n        }\n      }\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n      return b;\n    }\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n      mesh.mTexCoordsBuffers = [];\n      for (var _n = 0; _n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++_n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(_n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[_n] = Read_unsigned_int(stream);\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[_n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[_n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[_n] = [];\n          for (var uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n        for (var i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n          for (var a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n        for (var _a = 0; _a < mesh.mNumBones; ++_a) {\n          mesh.mBones[_a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[_a]);\n        }\n      }\n    }\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n        mat.mProperties = [];\n        for (var i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n        for (var a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n        for (var i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n        for (var _i8 = 0; _i8 < scene.mNumMaterials; ++_i8) {\n          scene.mMaterials[_i8] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[_i8]);\n        }\n      } // Read all animations\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n        for (var _i9 = 0; _i9 < scene.mNumAnimations; ++_i9) {\n          scene.mAnimations[_i9] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[_i9]);\n        }\n      } // Read all textures\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n        for (var _i10 = 0; _i10 < scene.mNumTextures; ++_i10) {\n          scene.mTextures[_i10] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[_i10]);\n        }\n      } // Read lights\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n        for (var _i11 = 0; _i11 < scene.mNumLights; ++_i11) {\n          scene.mLights[_i11] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[_i11]);\n        }\n      } // Read cameras\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n        for (var _i12 = 0; _i12 < scene.mNumCameras; ++_i12) {\n          scene.mCameras[_i12] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[_i12]);\n        }\n      }\n    }\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n    function extendStream(stream) {\n      stream.readOffset = 0;\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n        for (var i = 0; i < bytes; i++) {\n          buff[i] = Read_uint8_t(this);\n        }\n      };\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n    var shortened, compressed;\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n      return pScene.toTHREE();\n    }\n    return InternReadFile(buffer);\n  }\n});\nexport { AssimpLoader };","map":null,"metadata":{},"sourceType":"module"}