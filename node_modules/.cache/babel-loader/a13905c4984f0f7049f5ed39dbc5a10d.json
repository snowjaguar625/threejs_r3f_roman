{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { DataTexture, FloatType, UnsignedIntType, RGBAFormat, RGIntegerFormat, NearestFilter } from 'three';\nimport { FloatVertexAttributeTexture, UIntVertexAttributeTexture } from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, RIGHT_NODE, OFFSET, SPLIT_AXIS } from '../core/nodeBufferFunctions.js';\nfunction bvhToTextures(bvh, boundsTexture, contentsTexture) {\n  var roots = bvh._roots;\n  if (roots.length !== 1) {\n    throw new Error('MeshBVHUniformStruct: Multi-root BVHs not supported.');\n  }\n  var root = roots[0];\n  var uint16Array = new Uint16Array(root);\n  var uint32Array = new Uint32Array(root);\n  var float32Array = new Float32Array(root);\n\n  // Both bounds need two elements per node so compute the height so it's twice as long as\n  // the width so we can expand the row by two and still have a square texture\n  var nodeCount = root.byteLength / BYTES_PER_NODE;\n  var boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n  var boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n  var contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n  var contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n  for (var i = 0; i < nodeCount; i++) {\n    var nodeIndex32 = i * BYTES_PER_NODE / 4;\n    var nodeIndex16 = nodeIndex32 * 2;\n    var boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);\n    for (var b = 0; b < 3; b++) {\n      boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n      boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n    }\n    if (IS_LEAF(nodeIndex16, uint16Array)) {\n      var count = COUNT(nodeIndex16, uint16Array);\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var mergedLeafCount = 0xffff0000 | count;\n      contentsArray[i * 2 + 0] = mergedLeafCount;\n      contentsArray[i * 2 + 1] = offset;\n    } else {\n      var rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;\n      var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n      contentsArray[i * 2 + 0] = splitAxis;\n      contentsArray[i * 2 + 1] = rightIndex;\n    }\n  }\n  boundsTexture.image.data = boundsArray;\n  boundsTexture.image.width = boundsDimension;\n  boundsTexture.image.height = boundsDimension;\n  boundsTexture.format = RGBAFormat;\n  boundsTexture.type = FloatType;\n  boundsTexture.internalFormat = 'RGBA32F';\n  boundsTexture.minFilter = NearestFilter;\n  boundsTexture.magFilter = NearestFilter;\n  boundsTexture.generateMipmaps = false;\n  boundsTexture.needsUpdate = true;\n  boundsTexture.dispose();\n  contentsTexture.image.data = contentsArray;\n  contentsTexture.image.width = contentsDimension;\n  contentsTexture.image.height = contentsDimension;\n  contentsTexture.format = RGIntegerFormat;\n  contentsTexture.type = UnsignedIntType;\n  contentsTexture.internalFormat = 'RG32UI';\n  contentsTexture.minFilter = NearestFilter;\n  contentsTexture.magFilter = NearestFilter;\n  contentsTexture.generateMipmaps = false;\n  contentsTexture.needsUpdate = true;\n  contentsTexture.dispose();\n}\nexport var MeshBVHUniformStruct = /*#__PURE__*/function () {\n  function MeshBVHUniformStruct() {\n    _classCallCheck(this, MeshBVHUniformStruct);\n    this.autoDispose = true;\n    this.index = new UIntVertexAttributeTexture();\n    this.position = new FloatVertexAttributeTexture();\n    this.bvhBounds = new DataTexture();\n    this.bvhContents = new DataTexture();\n    this.index.overrideItemSize = 3;\n  }\n  _createClass(MeshBVHUniformStruct, [{\n    key: \"updateFrom\",\n    value: function updateFrom(bvh) {\n      var geometry = bvh.geometry;\n      bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n      this.index.updateFrom(geometry.index);\n      this.position.updateFrom(geometry.attributes.position);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var index = this.index,\n        position = this.position,\n        bvhBounds = this.bvhBounds,\n        bvhContents = this.bvhContents;\n      if (index) index.dispose();\n      if (position) position.dispose();\n      if (bvhBounds) bvhBounds.dispose();\n      if (bvhContents) bvhContents.dispose();\n    }\n  }]);\n  return MeshBVHUniformStruct;\n}();","map":null,"metadata":{},"sourceType":"module"}