{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Box3, Vector3, InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Sphere } from 'three';\nvar _box = new Box3();\nvar _vector = new Vector3();\nvar LineSegmentsGeometry = /*#__PURE__*/function (_InstancedBufferGeome) {\n  _inherits(LineSegmentsGeometry, _InstancedBufferGeome);\n  function LineSegmentsGeometry() {\n    var _this;\n    _classCallCheck(this, LineSegmentsGeometry);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineSegmentsGeometry).call(this));\n    _this.isLineSegmentsGeometry = true;\n    _this.type = 'LineSegmentsGeometry';\n    var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    _this.setIndex(index);\n    _this.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    return _this;\n  }\n  _createClass(LineSegmentsGeometry, [{\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n      if (start !== undefined) {\n        start.applyMatrix4(matrix);\n        end.applyMatrix4(matrix);\n        start.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n  }, {\n    key: \"setPositions\",\n    value: function setPositions(array) {\n      var lineSegments;\n      if (array instanceof Float32Array) {\n        lineSegments = array;\n      } else if (Array.isArray(array)) {\n        lineSegments = new Float32Array(array);\n      }\n      var instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n      this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n      this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n      //\n\n      this.computeBoundingBox();\n      this.computeBoundingSphere();\n      return this;\n    }\n  }, {\n    key: \"setColors\",\n    value: function setColors(array) {\n      var colors;\n      if (array instanceof Float32Array) {\n        colors = array;\n      } else if (Array.isArray(array)) {\n        colors = new Float32Array(array);\n      }\n      var instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n      this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n      this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n      return this;\n    }\n  }, {\n    key: \"fromWireframeGeometry\",\n    value: function fromWireframeGeometry(geometry) {\n      this.setPositions(geometry.attributes.position.array);\n      return this;\n    }\n  }, {\n    key: \"fromEdgesGeometry\",\n    value: function fromEdgesGeometry(geometry) {\n      this.setPositions(geometry.attributes.position.array);\n      return this;\n    }\n  }, {\n    key: \"fromMesh\",\n    value: function fromMesh(mesh) {\n      this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n      return this;\n    }\n  }, {\n    key: \"fromLineSegments\",\n    value: function fromLineSegments(lineSegments) {\n      var geometry = lineSegments.geometry;\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n      // set colors, maybe\n\n      return this;\n    }\n  }, {\n    key: \"computeBoundingBox\",\n    value: function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        _box.setFromBufferAttribute(end);\n        this.boundingBox.union(_box);\n      }\n    }\n  }, {\n    key: \"computeBoundingSphere\",\n    value: function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n      if (start !== undefined && end !== undefined) {\n        var center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        var maxRadiusSq = 0;\n        for (var i = 0, il = start.count; i < il; i++) {\n          _vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          _vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {// todo\n    }\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n      return this.applyMatrix4(matrix);\n    }\n  }]);\n  return LineSegmentsGeometry;\n}(InstancedBufferGeometry);\nexport { LineSegmentsGeometry };","map":null,"metadata":{},"sourceType":"module"}