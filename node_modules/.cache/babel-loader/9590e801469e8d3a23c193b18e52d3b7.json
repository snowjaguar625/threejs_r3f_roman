{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, AnimationClip, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack } from 'three';\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\nvar BVHLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(BVHLoader, _Loader);\n  function BVHLoader(manager) {\n    var _this;\n    _classCallCheck(this, BVHLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BVHLoader).call(this, manager));\n    _this.animateBonePositions = true;\n    _this.animateBoneRotations = true;\n    return _this;\n  }\n  _createClass(BVHLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      /*\n      reads a string array (lines) from a BVH file\n      and outputs a skeleton structure including motion data\n      returns thee root node:\n      { name: '', channels: [], children: [] }\n      */\n      function readBvh(lines) {\n        // read model structure\n        if (nextLine(lines) !== 'HIERARCHY') {\n          console.error('THREE.BVHLoader: HIERARCHY expected.');\n        }\n        var list = []; // collects flat array of all bones\n\n        var root = readNode(lines, nextLine(lines), list); // read motion data\n\n        if (nextLine(lines) !== 'MOTION') {\n          console.error('THREE.BVHLoader: MOTION expected.');\n        } // number of frames\n\n        var tokens = nextLine(lines).split(/[\\s]+/);\n        var numFrames = parseInt(tokens[1]);\n        if (isNaN(numFrames)) {\n          console.error('THREE.BVHLoader: Failed to read number of frames.');\n        } // frame time\n\n        tokens = nextLine(lines).split(/[\\s]+/);\n        var frameTime = parseFloat(tokens[2]);\n        if (isNaN(frameTime)) {\n          console.error('THREE.BVHLoader: Failed to read frame time.');\n        } // read frame data line by line\n\n        for (var i = 0; i < numFrames; i++) {\n          tokens = nextLine(lines).split(/[\\s]+/);\n          readFrameData(tokens, i * frameTime, root);\n        }\n        return list;\n      }\n      /*\n      Recursively reads data from a single frame into the bone hierarchy.\n      The passed bone hierarchy has to be structured in the same order as the BVH file.\n      keyframe data is stored in bone.frames.\n      - data: splitted string array (frame values), values are shift()ed so\n      this should be empty after parsing the whole hierarchy.\n      - frameTime: playback time for this keyframe.\n      - bone: the bone to read frame data from.\n      */\n\n      function readFrameData(data, frameTime, bone) {\n        // end sites have no motion data\n        if (bone.type === 'ENDSITE') return; // add keyframe\n\n        var keyframe = {\n          time: frameTime,\n          position: new Vector3(),\n          rotation: new Quaternion()\n        };\n        bone.frames.push(keyframe);\n        var quat = new Quaternion();\n        var vx = new Vector3(1, 0, 0);\n        var vy = new Vector3(0, 1, 0);\n        var vz = new Vector3(0, 0, 1); // parse values for each channel in node\n\n        for (var i = 0; i < bone.channels.length; i++) {\n          switch (bone.channels[i]) {\n            case 'Xposition':\n              keyframe.position.x = parseFloat(data.shift().trim());\n              break;\n            case 'Yposition':\n              keyframe.position.y = parseFloat(data.shift().trim());\n              break;\n            case 'Zposition':\n              keyframe.position.z = parseFloat(data.shift().trim());\n              break;\n            case 'Xrotation':\n              quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            case 'Yrotation':\n              quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            case 'Zrotation':\n              quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            default:\n              console.warn('THREE.BVHLoader: Invalid channel type.');\n          }\n        } // parse child nodes\n\n        for (var _i = 0; _i < bone.children.length; _i++) {\n          readFrameData(data, frameTime, bone.children[_i]);\n        }\n      }\n      /*\n      Recursively parses the HIERACHY section of the BVH file\n      - lines: all lines of the file. lines are consumed as we go along.\n      - firstline: line containing the node type and name e.g. 'JOINT hip'\n      - list: collects a flat list of nodes\n      returns: a BVH node including children\n      */\n\n      function readNode(lines, firstline, list) {\n        var node = {\n          name: '',\n          type: '',\n          frames: []\n        };\n        list.push(node); // parse node type and name\n\n        var tokens = firstline.split(/[\\s]+/);\n        if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n          node.type = 'ENDSITE';\n          node.name = 'ENDSITE'; // bvh end sites have no name\n        } else {\n          node.name = tokens[1];\n          node.type = tokens[0].toUpperCase();\n        }\n        if (nextLine(lines) !== '{') {\n          console.error('THREE.BVHLoader: Expected opening { after type & name');\n        } // parse OFFSET\n\n        tokens = nextLine(lines).split(/[\\s]+/);\n        if (tokens[0] !== 'OFFSET') {\n          console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n        }\n        if (tokens.length !== 4) {\n          console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n        }\n        var offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n        if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n          console.error('THREE.BVHLoader: Invalid values of OFFSET.');\n        }\n        node.offset = offset; // parse CHANNELS definitions\n\n        if (node.type !== 'ENDSITE') {\n          tokens = nextLine(lines).split(/[\\s]+/);\n          if (tokens[0] !== 'CHANNELS') {\n            console.error('THREE.BVHLoader: Expected CHANNELS definition.');\n          }\n          var numChannels = parseInt(tokens[1]);\n          node.channels = tokens.splice(2, numChannels);\n          node.children = [];\n        } // read children\n\n        while (true) {\n          var line = nextLine(lines);\n          if (line === '}') {\n            return node;\n          } else {\n            node.children.push(readNode(lines, line, list));\n          }\n        }\n      }\n      /*\n      recursively converts the internal bvh node structure to a Bone hierarchy\n      source: the bvh root node\n      list: pass an empty array, collects a flat list of all converted THREE.Bones\n      returns the root Bone\n      */\n\n      function toTHREEBone(source, list) {\n        var bone = new Bone();\n        list.push(bone);\n        bone.position.add(source.offset);\n        bone.name = source.name;\n        if (source.type !== 'ENDSITE') {\n          for (var i = 0; i < source.children.length; i++) {\n            bone.add(toTHREEBone(source.children[i], list));\n          }\n        }\n        return bone;\n      }\n      /*\n      builds a AnimationClip from the keyframe data saved in each bone.\n      bone: bvh root node\n      returns: a AnimationClip containing position and quaternion tracks\n      */\n\n      function toTHREEAnimation(bones) {\n        var tracks = []; // create a position and quaternion animation track for each node\n\n        for (var i = 0; i < bones.length; i++) {\n          var bone = bones[i];\n          if (bone.type === 'ENDSITE') continue; // track data\n\n          var times = [];\n          var positions = [];\n          var rotations = [];\n          for (var j = 0; j < bone.frames.length; j++) {\n            var frame = bone.frames[j];\n            times.push(frame.time); // the animation system animates the position property,\n            // so we have to add the joint offset to all values\n\n            positions.push(frame.position.x + bone.offset.x);\n            positions.push(frame.position.y + bone.offset.y);\n            positions.push(frame.position.z + bone.offset.z);\n            rotations.push(frame.rotation.x);\n            rotations.push(frame.rotation.y);\n            rotations.push(frame.rotation.z);\n            rotations.push(frame.rotation.w);\n          }\n          if (scope.animateBonePositions) {\n            tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n          }\n          if (scope.animateBoneRotations) {\n            tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n          }\n        }\n        return new AnimationClip('animation', -1, tracks);\n      }\n      /*\n      returns the next non-empty line in lines\n      */\n\n      function nextLine(lines) {\n        var line; // skip empty lines\n\n        while ((line = lines.shift().trim()).length === 0) {}\n        return line;\n      }\n      var scope = this;\n      var lines = text.split(/[\\r\\n]+/g);\n      var bones = readBvh(lines);\n      var threeBones = [];\n      toTHREEBone(bones[0], threeBones);\n      var threeClip = toTHREEAnimation(bones);\n      return {\n        skeleton: new Skeleton(threeBones),\n        clip: threeClip\n      };\n    }\n  }]);\n  return BVHLoader;\n}(Loader);\nexport { BVHLoader };","map":null,"metadata":{},"sourceType":"module"}