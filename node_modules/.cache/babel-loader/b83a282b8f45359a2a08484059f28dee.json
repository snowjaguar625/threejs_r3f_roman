{"ast":null,"code":"import { Vector2 } from 'three';\nvar DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nvar BlurShaderUtils = {\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\n    var gaussian = function gaussian(x, stdDev) {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n    var weights = [];\n    for (var i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\n    var offsets = [];\n    for (var i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: function configure(shader, kernelRadius, stdDev, uvIncrement) {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius;\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":null,"metadata":{},"sourceType":"module"}