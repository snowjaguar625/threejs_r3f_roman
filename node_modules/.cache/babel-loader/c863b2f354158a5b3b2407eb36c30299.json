{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\nvar tokens_public_1 = require(\"../scan/tokens_public\");\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\nexports.defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function buildMismatchTokenMessage(_a) {\n    var expected = _a.expected,\n      actual = _a.actual,\n      previous = _a.previous,\n      ruleName = _a.ruleName;\n    var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n    var expectedMsg = hasLabel ? \"--> \".concat((0, tokens_public_1.tokenLabel)(expected), \" <--\") : \"token of type --> \".concat(expected.name, \" <--\");\n    var msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_a) {\n    var firstRedundant = _a.firstRedundant,\n      ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function buildNoViableAltMessage(_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n      actual = _a.actual,\n      previous = _a.previous,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = (0, first_1.default)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function (currPath) {\n        return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\", \"), \"]\");\n      });\n      var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \".concat(idx + 1, \". \").concat(itemMsg);\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function buildEarlyExitMessage(_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n      actual = _a.actual,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = (0, first_1.default)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function (currPath) {\n        return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\",\"), \"]\");\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + \"<\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof gast_1.Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof gast_1.NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = (0, first_1.default)(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = (0, gast_2.getProductionDslName)(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \");\n    // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError: function buildNamespaceConflictError(rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + \"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {\n    var pathMsg = (0, map_1.default)(options.prefixPath, function (currTok) {\n      return (0, tokens_public_1.tokenLabel)(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\n\") + \"in <OR\".concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {\n    var pathMsg = (0, map_1.default)(options.prefixPath, function (currtok) {\n      return (0, tokens_public_1.tokenLabel)(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \">\") + \" inside <\".concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {\n    var dslName = (0, gast_2.getProductionDslName)(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    var errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\n\") + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError: function buildTokenNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError: function buildEmptyAlternationError(options) {\n    var errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \">\") + \" in <OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + \"<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function buildLeftRecursionError(options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = (0, map_1.default)(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames.concat([ruleName]).join(\" --> \"));\n    var errMsg = \"Left Recursion found in grammar.\\n\" + \"rule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\n\") + \"without consuming any Tokens. The grammar path that causes this is: \\n \".concat(leftRecursivePath, \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {\n    var ruleName;\n    if (options.topLevelRule instanceof gast_1.Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    var errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n    return errMsg;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}