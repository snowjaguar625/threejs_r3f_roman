{"ast":null,"code":"import _objectSpread from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from 'three';\nvar ColladaExporter = /*#__PURE__*/function () {\n  function ColladaExporter() {\n    _classCallCheck(this, ColladaExporter);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"geometryInfo\", void 0);\n    _defineProperty(this, \"materialMap\", void 0);\n    _defineProperty(this, \"imageMap\", void 0);\n    _defineProperty(this, \"textures\", void 0);\n    _defineProperty(this, \"libraryImages\", void 0);\n    _defineProperty(this, \"libraryGeometries\", void 0);\n    _defineProperty(this, \"libraryEffects\", void 0);\n    _defineProperty(this, \"libraryMaterials\", void 0);\n    _defineProperty(this, \"canvas\", void 0);\n    _defineProperty(this, \"ctx\", void 0);\n    _defineProperty(this, \"transMat\", void 0);\n    _defineProperty(this, \"getFuncs\", ['getX', 'getY', 'getZ', 'getW']);\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = new WeakMap();\n    this.materialMap = new WeakMap();\n    this.imageMap = new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  _createClass(ColladaExporter, [{\n    key: \"parse\",\n    value: function parse(object, onDone) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.options = _objectSpread({}, this.options, options);\n      if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n        console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.');\n        return null;\n      }\n      if (this.options.unitName !== null && this.options.unitMeter === null) {\n        console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.');\n        return null;\n      }\n      if (this.options.unitMeter !== null && this.options.unitName === null) {\n        console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.');\n        return null;\n      }\n      if (this.options.textureDirectory !== '') {\n        this.options.textureDirectory = \"\".concat(this.options.textureDirectory, \"/\").replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n      }\n      if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n        console.warn(\"ColladaExporter : Version \".concat(this.options.version, \" not supported for export. Only 1.4.1 and 1.5.0.\"));\n        return null;\n      }\n      var libraryVisualScenes = this.processObject(object);\n      var specLink = this.options.version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n      var dae = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\" ?>\".concat(\"<COLLADA xmlns=\\\"\".concat(specLink, \"\\\" version=\\\"\").concat(this.options.version, \"\\\">\"), \"<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>\", this.options.author !== null ? \"<author>\".concat(this.options.author, \"</author>\") : '', \"</contributor>\", \"<created>\".concat(new Date().toISOString(), \"</created>\"), \"<modified>\".concat(new Date().toISOString(), \"</modified>\"), \"<up_axis>Y_UP</up_axis></asset>\");\n      dae += \"<library_images>\".concat(this.libraryImages.join(''), \"</library_images>\");\n      dae += \"<library_effects>\".concat(this.libraryEffects.join(''), \"</library_effects>\");\n      dae += \"<library_materials>\".concat(this.libraryMaterials.join(''), \"</library_materials>\");\n      dae += \"<library_geometries>\".concat(this.libraryGeometries.join(''), \"</library_geometries>\");\n      dae += \"<library_visual_scenes><visual_scene id=\\\"Scene\\\" name=\\\"scene\\\">\".concat(libraryVisualScenes, \"</visual_scene></library_visual_scenes>\");\n      dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n      dae += '</COLLADA>';\n      var res = {\n        data: this.format(dae),\n        textures: this.textures\n      };\n      if (typeof onDone === 'function') {\n        requestAnimationFrame(function () {\n          return onDone(res);\n        });\n      }\n      return res;\n    } // Convert the urdf xml into a well-formatted, indented format\n  }, {\n    key: \"format\",\n    value: function format(urdf) {\n      var _urdf$match$map$join, _urdf$match;\n      var IS_END_TAG = /^<\\//;\n      var IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n      var HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n      var pad = function pad(ch, num) {\n        return num > 0 ? ch + pad(ch, num - 1) : '';\n      };\n      var tagnum = 0;\n      return (_urdf$match$map$join = (_urdf$match = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) === null || _urdf$match === void 0 ? void 0 : _urdf$match.map(function (tag) {\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n          tagnum--;\n        }\n        var res = \"\".concat(pad('  ', tagnum)).concat(tag);\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n          tagnum++;\n        }\n        return res;\n      }).join('\\n')) != null ? _urdf$match$map$join : '';\n    } // Convert an image into a png format for saving\n  }, {\n    key: \"base64ToBuffer\",\n    value: function base64ToBuffer(str) {\n      var b = atob(str);\n      var buf = new Uint8Array(b.length);\n      for (var i = 0, l = buf.length; i < l; i++) {\n        buf[i] = b.charCodeAt(i);\n      }\n      return buf;\n    }\n  }, {\n    key: \"imageToData\",\n    value: function imageToData(image, ext) {\n      var _this$ctx;\n      this.canvas = this.canvas || document.createElement('canvas');\n      this.ctx = this.ctx || this.canvas.getContext('2d');\n      this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n      this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n      (_this$ctx = this.ctx) === null || _this$ctx === void 0 ? void 0 : _this$ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n      var base64data = this.canvas.toDataURL(\"image/\".concat(ext), 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n      return this.base64ToBuffer(base64data);\n    } // gets the attribute array. Generate a new array if the attribute is interleaved\n  }, {\n    key: \"attrBufferToArray\",\n    value: function attrBufferToArray(attr) {\n      if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n        // use the typed array constructor to save on memory\n        var TypedArrayConstructor = attr.array.constructor; // @ts-expect-error\n\n        var arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n        var size = attr.itemSize;\n        for (var i = 0, l = attr.count; i < l; i++) {\n          for (var j = 0; j < size; j++) {\n            arr[i * size + j] = attr[this.getFuncs[j]](i);\n          }\n        }\n        return arr;\n      } else {\n        return attr.array;\n      }\n    } // Returns an array of the same type starting at the `st` index,\n    // and `ct` length\n  }, {\n    key: \"subArray\",\n    value: function subArray(arr, st, ct) {\n      if (Array.isArray(arr)) {\n        return arr.slice(st, st + ct);\n      } else {\n        var TypedArrayConstructor = arr.constructor; // @ts-expect-error\n\n        return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n      }\n    } // Returns the string for a geometry's attribute\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(attr, name, params, type) {\n      var array = this.attrBufferToArray(attr);\n      var res = Array.isArray(array) ? \"\".concat(\"<source id=\\\"\".concat(name, \"\\\">\") + \"<float_array id=\\\"\".concat(name, \"-array\\\" count=\\\"\").concat(array.length, \"\\\">\") + array.join(' '), \"</float_array><technique_common>\", \"<accessor source=\\\"#\".concat(name, \"-array\\\" count=\\\"\").concat(Math.floor(array.length / attr.itemSize), \"\\\" stride=\\\"\").concat(attr.itemSize, \"\\\">\")).concat(params.map(function (n) {\n        return \"<param name=\\\"\".concat(n, \"\\\" type=\\\"\").concat(type, \"\\\" />\");\n      }).join(''), \"</accessor></technique_common></source>\") : '';\n      return res;\n    } // Returns the string for a node's transform information\n  }, {\n    key: \"getTransform\",\n    value: function getTransform(o) {\n      // ensure the object's matrix is up to date\n      // before saving the transform\n      o.updateMatrix();\n      this.transMat = this.transMat || new Matrix4();\n      this.transMat.copy(o.matrix);\n      this.transMat.transpose();\n      return \"<matrix>\".concat(this.transMat.toArray().join(' '), \"</matrix>\");\n    } // Process the given piece of geometry into the geometry library\n    // Returns the mesh id\n  }, {\n    key: \"processGeometry\",\n    value: function processGeometry(g) {\n      var info = this.geometryInfo.get(g);\n      if (!info) {\n        // convert the geometry to bufferGeometry if it isn't already\n        var bufferGeometry = g;\n        if (!bufferGeometry.isBufferGeometry) {\n          throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n        var meshid = \"Mesh\".concat(this.libraryGeometries.length + 1);\n        var indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n        var groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n          start: 0,\n          count: indexCount,\n          materialIndex: 0\n        }];\n        var gname = g.name ? \" name=\\\"\".concat(g.name, \"\\\"\") : '';\n        var gnode = \"<geometry id=\\\"\".concat(meshid, \"\\\"\").concat(gname, \"><mesh>\"); // define the geometry node and the vertices for the geometry\n\n        var posName = \"\".concat(meshid, \"-position\");\n        var vertName = \"\".concat(meshid, \"-vertices\");\n        gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n        gnode += \"<vertices id=\\\"\".concat(vertName, \"\\\"><input semantic=\\\"POSITION\\\" source=\\\"#\").concat(posName, \"\\\" /></vertices>\"); // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n        // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n        // models with attributes that share an offset.\n        // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n        // serialize normals\n\n        var triangleInputs = \"<input semantic=\\\"VERTEX\\\" source=\\\"#\".concat(vertName, \"\\\" offset=\\\"0\\\" />\");\n        if ('normal' in bufferGeometry.attributes) {\n          var normName = \"\".concat(meshid, \"-normal\");\n          gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n          triangleInputs += \"<input semantic=\\\"NORMAL\\\" source=\\\"#\".concat(normName, \"\\\" offset=\\\"0\\\" />\");\n        } // serialize uvs\n\n        if ('uv' in bufferGeometry.attributes) {\n          var uvName = \"\".concat(meshid, \"-texcoord\");\n          gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n          triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"0\\\" />\");\n        } // serialize lightmap uvs\n\n        if ('uv2' in bufferGeometry.attributes) {\n          var _uvName = \"\".concat(meshid, \"-texcoord2\");\n          gnode += this.getAttribute(bufferGeometry.attributes.uv2, _uvName, ['S', 'T'], 'float');\n          triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(_uvName, \"\\\" offset=\\\"0\\\" set=\\\"1\\\" />\");\n        } // serialize colors\n\n        if ('color' in bufferGeometry.attributes) {\n          var colName = \"\".concat(meshid, \"-color\");\n          gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n          triangleInputs += \"<input semantic=\\\"COLOR\\\" source=\\\"#\".concat(colName, \"\\\" offset=\\\"0\\\" />\");\n        }\n        var indexArray = null;\n        if (bufferGeometry.index) {\n          indexArray = this.attrBufferToArray(bufferGeometry.index);\n        } else {\n          indexArray = new Array(indexCount);\n          for (var i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) {\n            indexArray[i] = i;\n          }\n        }\n        for (var _i = 0, _l = groups.length; _i < _l; _i++) {\n          var group = groups[_i];\n          var subarr = this.subArray(indexArray, group.start, group.count);\n          var polycount = subarr.length / 3;\n          gnode += \"<triangles material=\\\"MESH_MATERIAL_\".concat(group.materialIndex, \"\\\" count=\\\"\").concat(polycount, \"\\\">\");\n          gnode += triangleInputs;\n          gnode += \"<p>\".concat(subarr.join(' '), \"</p>\");\n          gnode += '</triangles>';\n        }\n        gnode += '</mesh></geometry>';\n        this.libraryGeometries.push(gnode);\n        info = {\n          meshid: meshid,\n          bufferGeometry: bufferGeometry\n        };\n        this.geometryInfo.set(g, info);\n      }\n      return info;\n    } // Process the given texture into the image library\n    // Returns the image library\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(tex) {\n      var texid = this.imageMap.get(tex);\n      if (texid == null) {\n        texid = \"image-\".concat(this.libraryImages.length + 1);\n        var ext = 'png';\n        var name = tex.name || texid;\n        var imageNode = \"<image id=\\\"\".concat(texid, \"\\\" name=\\\"\").concat(name, \"\\\">\");\n        if (this.options.version === '1.5.0') {\n          imageNode += \"<init_from><ref>\".concat(this.options.textureDirectory).concat(name, \".\").concat(ext, \"</ref></init_from>\");\n        } else {\n          // version image node 1.4.1\n          imageNode += \"<init_from>\".concat(this.options.textureDirectory).concat(name, \".\").concat(ext, \"</init_from>\");\n        }\n        imageNode += '</image>';\n        this.libraryImages.push(imageNode);\n        this.imageMap.set(tex, texid);\n        this.textures.push({\n          directory: this.options.textureDirectory,\n          name: name,\n          ext: ext,\n          data: this.imageToData(tex.image, ext),\n          original: tex\n        });\n      }\n      return texid;\n    } // Process the given material into the material and effect libraries\n    // Returns the material id\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(m) {\n      var matid = this.materialMap.get(m);\n      if (matid == null) {\n        matid = \"Mat\".concat(this.libraryEffects.length + 1);\n        var type = 'phong';\n        if (m instanceof MeshLambertMaterial) {\n          type = 'lambert';\n        } else if (m instanceof MeshBasicMaterial) {\n          type = 'constant';\n          if (m.map !== null) {\n            // The Collada spec does not support diffuse texture maps with the\n            // constant shader type.\n            // mrdoob/three.js#15469\n            console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n          }\n        }\n        if (m instanceof MeshPhongMaterial) {\n          var emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n          var diffuse = m.color ? m.color : new Color(0, 0, 0);\n          var specular = m.specular ? m.specular : new Color(1, 1, 1);\n          var shininess = m.shininess || 0;\n          var reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n          // in three.js alpha maps are black and white, but collada expects the alpha\n          // channel to specify the transparency\n\n          var transparencyNode = '';\n          if (m.transparent) {\n            transparencyNode += \"<transparent>\".concat(m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>', \"</transparent>\");\n            if (m.opacity < 1) {\n              transparencyNode += \"<transparency><float>\".concat(m.opacity, \"</float></transparency>\");\n            }\n          }\n          var techniqueNode = \"\".concat(\"<technique sid=\\\"common\\\"><\".concat(type, \">\"), \"<emission>\", m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"emission\\\">\".concat(emissive.r, \" \").concat(emissive.g, \" \").concat(emissive.b, \" 1</color>\"), \"</emission>\").concat(type !== 'constant' ? \"<diffuse>\".concat(m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"diffuse\\\">\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color>\"), \"</diffuse>\") : '').concat(type !== 'constant' ? \"<bump>\".concat(m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : '', \"</bump>\") : '').concat(type === 'phong' ? \"\".concat(\"<specular><color sid=\\\"specular\\\">\".concat(specular.r, \" \").concat(specular.g, \" \").concat(specular.b, \" 1</color></specular>\"), \"<shininess>\", m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : \"<float sid=\\\"shininess\\\">\".concat(shininess, \"</float>\"), \"</shininess>\") : '', \"<reflective><color>\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color></reflective>\"), \"<reflectivity><float>\".concat(reflectivity, \"</float></reflectivity>\")).concat(transparencyNode, \"</\".concat(type, \"></technique>\"));\n          var effectnode = \"\".concat(\"<effect id=\\\"\".concat(matid, \"-effect\\\">\"), \"<profile_COMMON>\", m.map ? \"<newparam sid=\\\"diffuse-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.map), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"diffuse-sampler\\\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>\") : '').concat(m.specularMap ? \"<newparam sid=\\\"specular-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.specularMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"specular-sampler\\\"><sampler2D><source>specular-surface</source></sampler2D></newparam>\") : '').concat(m.emissiveMap ? \"<newparam sid=\\\"emissive-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.emissiveMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"emissive-sampler\\\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>\") : '').concat(m.normalMap ? \"<newparam sid=\\\"bump-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.normalMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"bump-sampler\\\"><sampler2D><source>bump-surface</source></sampler2D></newparam>\") : '').concat(techniqueNode).concat(m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : '', \"</profile_COMMON></effect>\");\n          var materialName = m.name ? \" name=\\\"\".concat(m.name, \"\\\"\") : '';\n          var materialNode = \"<material id=\\\"\".concat(matid, \"\\\"\").concat(materialName, \"><instance_effect url=\\\"#\").concat(matid, \"-effect\\\" /></material>\");\n          this.libraryMaterials.push(materialNode);\n          this.libraryEffects.push(effectnode);\n          this.materialMap.set(m, matid);\n        }\n      }\n      return matid;\n    } // Recursively process the object into a scene\n  }, {\n    key: \"processObject\",\n    value: function processObject(o) {\n      var _this = this;\n      var node = \"<node name=\\\"\".concat(o.name, \"\\\">\");\n      node += this.getTransform(o);\n      new Mesh();\n      if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n        // function returns the id associated with the mesh and a \"BufferGeometry\" version\n        // of the geometry in case it's not a geometry.\n        var geomInfo = this.processGeometry(o.geometry);\n        var meshid = geomInfo.meshid;\n        var geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n        var matids = null;\n        var matidsArray; // get a list of materials to bind to the sub groups of the geometry.\n        // If the amount of subgroups is greater than the materials, than reuse\n        // the materials.\n\n        var mat = o.material || new MeshBasicMaterial();\n        var materials = Array.isArray(mat) ? mat : [mat];\n        if (geometry.groups.length > materials.length) {\n          matidsArray = new Array(geometry.groups.length);\n        } else {\n          matidsArray = new Array(materials.length);\n        }\n        matids = matidsArray.fill(null).map(function (_, i) {\n          return _this.processMaterial(materials[i % materials.length]);\n        });\n        node += \"\".concat(\"<instance_geometry url=\\\"#\".concat(meshid, \"\\\">\") + (matids != null ? \"<bind_material><technique_common>\".concat(matids.map(function (id, i) {\n          return \"\".concat(\"<instance_material symbol=\\\"MESH_MATERIAL_\".concat(i, \"\\\" target=\\\"#\").concat(id, \"\\\" >\"), \"<bind_vertex_input semantic=\\\"TEXCOORD\\\" input_semantic=\\\"TEXCOORD\\\" input_set=\\\"0\\\" /></instance_material>\");\n        }).join(''), \"</technique_common></bind_material>\") : ''), \"</instance_geometry>\");\n      }\n      o.children.forEach(function (c) {\n        return node += _this.processObject(c);\n      });\n      node += '</node>';\n      return node;\n    }\n  }]);\n  return ColladaExporter;\n}();\nexport { ColladaExporter };","map":null,"metadata":{},"sourceType":"module"}