{"ast":null,"code":"import { Vector4, Vector3 } from 'three';\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\n/*\n\tFinds knot vector span.\n\n\tp : degree\n\tu : parametric value\n\tU : knot vector\n\n\treturns the span\n\t*/\n\nfunction findSpan(p, u, U) {\n  var n = U.length - p - 1;\n  if (u >= U[n]) {\n    return n - 1;\n  }\n  if (u <= U[p]) {\n    return p;\n  }\n  var low = p;\n  var high = n;\n  var mid = Math.floor((low + high) / 2);\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n    mid = Math.floor((low + high) / 2);\n  }\n  return mid;\n}\n/*\n\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tU    : knot vector\n\n\treturns array[p+1] with basis functions values.\n\t*/\n\nfunction calcBasisFunctions(span, u, p, U) {\n  var N = [];\n  var left = [];\n  var right = [];\n  N[0] = 1.0;\n  for (var j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    var saved = 0.0;\n    for (var r = 0; r < j; ++r) {\n      var rv = right[r + 1];\n      var lv = left[j - r];\n      var temp = N[r] / (rv + lv);\n      N[r] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    N[j] = saved;\n  }\n  return N;\n}\n/*\n\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\tp : degree of B-Spline\n\tU : knot vector\n\tP : control points (x, y, z, w)\n\tu : parametric point\n\n\treturns point for given u\n\t*/\n\nfunction calcBSplinePoint(p, U, P, u) {\n  var span = findSpan(p, u, U);\n  var N = calcBasisFunctions(span, u, p, U);\n  var C = new Vector4(0, 0, 0, 0);\n  for (var j = 0; j <= p; ++j) {\n    var point = P[span - p + j];\n    var Nj = N[j];\n    var wNj = point.w * Nj;\n    C.x += point.x * wNj;\n    C.y += point.y * wNj;\n    C.z += point.z * wNj;\n    C.w += point.w * Nj;\n  }\n  return C;\n}\n/*\n\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tn    : number of derivatives to calculate\n\tU    : knot vector\n\n\treturns array[n+1][p+1] with basis functions derivatives\n\t*/\n\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  var zeroArr = [];\n  for (var i = 0; i <= p; ++i) {\n    zeroArr[i] = 0.0;\n  }\n  var ders = [];\n  for (var _i = 0; _i <= n; ++_i) {\n    ders[_i] = zeroArr.slice(0);\n  }\n  var ndu = [];\n  for (var _i2 = 0; _i2 <= p; ++_i2) {\n    ndu[_i2] = zeroArr.slice(0);\n  }\n  ndu[0][0] = 1.0;\n  var left = zeroArr.slice(0);\n  var right = zeroArr.slice(0);\n  for (var _j = 1; _j <= p; ++_j) {\n    left[_j] = u - U[span + 1 - _j];\n    right[_j] = U[span + _j] - u;\n    var saved = 0.0;\n    for (var _r = 0; _r < _j; ++_r) {\n      var rv = right[_r + 1];\n      var lv = left[_j - _r];\n      ndu[_j][_r] = rv + lv;\n      var temp = ndu[_r][_j - 1] / ndu[_j][_r];\n      ndu[_r][_j] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    ndu[_j][_j] = saved;\n  }\n  for (var _j2 = 0; _j2 <= p; ++_j2) {\n    ders[0][_j2] = ndu[_j2][p];\n  }\n  for (var _r2 = 0; _r2 <= p; ++_r2) {\n    var s1 = 0;\n    var s2 = 1;\n    var a = [];\n    for (var _i3 = 0; _i3 <= p; ++_i3) {\n      a[_i3] = zeroArr.slice(0);\n    }\n    a[0][0] = 1.0;\n    for (var k = 1; k <= n; ++k) {\n      var d = 0.0;\n      var rk = _r2 - k;\n      var pk = p - k;\n      if (_r2 >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n        d = a[s2][0] * ndu[rk][pk];\n      }\n      var j1 = rk >= -1 ? 1 : -rk;\n      var j2 = _r2 - 1 <= pk ? k - 1 : p - _r2;\n      for (var _j3 = j1; _j3 <= j2; ++_j3) {\n        a[s2][_j3] = (a[s1][_j3] - a[s1][_j3 - 1]) / ndu[pk + 1][rk + _j3];\n        d += a[s2][_j3] * ndu[rk + _j3][pk];\n      }\n      if (_r2 <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][_r2];\n        d += a[s2][k] * ndu[_r2][pk];\n      }\n      ders[k][_r2] = d;\n      var j = s1;\n      s1 = s2;\n      s2 = j;\n    }\n  }\n  var r = p;\n  for (var _k = 1; _k <= n; ++_k) {\n    for (var _j4 = 0; _j4 <= p; ++_j4) {\n      ders[_k][_j4] *= r;\n    }\n    r *= p - _k;\n  }\n  return ders;\n}\n/*\n\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points\n\t\tu  : Parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array[d+1] with derivatives\n\t\t*/\n\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  var du = nd < p ? nd : p;\n  var CK = [];\n  var span = findSpan(p, u, U);\n  var nders = calcBasisFunctionDerivatives(span, u, p, du, U);\n  var Pw = [];\n  for (var i = 0; i < P.length; ++i) {\n    var point = P[i].clone();\n    var w = point.w;\n    point.x *= w;\n    point.y *= w;\n    point.z *= w;\n    Pw[i] = point;\n  }\n  for (var k = 0; k <= du; ++k) {\n    var point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n    for (var j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n    }\n    CK[k] = point;\n  }\n  for (var _k2 = du + 1; _k2 <= nd + 1; ++_k2) {\n    CK[_k2] = new Vector4(0, 0, 0);\n  }\n  return CK;\n}\n/*\n\tCalculate \"K over I\"\n\n\treturns k!/(i!(k-i)!)\n\t*/\n\nfunction calcKoverI(k, i) {\n  var nom = 1;\n  for (var j = 2; j <= k; ++j) {\n    nom *= j;\n  }\n  var denom = 1;\n  for (var _j5 = 2; _j5 <= i; ++_j5) {\n    denom *= _j5;\n  }\n  for (var _j6 = 2; _j6 <= k - i; ++_j6) {\n    denom *= _j6;\n  }\n  return nom / denom;\n}\n/*\n\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\tPders : result of function calcBSplineDerivatives\n\n\treturns array with derivatives for rational curve.\n\t*/\n\nfunction calcRationalCurveDerivatives(Pders) {\n  var nd = Pders.length;\n  var Aders = [];\n  var wders = [];\n  for (var i = 0; i < nd; ++i) {\n    var point = Pders[i];\n    Aders[i] = new Vector3(point.x, point.y, point.z);\n    wders[i] = point.w;\n  }\n  var CK = [];\n  for (var k = 0; k < nd; ++k) {\n    var v = Aders[k].clone();\n    for (var _i4 = 1; _i4 <= k; ++_i4) {\n      v.sub(CK[k - _i4].clone().multiplyScalar(calcKoverI(k, _i4) * wders[_i4]));\n    }\n    CK[k] = v.divideScalar(wders[0]);\n  }\n  return CK;\n}\n/*\n\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points in homogeneous space\n\tu  : parametric points\n\tnd : number of derivatives\n\n\treturns array with derivatives.\n\t*/\n\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  var Pders = calcBSplineDerivatives(p, U, P, u, nd);\n  return calcRationalCurveDerivatives(Pders);\n}\n/*\n\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\tp1, p2 : degrees of B-Spline surface\n\tU1, U2 : knot vectors\n\tP      : control points (x, y, z, w)\n\tu, v   : parametric values\n\n\treturns point for given (u, v)\n\t*/\n\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  var uspan = findSpan(p, u, U);\n  var vspan = findSpan(q, v, V);\n  var Nu = calcBasisFunctions(uspan, u, p, U);\n  var Nv = calcBasisFunctions(vspan, v, q, V);\n  var temp = [];\n  for (var l = 0; l <= q; ++l) {\n    temp[l] = new Vector4(0, 0, 0, 0);\n    for (var k = 0; k <= p; ++k) {\n      var point = P[uspan - p + k][vspan - q + l].clone();\n      var w = point.w;\n      point.x *= w;\n      point.y *= w;\n      point.z *= w;\n      temp[l].add(point.multiplyScalar(Nu[k]));\n    }\n  }\n  var Sw = new Vector4(0, 0, 0, 0);\n  for (var _l = 0; _l <= q; ++_l) {\n    Sw.add(temp[_l].multiplyScalar(Nv[_l]));\n  }\n  Sw.divideScalar(Sw.w);\n  target.set(Sw.x, Sw.y, Sw.z);\n}\nexport { calcBSplineDerivatives, calcBSplinePoint, calcBasisFunctionDerivatives, calcBasisFunctions, calcKoverI, calcNURBSDerivatives, calcRationalCurveDerivatives, calcSurfacePoint, findSpan };","map":null,"metadata":{},"sourceType":"module"}