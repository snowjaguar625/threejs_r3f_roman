{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\nvar PLYLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PLYLoader, _Loader);\n  function PLYLoader(manager) {\n    var _this;\n    _classCallCheck(this, PLYLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PLYLoader).call(this, manager));\n    _this.propertyNameMapping = {};\n    return _this;\n  }\n  _createClass(PLYLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"setPropertyNameMapping\",\n    value: function setPropertyNameMapping(mapping) {\n      this.propertyNameMapping = mapping;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseHeader(data) {\n        var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n        var headerText = '';\n        var headerLength = 0;\n        var result = patternHeader.exec(data);\n        if (result !== null) {\n          headerText = result[1];\n          headerLength = new Blob([result[0]]).size;\n        }\n        var header = {\n          comments: [],\n          elements: [],\n          headerLength: headerLength,\n          objInfo: ''\n        };\n        var lines = headerText.split('\\n');\n        var currentElement;\n        function make_ply_element_property(propertValues, propertyNameMapping) {\n          var property = {\n            type: propertValues[0]\n          };\n          if (property.type === 'list') {\n            property.name = propertValues[3];\n            property.countType = propertValues[1];\n            property.itemType = propertValues[2];\n          } else {\n            property.name = propertValues[1];\n          }\n          if (property.name in propertyNameMapping) {\n            property.name = propertyNameMapping[property.name];\n          }\n          return property;\n        }\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === '') continue;\n          var lineValues = line.split(/\\s+/);\n          var lineType = lineValues.shift();\n          line = lineValues.join(' ');\n          switch (lineType) {\n            case 'format':\n              header.format = lineValues[0];\n              header.version = lineValues[1];\n              break;\n            case 'comment':\n              header.comments.push(line);\n              break;\n            case 'element':\n              if (currentElement !== undefined) {\n                header.elements.push(currentElement);\n              }\n              currentElement = {};\n              currentElement.name = lineValues[0];\n              currentElement.count = parseInt(lineValues[1]);\n              currentElement.properties = [];\n              break;\n            case 'property':\n              currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n              break;\n            case 'obj_info':\n              header.objInfo = line;\n              break;\n            default:\n              console.log('unhandled', lineType, lineValues);\n          }\n        }\n        if (currentElement !== undefined) {\n          header.elements.push(currentElement);\n        }\n        return header;\n      }\n      function parseASCIINumber(n, type) {\n        switch (type) {\n          case 'char':\n          case 'uchar':\n          case 'short':\n          case 'ushort':\n          case 'int':\n          case 'uint':\n          case 'int8':\n          case 'uint8':\n          case 'int16':\n          case 'uint16':\n          case 'int32':\n          case 'uint32':\n            return parseInt(n);\n          case 'float':\n          case 'double':\n          case 'float32':\n          case 'float64':\n            return parseFloat(n);\n        }\n      }\n      function parseASCIIElement(properties, line) {\n        var values = line.split(/\\s+/);\n        var element = {};\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === 'list') {\n            var list = [];\n            var n = parseASCIINumber(values.shift(), properties[i].countType);\n            for (var j = 0; j < n; j++) {\n              list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n            }\n            element[properties[i].name] = list;\n          } else {\n            element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n          }\n        }\n        return element;\n      }\n      function parseASCII(data, header) {\n        // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var result;\n        var patternBody = /end_header\\s([\\s\\S]*)$/;\n        var body = '';\n        if ((result = patternBody.exec(data)) !== null) {\n          body = result[1];\n        }\n        var lines = body.split('\\n');\n        var currentElement = 0;\n        var currentElementCount = 0;\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === '') {\n            continue;\n          }\n          if (currentElementCount >= header.elements[currentElement].count) {\n            currentElement++;\n            currentElementCount = 0;\n          }\n          var element = parseASCIIElement(header.elements[currentElement].properties, line);\n          handleElement(buffer, header.elements[currentElement].name, element);\n          currentElementCount++;\n        }\n        return postProcess(buffer);\n      }\n      function postProcess(buffer) {\n        var geometry = new BufferGeometry(); // mandatory buffer data\n\n        if (buffer.indices.length > 0) {\n          geometry.setIndex(buffer.indices);\n        }\n        geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3)); // optional buffer data\n\n        if (buffer.normals.length > 0) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n        }\n        if (buffer.uvs.length > 0) {\n          geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n        }\n        if (buffer.colors.length > 0) {\n          geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n        }\n        if (buffer.faceVertexUvs.length > 0) {\n          geometry = geometry.toNonIndexed();\n          geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n        }\n        geometry.computeBoundingSphere();\n        return geometry;\n      }\n      function handleElement(buffer, elementName, element) {\n        if (elementName === 'vertex') {\n          buffer.vertices.push(element.x, element.y, element.z);\n          if ('nx' in element && 'ny' in element && 'nz' in element) {\n            buffer.normals.push(element.nx, element.ny, element.nz);\n          }\n          if ('s' in element && 't' in element) {\n            buffer.uvs.push(element.s, element.t);\n          }\n          if ('red' in element && 'green' in element && 'blue' in element) {\n            buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n          }\n        } else if (elementName === 'face') {\n          var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n          var texcoord = element.texcoord;\n          if (vertex_indices.length === 3) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n            if (texcoord && texcoord.length === 6) {\n              buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n              buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n              buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n            }\n          } else if (vertex_indices.length === 4) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n            buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n          }\n        }\n      }\n      function binaryRead(dataview, at, type, little_endian) {\n        switch (type) {\n          // corespondences for non-specific length types here match rply:\n          case 'int8':\n          case 'char':\n            return [dataview.getInt8(at), 1];\n          case 'uint8':\n          case 'uchar':\n            return [dataview.getUint8(at), 1];\n          case 'int16':\n          case 'short':\n            return [dataview.getInt16(at, little_endian), 2];\n          case 'uint16':\n          case 'ushort':\n            return [dataview.getUint16(at, little_endian), 2];\n          case 'int32':\n          case 'int':\n            return [dataview.getInt32(at, little_endian), 4];\n          case 'uint32':\n          case 'uint':\n            return [dataview.getUint32(at, little_endian), 4];\n          case 'float32':\n          case 'float':\n            return [dataview.getFloat32(at, little_endian), 4];\n          case 'float64':\n          case 'double':\n            return [dataview.getFloat64(at, little_endian), 8];\n        }\n      }\n      function binaryReadElement(dataview, at, properties, little_endian) {\n        var element = {};\n        var result,\n          read = 0;\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === 'list') {\n            var list = [];\n            result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n            var n = result[0];\n            read += result[1];\n            for (var j = 0; j < n; j++) {\n              result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n              list.push(result[0]);\n              read += result[1];\n            }\n            element[properties[i].name] = list;\n          } else {\n            result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n            element[properties[i].name] = result[0];\n            read += result[1];\n          }\n        }\n        return [element, read];\n      }\n      function parseBinary(data, header) {\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var little_endian = header.format === 'binary_little_endian';\n        var body = new DataView(data, header.headerLength);\n        var result,\n          loc = 0;\n        for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n          for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n            result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n            loc += result[1];\n            var element = result[0];\n            handleElement(buffer, header.elements[currentElement].name, element);\n          }\n        }\n        return postProcess(buffer);\n      } //\n\n      var geometry;\n      var scope = this;\n      if (data instanceof ArrayBuffer) {\n        var text = LoaderUtils.decodeText(new Uint8Array(data));\n        var header = parseHeader(text);\n        geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n      } else {\n        geometry = parseASCII(data, parseHeader(data));\n      }\n      return geometry;\n    }\n  }]);\n  return PLYLoader;\n}(Loader);\nexport { PLYLoader };","map":null,"metadata":{},"sourceType":"module"}