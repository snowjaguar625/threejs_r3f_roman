{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { BufferAttribute, Matrix4, Vector3, Matrix3, MeshPhongMaterial, UniformsUtils, ShaderLib, ShaderChunk } from 'three';\n\n/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\nvar GeometryCompressionUtils = {\n  /**\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n   *\n   */\n  compressNormals: function compressNormals(mesh, encodeMethod) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n    var normal = mesh.geometry.attributes.normal;\n    if (!normal) {\n      console.error('Geometry must contain normal attribute. ');\n    }\n    if (normal.isPacked) return;\n    if (normal.itemSize != 3) {\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\n    }\n    var array = normal.array;\n    var count = normal.count;\n    var result;\n    if (encodeMethod == 'DEFAULT') {\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n      result = new Uint8Array(count * 3);\n      for (var idx = 0; idx < array.length; idx += 3) {\n        var encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx + 0] = encoded[0];\n        result[idx + 1] = encoded[1];\n        result[idx + 2] = encoded[2];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 3, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT1Byte') {\n      /**\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n       */\n      result = new Int8Array(count * 2);\n      for (var _idx = 0; _idx < array.length; _idx += 3) {\n        var _encoded = this.EncodingFuncs.octEncodeBest(array[_idx], array[_idx + 1], array[_idx + 2], 1);\n        result[_idx / 3 * 2 + 0] = _encoded[0];\n        result[_idx / 3 * 2 + 1] = _encoded[1];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT2Byte') {\n      result = new Int16Array(count * 2);\n      for (var _idx2 = 0; _idx2 < array.length; _idx2 += 3) {\n        var _encoded2 = this.EncodingFuncs.octEncodeBest(array[_idx2], array[_idx2 + 1], array[_idx2 + 2], 2);\n        result[_idx2 / 3 * 2 + 0] = _encoded2[0];\n        result[_idx2 / 3 * 2 + 1] = _encoded2[1];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else if (encodeMethod == 'ANGLES') {\n      result = new Uint16Array(count * 2);\n      for (var _idx3 = 0; _idx3 < array.length; _idx3 += 3) {\n        var _encoded3 = this.EncodingFuncs.anglesEncode(array[_idx3], array[_idx3 + 1], array[_idx3 + 2]);\n        result[_idx3 / 3 * 2 + 0] = _encoded3[0];\n        result[_idx3 / 3 * 2 + 1] = _encoded3[1];\n      }\n      mesh.geometry.setAttribute('normal', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else {\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n    }\n    mesh.geometry.attributes.normal.needsUpdate = true;\n    mesh.geometry.attributes.normal.isPacked = true;\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n    if (encodeMethod == 'ANGLES') {\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\n    }\n    if (encodeMethod == 'OCT1Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n    if (encodeMethod == 'OCT2Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n    if (encodeMethod == 'DEFAULT') {\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\n    }\n  },\n  /**\n   * Make the input mesh.geometry's position attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressPositions: function compressPositions(mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n    var position = mesh.geometry.attributes.position;\n    if (!position) {\n      console.error('Geometry must contain position attribute. ');\n    }\n    if (position.isPacked) return;\n    if (position.itemSize != 3) {\n      console.error('position.itemSize is not 3, which cannot be packed. ');\n    }\n    var array = position.array;\n    var encodingBytes = 2;\n    var result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n    var quantized = result.quantized;\n    var decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n    mesh.geometry.setAttribute('position', new BufferAttribute(quantized, 3));\n    mesh.geometry.attributes.position.isPacked = true;\n    mesh.geometry.attributes.position.needsUpdate = true;\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n    mesh.material.defines.USE_PACKED_POSITION = 0;\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n  },\n  /**\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressUvs: function compressUvs(mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry property. ');\n    }\n    var uvs = mesh.geometry.attributes.uv;\n    if (!uvs) {\n      console.error('Geometry must contain uv attribute. ');\n    }\n    if (uvs.isPacked) return;\n    var range = {\n      min: Infinity,\n      max: -Infinity\n    };\n    var array = uvs.array;\n    for (var i = 0; i < array.length; i++) {\n      range.min = Math.min(range.min, array[i]);\n      range.max = Math.max(range.max, array[i]);\n    }\n    var result;\n    if (range.min >= -1.0 && range.max <= 1.0) {\n      // use default encoding method\n      result = new Uint16Array(array.length);\n      for (var _i = 0; _i < array.length; _i += 2) {\n        var encoded = this.EncodingFuncs.defaultEncode(array[_i], array[_i + 1], 0, 2);\n        result[_i] = encoded[0];\n        result[_i + 1] = encoded[1];\n      }\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n      mesh.material.defines.USE_PACKED_UV = 0;\n    } else {\n      // use quantized encoding method\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n      mesh.geometry.setAttribute('uv', new BufferAttribute(result.quantized, 2));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n      mesh.material.defines.USE_PACKED_UV = 1;\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n    }\n  },\n  EncodingFuncs: {\n    defaultEncode: function defaultEncode(x, y, z, bytes) {\n      if (bytes == 1) {\n        var tmpx = Math.round((x + 1) * 0.5 * 255);\n        var tmpy = Math.round((y + 1) * 0.5 * 255);\n        var tmpz = Math.round((z + 1) * 0.5 * 255);\n        return new Uint8Array([tmpx, tmpy, tmpz]);\n      } else if (bytes == 2) {\n        var _tmpx = Math.round((x + 1) * 0.5 * 65535);\n        var _tmpy = Math.round((y + 1) * 0.5 * 65535);\n        var _tmpz = Math.round((z + 1) * 0.5 * 65535);\n        return new Uint16Array([_tmpx, _tmpy, _tmpz]);\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    defaultDecode: function defaultDecode(array, bytes) {\n      if (bytes == 1) {\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\n      } else if (bytes == 2) {\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    // for `Angles` encoding\n    anglesEncode: function anglesEncode(x, y, z) {\n      var normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n      var normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n      return new Uint16Array([normal0, normal1]);\n    },\n    // for `Octahedron` encoding\n    octEncodeBest: function octEncodeBest(x, y, z, bytes) {\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\n      // to minimize rounding errors\n\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n      dec = octDecodeVec2(oct);\n      bestCos = dot(x, y, z, dec);\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n      if (currentCos > bestCos) {\n        best = oct;\n      }\n      return best;\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        if (z < 0) {\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n          x = tempx;\n          y = tempy;\n          var diff = 1 - Math.abs(x) - Math.abs(y);\n          if (diff > 0) {\n            diff += 0.001;\n            x += x > 0 ? diff / 2 : -diff / 2;\n            y += y > 0 ? diff / 2 : -diff / 2;\n          }\n        }\n        if (bytes == 1) {\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n        }\n        if (bytes == 2) {\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n        }\n      }\n      function octDecodeVec2(oct) {\n        var x = oct[0];\n        var y = oct[1];\n        if (bytes == 1) {\n          x /= x < 0 ? 127 : 128;\n          y /= y < 0 ? 127 : 128;\n        } else if (bytes == 2) {\n          x /= x < 0 ? 32767 : 32768;\n          y /= y < 0 ? 32767 : 32768;\n        }\n        var z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n          var tmpx = x;\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n        }\n        var length = Math.sqrt(x * x + y * y + z * z);\n        return [x / length, y / length, z / length];\n      }\n      function dot(x, y, z, vec3) {\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\n      }\n    },\n    quantizedEncode: function quantizedEncode(array, bytes) {\n      var quantized, segments;\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n      var decodeMat = new Matrix4();\n      var min = new Float32Array(3);\n      var max = new Float32Array(3);\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n      for (var i = 0; i < array.length; i += 3) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        min[2] = Math.min(min[2], array[i + 2]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n        max[2] = Math.max(max[2], array[i + 2]);\n      }\n      decodeMat.scale(new Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n      decodeMat.elements[12] = min[0];\n      decodeMat.elements[13] = min[1];\n      decodeMat.elements[14] = min[2];\n      decodeMat.transpose();\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n      for (var _i2 = 0; _i2 < array.length; _i2 += 3) {\n        quantized[_i2 + 0] = Math.floor((array[_i2 + 0] - min[0]) * multiplier[0]);\n        quantized[_i2 + 1] = Math.floor((array[_i2 + 1] - min[1]) * multiplier[1]);\n        quantized[_i2 + 2] = Math.floor((array[_i2 + 2] - min[2]) * multiplier[2]);\n      }\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    },\n    quantizedEncodeUV: function quantizedEncodeUV(array, bytes) {\n      var quantized, segments;\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n      var decodeMat = new Matrix3();\n      var min = new Float32Array(2);\n      var max = new Float32Array(2);\n      min[0] = min[1] = Number.MAX_VALUE;\n      max[0] = max[1] = -Number.MAX_VALUE;\n      for (var i = 0; i < array.length; i += 2) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n      }\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n      decodeMat.elements[6] = min[0];\n      decodeMat.elements[7] = min[1];\n      decodeMat.transpose();\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n      for (var _i3 = 0; _i3 < array.length; _i3 += 2) {\n        quantized[_i3 + 0] = Math.floor((array[_i3 + 0] - min[0]) * multiplier[0]);\n        quantized[_i3 + 1] = Math.floor((array[_i3 + 1] - min[1]) * multiplier[1]);\n      }\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    }\n  }\n};\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\nvar PackedPhongMaterial = /*#__PURE__*/function (_MeshPhongMaterial) {\n  _inherits(PackedPhongMaterial, _MeshPhongMaterial);\n  function PackedPhongMaterial(parameters) {\n    var _this;\n    _classCallCheck(this, PackedPhongMaterial);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PackedPhongMaterial).call(this));\n    _this.defines = {};\n    _this.type = 'PackedPhongMaterial';\n    _this.uniforms = UniformsUtils.merge([ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    _this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', ShaderChunk.common, ShaderChunk.uv_pars_vertex, ShaderChunk.uv2_pars_vertex, ShaderChunk.displacementmap_pars_vertex, ShaderChunk.envmap_pars_vertex, ShaderChunk.color_pars_vertex, ShaderChunk.fog_pars_vertex, ShaderChunk.morphtarget_pars_vertex, ShaderChunk.skinning_pars_vertex, ShaderChunk.shadowmap_pars_vertex, ShaderChunk.logdepthbuf_pars_vertex, ShaderChunk.clipping_planes_pars_vertex, \"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 0\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tfloat x = packedNormal.x * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tfloat y = packedNormal.y * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\\n\\t\\t\\t\\t\\t\\t\\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\\n\\t\\t\\t\\t\\t\\t\\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 1\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\\n\\t\\t\\t\\t\\t\\t\\tif (v.z < 0.0)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 2\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v = (packedNormal * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION == 0\\n\\t\\t\\t\\t\\t\\tuniform mat4 quantizeMatPos;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 1\\n\\t\\t\\t\\t\\t\\tuniform mat3 quantizeMatUV;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 0\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv = (packedUV * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 1\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", 'void main() {', ShaderChunk.uv_vertex, \"#ifdef USE_UV\\n\\t\\t\\t\\t\\t#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t\\tvUv = decodeUV(vUv);\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", ShaderChunk.uv2_vertex, ShaderChunk.color_vertex, ShaderChunk.beginnormal_vertex, \"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\tobjectNormal = decodeNormal(objectNormal);\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\t\\t\\tvec3 objectTangent = vec3( tangent.xyz );\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\", ShaderChunk.morphnormal_vertex, ShaderChunk.skinbase_vertex, ShaderChunk.skinnormal_vertex, ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\tvNormal = normalize( transformedNormal );', '#endif', ShaderChunk.begin_vertex, \"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION == 0\\n\\t\\t\\t\\t\\t\\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", ShaderChunk.morphtarget_vertex, ShaderChunk.skinning_vertex, ShaderChunk.displacementmap_vertex, ShaderChunk.project_vertex, ShaderChunk.logdepthbuf_vertex, ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', ShaderChunk.worldpos_vertex, ShaderChunk.envmap_vertex, ShaderChunk.shadowmap_vertex, ShaderChunk.fog_vertex, '}'].join('\\n'); // Use the original MeshPhongMaterial's fragmentShader.\n\n    _this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', ShaderChunk.common, ShaderChunk.packing, ShaderChunk.dithering_pars_fragment, ShaderChunk.color_pars_fragment, ShaderChunk.uv_pars_fragment, ShaderChunk.uv2_pars_fragment, ShaderChunk.map_pars_fragment, ShaderChunk.alphamap_pars_fragment, ShaderChunk.aomap_pars_fragment, ShaderChunk.lightmap_pars_fragment, ShaderChunk.emissivemap_pars_fragment, ShaderChunk.envmap_common_pars_fragment, ShaderChunk.envmap_pars_fragment, ShaderChunk.cube_uv_reflection_fragment, ShaderChunk.fog_pars_fragment, ShaderChunk.bsdfs, ShaderChunk.lights_pars_begin, ShaderChunk.lights_phong_pars_fragment, ShaderChunk.shadowmap_pars_fragment, ShaderChunk.bumpmap_pars_fragment, ShaderChunk.normalmap_pars_fragment, ShaderChunk.specularmap_pars_fragment, ShaderChunk.logdepthbuf_pars_fragment, ShaderChunk.clipping_planes_pars_fragment, 'void main() {', ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', ShaderChunk.logdepthbuf_fragment, ShaderChunk.map_fragment, ShaderChunk.color_fragment, ShaderChunk.alphamap_fragment, ShaderChunk.alphatest_fragment, ShaderChunk.specularmap_fragment, ShaderChunk.normal_fragment_begin, ShaderChunk.normal_fragment_maps, ShaderChunk.emissivemap_fragment,\n    // accumulation\n    ShaderChunk.lights_phong_fragment, ShaderChunk.lights_fragment_begin, ShaderChunk.lights_fragment_maps, ShaderChunk.lights_fragment_end,\n    // modulation\n    ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', ShaderChunk.tonemapping_fragment, ShaderChunk.encodings_fragment, ShaderChunk.fog_fragment, ShaderChunk.premultiplied_alpha_fragment, ShaderChunk.dithering_fragment, '}'].join('\\n');\n    _this.setValues(parameters);\n    return _this;\n  }\n  return PackedPhongMaterial;\n}(MeshPhongMaterial);\nexport { GeometryCompressionUtils, PackedPhongMaterial };","map":null,"metadata":{},"sourceType":"module"}