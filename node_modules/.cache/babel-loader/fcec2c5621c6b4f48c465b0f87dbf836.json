{"ast":null,"code":"import { Matrix3, OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from 'three';\nvar AnaglyphEffect = function AnaglyphEffect(renderer, width, height) {\n  // Dubois matrices from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.6968&rep=rep1&type=pdf#page=4\n  this.colorMatrixLeft = new Matrix3().fromArray([0.4561, -0.0400822, -0.0152161, 0.500484, -0.0378246, -0.0205971, 0.176381, -0.0157589, -0.00546856]);\n  this.colorMatrixRight = new Matrix3().fromArray([-0.0434706, 0.378476, -0.0721527, -0.0879388, 0.73364, -0.112961, -0.00155529, -0.0184503, 1.2264]);\n  var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  var _scene = new Scene();\n  var _stereo = new StereoCamera();\n  var _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n  if (width === undefined) width = 512;\n  if (height === undefined) height = 512;\n  var _renderTargetL = new WebGLRenderTarget(width, height, _params);\n  var _renderTargetR = new WebGLRenderTarget(width, height, _params);\n  var _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      },\n      colorMatrixLeft: {\n        value: this.colorMatrixLeft\n      },\n      colorMatrixRight: {\n        value: this.colorMatrixRight\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'uniform mat3 colorMatrixLeft;', 'uniform mat3 colorMatrixRight;',\n    // These functions implement sRGB linearization and gamma correction\n    'float lin( float c ) {', '\treturn c <= 0.04045 ? c * 0.0773993808 :', '\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );', '}', 'vec4 lin( vec4 c ) {', '\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );', '}', 'float dev( float c ) {', '\treturn c <= 0.0031308 ? c * 12.92', '\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;', '}', 'void main() {', '\tvec2 uv = vUv;', '\tvec4 colorL = lin( texture2D( mapLeft, uv ) );', '\tvec4 colorR = lin( texture2D( mapRight, uv ) );', '\tvec3 color = clamp(', '\t\t\tcolorMatrixLeft * colorL.rgb +', '\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );', '\tgl_FragColor = vec4(', '\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),', '\t\t\tmax( colorL.a, colorR.a ) );', '}'].join('\\n')\n  });\n  var _mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n  _scene.add(_mesh);\n  this.setSize = function (width, height) {\n    renderer.setSize(width, height);\n    var pixelRatio = renderer.getPixelRatio();\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n  this.render = function (scene, camera) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n    _stereo.update(camera);\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n  this.dispose = function () {\n    if (_renderTargetL) _renderTargetL.dispose();\n    if (_renderTargetR) _renderTargetR.dispose();\n    if (_mesh) _mesh.geometry.dispose();\n    if (_material) _material.dispose();\n  };\n};\nexport { AnaglyphEffect };","map":null,"metadata":{},"sourceType":"module"}