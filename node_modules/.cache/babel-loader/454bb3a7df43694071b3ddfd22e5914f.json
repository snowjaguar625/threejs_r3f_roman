{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, Mesh, SkinnedMesh } from 'three';\n\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/f7ec78508c6797e42f87a4390735bc2c650a1bfd/types/three/examples/jsm/exporters/STLExporter.d.ts\nvar STLExporter = /*#__PURE__*/function () {\n  function STLExporter() {\n    _classCallCheck(this, STLExporter);\n    _defineProperty(this, \"binary\", void 0);\n    _defineProperty(this, \"output\", void 0);\n    _defineProperty(this, \"offset\", void 0);\n    _defineProperty(this, \"objects\", void 0);\n    _defineProperty(this, \"triangles\", void 0);\n    _defineProperty(this, \"vA\", void 0);\n    _defineProperty(this, \"vB\", void 0);\n    _defineProperty(this, \"vC\", void 0);\n    _defineProperty(this, \"cb\", void 0);\n    _defineProperty(this, \"ab\", void 0);\n    _defineProperty(this, \"normal\", void 0);\n    this.binary = false;\n    this.output = '';\n    this.offset = 80; // skip header\n\n    this.objects = [];\n    this.triangles = 0;\n    this.vA = new Vector3();\n    this.vB = new Vector3();\n    this.vC = new Vector3();\n    this.cb = new Vector3();\n    this.ab = new Vector3();\n    this.normal = new Vector3();\n  }\n  _createClass(STLExporter, [{\n    key: \"parse\",\n    value: function parse(scene, options) {\n      var _this = this;\n      this.binary = options.binary !== undefined ? options.binary : false; //\n\n      scene.traverse(function (object) {\n        if (object instanceof Mesh && object.isMesh) {\n          var geometry = object.geometry;\n          if (!geometry.isBufferGeometry) {\n            throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n          var index = geometry.index;\n          var positionAttribute = geometry.getAttribute('position');\n          _this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n          _this.objects.push({\n            object3d: object,\n            geometry: geometry\n          });\n        }\n      });\n      if (this.binary) {\n        var bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4;\n        var arrayBuffer = new ArrayBuffer(bufferLength);\n        this.output = new DataView(arrayBuffer);\n        this.output.setUint32(this.offset, this.triangles, true);\n        this.offset += 4;\n      } else {\n        this.output = '';\n        this.output += 'solid exported\\n';\n      }\n      for (var i = 0, il = this.objects.length; i < il; i++) {\n        var object = this.objects[i].object3d;\n        var geometry = this.objects[i].geometry;\n        var index = geometry.index;\n        var positionAttribute = geometry.getAttribute('position');\n        if (object instanceof SkinnedMesh) {\n          if (index !== null) {\n            // indexed geometry\n            for (var j = 0; j < index.count; j += 3) {\n              var a = index.getX(j + 0);\n              var b = index.getX(j + 1);\n              var c = index.getX(j + 2);\n              this.writeFace(a, b, c, positionAttribute, object);\n            }\n          } else {\n            // non-indexed geometry\n            for (var _j = 0; _j < positionAttribute.count; _j += 3) {\n              var _a = _j + 0;\n              var _b = _j + 1;\n              var _c = _j + 2;\n              this.writeFace(_a, _b, _c, positionAttribute, object);\n            }\n          }\n        }\n      }\n      if (!this.binary) {\n        this.output += 'endsolid exported\\n';\n      }\n      return this.output;\n    }\n  }, {\n    key: \"writeFace\",\n    value: function writeFace(a, b, c, positionAttribute, object) {\n      this.vA.fromBufferAttribute(positionAttribute, a);\n      this.vB.fromBufferAttribute(positionAttribute, b);\n      this.vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh) {\n        object.boneTransform(a, this.vA);\n        object.boneTransform(b, this.vB);\n        object.boneTransform(c, this.vC);\n      }\n      this.vA.applyMatrix4(object.matrixWorld);\n      this.vB.applyMatrix4(object.matrixWorld);\n      this.vC.applyMatrix4(object.matrixWorld);\n      this.writeNormal(this.vA, this.vB, this.vC);\n      this.writeVertex(this.vA);\n      this.writeVertex(this.vB);\n      this.writeVertex(this.vC);\n      if (this.binary && this.output instanceof DataView) {\n        this.output.setUint16(this.offset, 0, true);\n        this.offset += 2;\n      } else {\n        this.output += '\\t\\tendloop\\n';\n        this.output += '\\tendfacet\\n';\n      }\n    }\n  }, {\n    key: \"writeNormal\",\n    value: function writeNormal(vA, vB, vC) {\n      this.cb.subVectors(vC, vB);\n      this.ab.subVectors(vA, vB);\n      this.cb.cross(this.ab).normalize();\n      this.normal.copy(this.cb).normalize();\n      if (this.binary && this.output instanceof DataView) {\n        this.output.setFloat32(this.offset, this.normal.x, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, this.normal.y, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, this.normal.z, true);\n        this.offset += 4;\n      } else {\n        this.output += \"\\tfacet normal \".concat(this.normal.x, \" \").concat(this.normal.y, \" \").concat(this.normal.z, \"\\n\");\n        this.output += '\\t\\touter loop\\n';\n      }\n    }\n  }, {\n    key: \"writeVertex\",\n    value: function writeVertex(vertex) {\n      if (this.binary && this.output instanceof DataView) {\n        this.output.setFloat32(this.offset, vertex.x, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, vertex.y, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, vertex.z, true);\n        this.offset += 4;\n      } else {\n        this.output += \"\\t\\t\\tvertex vertex.x vertex.y vertex.z\\n\";\n      }\n    }\n  }]);\n  return STLExporter;\n}();\nexport { STLExporter };","map":null,"metadata":{},"sourceType":"module"}