{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _get from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Object3D, Raycaster, Vector3, Quaternion, Euler, Matrix4, Color, MeshBasicMaterial, DoubleSide, LineBasicMaterial, CylinderGeometry, BoxGeometry, BufferGeometry, Float32BufferAttribute, Mesh, Line, OctahedronGeometry, PlaneGeometry, TorusGeometry, SphereGeometry } from 'three';\nvar TransformControls = /*#__PURE__*/function (_Object3D) {\n  _inherits(TransformControls, _Object3D);\n  // events\n  function TransformControls(camera, _domElement) {\n    var _thisSuper, _this;\n    _classCallCheck(this, TransformControls);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TransformControls).call(this));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"isTransformControls\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"visible\", false);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"domElement\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"raycaster\", new Raycaster());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"gizmo\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"plane\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"tempVector\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"tempVector2\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"tempQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"unit\", {\n      X: new Vector3(1, 0, 0),\n      Y: new Vector3(0, 1, 0),\n      Z: new Vector3(0, 0, 1)\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pointStart\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pointEnd\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"offset\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"rotationAxis\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"startNorm\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"endNorm\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"rotationAngle\", 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"cameraPosition\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"cameraQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"cameraScale\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"parentPosition\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"parentQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"parentQuaternionInv\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"parentScale\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldPositionStart\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldQuaternionStart\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldScaleStart\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldPosition\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldQuaternionInv\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"worldScale\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"eye\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"positionStart\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"quaternionStart\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"scaleStart\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"camera\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"object\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"axis\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"mode\", 'translate');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"translationSnap\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"rotationSnap\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"scaleSnap\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"space\", 'world');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"size\", 1);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"dragging\", false);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"showX\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"showY\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"showZ\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"changeEvent\", {\n      type: 'change'\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"mouseDownEvent\", {\n      type: 'mouseDown',\n      mode: _this.mode\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"mouseUpEvent\", {\n      type: 'mouseUp',\n      mode: _this.mode\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"objectChangeEvent\", {\n      type: 'objectChange'\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"intersectObjectWithRay\", function (object, raycaster, includeInvisible) {\n      var allIntersections = raycaster.intersectObject(object, true);\n      for (var i = 0; i < allIntersections.length; i++) {\n        if (allIntersections[i].object.visible || includeInvisible) {\n          return allIntersections[i];\n        }\n      }\n      return false;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"attach\", function (object) {\n      _this.object = object;\n      _this.visible = true;\n      return _assertThisInitialized(_assertThisInitialized(_this));\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"detach\", function () {\n      _this.object = undefined;\n      _this.visible = false;\n      _this.axis = null;\n      return _assertThisInitialized(_assertThisInitialized(_this));\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"reset\", function () {\n      if (!_this.enabled) return _assertThisInitialized(_assertThisInitialized(_this));\n      if (_this.dragging) {\n        if (_this.object !== undefined) {\n          _this.object.position.copy(_this.positionStart);\n          _this.object.quaternion.copy(_this.quaternionStart);\n          _this.object.scale.copy(_this.scaleStart);\n          _this.dispatchEvent(_this.changeEvent);\n          _this.dispatchEvent(_this.objectChangeEvent);\n          _this.pointStart.copy(_this.pointEnd);\n        }\n      }\n      return _assertThisInitialized(_assertThisInitialized(_this));\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updateMatrixWorld\", function () {\n      if (_this.object !== undefined) {\n        _this.object.updateMatrixWorld();\n        if (_this.object.parent === null) {\n          console.error('TransformControls: The attached 3D object must be a part of the scene graph.');\n        } else {\n          _this.object.parent.matrixWorld.decompose(_this.parentPosition, _this.parentQuaternion, _this.parentScale);\n        }\n        _this.object.matrixWorld.decompose(_this.worldPosition, _this.worldQuaternion, _this.worldScale);\n        _this.parentQuaternionInv.copy(_this.parentQuaternion).invert();\n        _this.worldQuaternionInv.copy(_this.worldQuaternion).invert();\n      }\n      _this.camera.updateMatrixWorld();\n      _this.camera.matrixWorld.decompose(_this.cameraPosition, _this.cameraQuaternion, _this.cameraScale);\n      _this.eye.copy(_this.cameraPosition).sub(_this.worldPosition).normalize();\n      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(TransformControls.prototype)), \"updateMatrixWorld\", _thisSuper).call(_thisSuper);\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pointerHover\", function (pointer) {\n      if (_this.object === undefined || _this.dragging === true) return;\n      _this.raycaster.setFromCamera(pointer, _this.camera);\n      var intersect = _this.intersectObjectWithRay(_this.gizmo.picker[_this.mode], _this.raycaster);\n      if (intersect) {\n        _this.axis = intersect.object.name;\n      } else {\n        _this.axis = null;\n      }\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pointerDown\", function (pointer) {\n      if (_this.object === undefined || _this.dragging === true || pointer.button !== 0) return;\n      if (_this.axis !== null) {\n        _this.raycaster.setFromCamera(pointer, _this.camera);\n        var planeIntersect = _this.intersectObjectWithRay(_this.plane, _this.raycaster, true);\n        if (planeIntersect) {\n          var space = _this.space;\n          if (_this.mode === 'scale') {\n            space = 'local';\n          } else if (_this.axis === 'E' || _this.axis === 'XYZE' || _this.axis === 'XYZ') {\n            space = 'world';\n          }\n          if (space === 'local' && _this.mode === 'rotate') {\n            var snap = _this.rotationSnap;\n            if (_this.axis === 'X' && snap) _this.object.rotation.x = Math.round(_this.object.rotation.x / snap) * snap;\n            if (_this.axis === 'Y' && snap) _this.object.rotation.y = Math.round(_this.object.rotation.y / snap) * snap;\n            if (_this.axis === 'Z' && snap) _this.object.rotation.z = Math.round(_this.object.rotation.z / snap) * snap;\n          }\n          _this.object.updateMatrixWorld();\n          if (_this.object.parent) {\n            _this.object.parent.updateMatrixWorld();\n          }\n          _this.positionStart.copy(_this.object.position);\n          _this.quaternionStart.copy(_this.object.quaternion);\n          _this.scaleStart.copy(_this.object.scale);\n          _this.object.matrixWorld.decompose(_this.worldPositionStart, _this.worldQuaternionStart, _this.worldScaleStart);\n          _this.pointStart.copy(planeIntersect.point).sub(_this.worldPositionStart);\n        }\n        _this.dragging = true;\n        _this.mouseDownEvent.mode = _this.mode;\n        _this.dispatchEvent(_this.mouseDownEvent);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pointerMove\", function (pointer) {\n      var axis = _this.axis;\n      var mode = _this.mode;\n      var object = _this.object;\n      var space = _this.space;\n      if (mode === 'scale') {\n        space = 'local';\n      } else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {\n        space = 'world';\n      }\n      if (object === undefined || axis === null || _this.dragging === false || pointer.button !== -1) return;\n      _this.raycaster.setFromCamera(pointer, _this.camera);\n      var planeIntersect = _this.intersectObjectWithRay(_this.plane, _this.raycaster, true);\n      if (!planeIntersect) return;\n      _this.pointEnd.copy(planeIntersect.point).sub(_this.worldPositionStart);\n      if (mode === 'translate') {\n        // Apply translate\n        _this.offset.copy(_this.pointEnd).sub(_this.pointStart);\n        if (space === 'local' && axis !== 'XYZ') {\n          _this.offset.applyQuaternion(_this.worldQuaternionInv);\n        }\n        if (axis.indexOf('X') === -1) _this.offset.x = 0;\n        if (axis.indexOf('Y') === -1) _this.offset.y = 0;\n        if (axis.indexOf('Z') === -1) _this.offset.z = 0;\n        if (space === 'local' && axis !== 'XYZ') {\n          _this.offset.applyQuaternion(_this.quaternionStart).divide(_this.parentScale);\n        } else {\n          _this.offset.applyQuaternion(_this.parentQuaternionInv).divide(_this.parentScale);\n        }\n        object.position.copy(_this.offset).add(_this.positionStart); // Apply translation snap\n\n        if (_this.translationSnap) {\n          if (space === 'local') {\n            object.position.applyQuaternion(_this.tempQuaternion.copy(_this.quaternionStart).invert());\n            if (axis.search('X') !== -1) {\n              object.position.x = Math.round(object.position.x / _this.translationSnap) * _this.translationSnap;\n            }\n            if (axis.search('Y') !== -1) {\n              object.position.y = Math.round(object.position.y / _this.translationSnap) * _this.translationSnap;\n            }\n            if (axis.search('Z') !== -1) {\n              object.position.z = Math.round(object.position.z / _this.translationSnap) * _this.translationSnap;\n            }\n            object.position.applyQuaternion(_this.quaternionStart);\n          }\n          if (space === 'world') {\n            if (object.parent) {\n              object.position.add(_this.tempVector.setFromMatrixPosition(object.parent.matrixWorld));\n            }\n            if (axis.search('X') !== -1) {\n              object.position.x = Math.round(object.position.x / _this.translationSnap) * _this.translationSnap;\n            }\n            if (axis.search('Y') !== -1) {\n              object.position.y = Math.round(object.position.y / _this.translationSnap) * _this.translationSnap;\n            }\n            if (axis.search('Z') !== -1) {\n              object.position.z = Math.round(object.position.z / _this.translationSnap) * _this.translationSnap;\n            }\n            if (object.parent) {\n              object.position.sub(_this.tempVector.setFromMatrixPosition(object.parent.matrixWorld));\n            }\n          }\n        }\n      } else if (mode === 'scale') {\n        if (axis.search('XYZ') !== -1) {\n          var d = _this.pointEnd.length() / _this.pointStart.length();\n          if (_this.pointEnd.dot(_this.pointStart) < 0) d *= -1;\n          _this.tempVector2.set(d, d, d);\n        } else {\n          _this.tempVector.copy(_this.pointStart);\n          _this.tempVector2.copy(_this.pointEnd);\n          _this.tempVector.applyQuaternion(_this.worldQuaternionInv);\n          _this.tempVector2.applyQuaternion(_this.worldQuaternionInv);\n          _this.tempVector2.divide(_this.tempVector);\n          if (axis.search('X') === -1) {\n            _this.tempVector2.x = 1;\n          }\n          if (axis.search('Y') === -1) {\n            _this.tempVector2.y = 1;\n          }\n          if (axis.search('Z') === -1) {\n            _this.tempVector2.z = 1;\n          }\n        } // Apply scale\n\n        object.scale.copy(_this.scaleStart).multiply(_this.tempVector2);\n        if (_this.scaleSnap && _this.object) {\n          if (axis.search('X') !== -1) {\n            _this.object.scale.x = Math.round(object.scale.x / _this.scaleSnap) * _this.scaleSnap || _this.scaleSnap;\n          }\n          if (axis.search('Y') !== -1) {\n            object.scale.y = Math.round(object.scale.y / _this.scaleSnap) * _this.scaleSnap || _this.scaleSnap;\n          }\n          if (axis.search('Z') !== -1) {\n            object.scale.z = Math.round(object.scale.z / _this.scaleSnap) * _this.scaleSnap || _this.scaleSnap;\n          }\n        }\n      } else if (mode === 'rotate') {\n        _this.offset.copy(_this.pointEnd).sub(_this.pointStart);\n        var ROTATION_SPEED = 20 / _this.worldPosition.distanceTo(_this.tempVector.setFromMatrixPosition(_this.camera.matrixWorld));\n        if (axis === 'E') {\n          _this.rotationAxis.copy(_this.eye);\n          _this.rotationAngle = _this.pointEnd.angleTo(_this.pointStart);\n          _this.startNorm.copy(_this.pointStart).normalize();\n          _this.endNorm.copy(_this.pointEnd).normalize();\n          _this.rotationAngle *= _this.endNorm.cross(_this.startNorm).dot(_this.eye) < 0 ? 1 : -1;\n        } else if (axis === 'XYZE') {\n          _this.rotationAxis.copy(_this.offset).cross(_this.eye).normalize();\n          _this.rotationAngle = _this.offset.dot(_this.tempVector.copy(_this.rotationAxis).cross(_this.eye)) * ROTATION_SPEED;\n        } else if (axis === 'X' || axis === 'Y' || axis === 'Z') {\n          _this.rotationAxis.copy(_this.unit[axis]);\n          _this.tempVector.copy(_this.unit[axis]);\n          if (space === 'local') {\n            _this.tempVector.applyQuaternion(_this.worldQuaternion);\n          }\n          _this.rotationAngle = _this.offset.dot(_this.tempVector.cross(_this.eye).normalize()) * ROTATION_SPEED;\n        } // Apply rotation snap\n\n        if (_this.rotationSnap) {\n          _this.rotationAngle = Math.round(_this.rotationAngle / _this.rotationSnap) * _this.rotationSnap;\n        } // Apply rotate\n\n        if (space === 'local' && axis !== 'E' && axis !== 'XYZE') {\n          object.quaternion.copy(_this.quaternionStart);\n          object.quaternion.multiply(_this.tempQuaternion.setFromAxisAngle(_this.rotationAxis, _this.rotationAngle)).normalize();\n        } else {\n          _this.rotationAxis.applyQuaternion(_this.parentQuaternionInv);\n          object.quaternion.copy(_this.tempQuaternion.setFromAxisAngle(_this.rotationAxis, _this.rotationAngle));\n          object.quaternion.multiply(_this.quaternionStart).normalize();\n        }\n      }\n      _this.dispatchEvent(_this.changeEvent);\n      _this.dispatchEvent(_this.objectChangeEvent);\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pointerUp\", function (pointer) {\n      if (pointer.button !== 0) return;\n      if (_this.dragging && _this.axis !== null) {\n        _this.mouseUpEvent.mode = _this.mode;\n        _this.dispatchEvent(_this.mouseUpEvent);\n      }\n      _this.dragging = false;\n      _this.axis = null;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getPointer\", function (event) {\n      var _this$domElement$owne;\n      if (_this.domElement && (_this$domElement$owne = _this.domElement.ownerDocument) !== null && _this$domElement$owne !== void 0 && _this$domElement$owne.pointerLockElement) {\n        return {\n          x: 0,\n          y: 0,\n          button: event.button\n        };\n      } else {\n        var _this$domElement;\n        var pointer = event.changedTouches ? event.changedTouches[0] : event;\n        var rect = (_this$domElement = _this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.getBoundingClientRect();\n        return {\n          x: (pointer.clientX - rect.left) / rect.width * 2 - 1,\n          y: -(pointer.clientY - rect.top) / rect.height * 2 + 1,\n          button: event.button\n        };\n      }\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onPointerHover\", function (event) {\n      if (!_this.enabled) return;\n      switch (event.pointerType) {\n        case 'mouse':\n        case 'pen':\n          _this.pointerHover(_this.getPointer(event));\n          break;\n      }\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onPointerDown\", function (event) {\n      if (!_this.enabled || !_this.domElement) return;\n      _this.domElement.style.touchAction = 'none'; // disable touch scroll\n\n      _this.domElement.ownerDocument.addEventListener('pointermove', _this.onPointerMove);\n      _this.pointerHover(_this.getPointer(event));\n      _this.pointerDown(_this.getPointer(event));\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onPointerMove\", function (event) {\n      if (!_this.enabled) return;\n      _this.pointerMove(_this.getPointer(event));\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onPointerUp\", function (event) {\n      if (!_this.enabled || !_this.domElement) return;\n      _this.domElement.style.touchAction = '';\n      _this.domElement.ownerDocument.removeEventListener('pointermove', _this.onPointerMove);\n      _this.pointerUp(_this.getPointer(event));\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getMode\", function () {\n      return _this.mode;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setMode\", function (mode) {\n      _this.mode = mode;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setTranslationSnap\", function (translationSnap) {\n      _this.translationSnap = translationSnap;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setRotationSnap\", function (rotationSnap) {\n      _this.rotationSnap = rotationSnap;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setScaleSnap\", function (scaleSnap) {\n      _this.scaleSnap = scaleSnap;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setSize\", function (size) {\n      _this.size = size;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setSpace\", function (space) {\n      _this.space = space;\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"update\", function () {\n      console.warn('THREE.TransformControls: update function has no more functionality and therefore has been deprecated.');\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"connect\", function (domElement) {\n      if (domElement === document) {\n        console.error('THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n      }\n      _this.domElement = domElement;\n      _this.domElement.addEventListener('pointerdown', _this.onPointerDown);\n      _this.domElement.addEventListener('pointermove', _this.onPointerHover);\n      _this.domElement.ownerDocument.addEventListener('pointerup', _this.onPointerUp);\n    });\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"dispose\", function () {\n      var _this$domElement2, _this$domElement3, _this$domElement4, _this$domElement4$own, _this$domElement5, _this$domElement5$own;\n      (_this$domElement2 = _this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener('pointerdown', _this.onPointerDown);\n      (_this$domElement3 = _this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener('pointermove', _this.onPointerHover);\n      (_this$domElement4 = _this.domElement) === null || _this$domElement4 === void 0 ? void 0 : (_this$domElement4$own = _this$domElement4.ownerDocument) === null || _this$domElement4$own === void 0 ? void 0 : _this$domElement4$own.removeEventListener('pointermove', _this.onPointerMove);\n      (_this$domElement5 = _this.domElement) === null || _this$domElement5 === void 0 ? void 0 : (_this$domElement5$own = _this$domElement5.ownerDocument) === null || _this$domElement5$own === void 0 ? void 0 : _this$domElement5$own.removeEventListener('pointerup', _this.onPointerUp);\n      _this.traverse(function (child) {\n        var mesh = child;\n        if (mesh.geometry) {\n          mesh.geometry.dispose();\n        }\n        if (mesh.material) {\n          mesh.material.dispose();\n        }\n      });\n    });\n    _this.domElement = _domElement;\n    _this.camera = camera;\n    _this.gizmo = new TransformControlsGizmo();\n    _this.add(_this.gizmo);\n    _this.plane = new TransformControlsPlane();\n    _this.add(_this.plane); // Defined getter, setter and store for a property\n\n    var defineProperty = function defineProperty(propName, defaultValue) {\n      var propValue = defaultValue;\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), propName, {\n        get: function get() {\n          return propValue !== undefined ? propValue : defaultValue;\n        },\n        set: function set(value) {\n          if (propValue !== value) {\n            propValue = value;\n            this.plane[propName] = value;\n            this.gizmo[propName] = value;\n            this.dispatchEvent({\n              type: propName + '-changed',\n              value: value\n            });\n            this.dispatchEvent(this.changeEvent);\n          }\n        }\n      }); //@ts-ignore\n\n      _this[propName] = defaultValue; // @ts-ignore\n\n      _this.plane[propName] = defaultValue; // @ts-ignore\n\n      _this.gizmo[propName] = defaultValue;\n    };\n    defineProperty('camera', _this.camera);\n    defineProperty('object', _this.object);\n    defineProperty('enabled', _this.enabled);\n    defineProperty('axis', _this.axis);\n    defineProperty('mode', _this.mode);\n    defineProperty('translationSnap', _this.translationSnap);\n    defineProperty('rotationSnap', _this.rotationSnap);\n    defineProperty('scaleSnap', _this.scaleSnap);\n    defineProperty('space', _this.space);\n    defineProperty('size', _this.size);\n    defineProperty('dragging', _this.dragging);\n    defineProperty('showX', _this.showX);\n    defineProperty('showY', _this.showY);\n    defineProperty('showZ', _this.showZ);\n    defineProperty('worldPosition', _this.worldPosition);\n    defineProperty('worldPositionStart', _this.worldPositionStart);\n    defineProperty('worldQuaternion', _this.worldQuaternion);\n    defineProperty('worldQuaternionStart', _this.worldQuaternionStart);\n    defineProperty('cameraPosition', _this.cameraPosition);\n    defineProperty('cameraQuaternion', _this.cameraQuaternion);\n    defineProperty('pointStart', _this.pointStart);\n    defineProperty('pointEnd', _this.pointEnd);\n    defineProperty('rotationAxis', _this.rotationAxis);\n    defineProperty('rotationAngle', _this.rotationAngle);\n    defineProperty('eye', _this.eye); // connect events\n\n    if (_domElement !== undefined) _this.connect(_domElement);\n    return _this;\n  }\n  return TransformControls;\n}(Object3D);\nvar TransformControlsGizmo = /*#__PURE__*/function (_Object3D2) {\n  _inherits(TransformControlsGizmo, _Object3D2);\n  // these are set from parent class TransformControls\n  function TransformControlsGizmo() {\n    var _thisSuper2, _this2;\n    _classCallCheck(this, TransformControlsGizmo);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(TransformControlsGizmo).call(this));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"isTransformControlsGizmo\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"type\", 'TransformControlsGizmo');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"tempVector\", new Vector3(0, 0, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"tempEuler\", new Euler());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"alignVector\", new Vector3(0, 1, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"zeroVector\", new Vector3(0, 0, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"lookAtMatrix\", new Matrix4());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"tempQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"tempQuaternion2\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"identityQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"unitX\", new Vector3(1, 0, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"unitY\", new Vector3(0, 1, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"unitZ\", new Vector3(0, 0, 1));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"gizmo\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"picker\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"helper\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"rotationAxis\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"cameraPosition\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"worldPositionStart\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"worldQuaternionStart\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"worldPosition\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"worldQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"eye\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"camera\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"axis\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"mode\", 'translate');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"space\", 'world');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"size\", 1);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"dragging\", false);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"showX\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"showY\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"showZ\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"updateMatrixWorld\", function () {\n      var space = _this2.space;\n      if (_this2.mode === 'scale') {\n        space = 'local'; // scale always oriented to local rotation\n      }\n\n      var quaternion = space === 'local' ? _this2.worldQuaternion : _this2.identityQuaternion; // Show only gizmos for current transform mode\n\n      _this2.gizmo['translate'].visible = _this2.mode === 'translate';\n      _this2.gizmo['rotate'].visible = _this2.mode === 'rotate';\n      _this2.gizmo['scale'].visible = _this2.mode === 'scale';\n      _this2.helper['translate'].visible = _this2.mode === 'translate';\n      _this2.helper['rotate'].visible = _this2.mode === 'rotate';\n      _this2.helper['scale'].visible = _this2.mode === 'scale';\n      var handles = [];\n      handles = handles.concat(_this2.picker[_this2.mode].children);\n      handles = handles.concat(_this2.gizmo[_this2.mode].children);\n      handles = handles.concat(_this2.helper[_this2.mode].children);\n      var _loop = function _loop(i) {\n        var handle = handles[i]; // hide aligned to camera\n\n        handle.visible = true;\n        handle.rotation.set(0, 0, 0);\n        handle.position.copy(_this2.worldPosition);\n        var factor = void 0;\n        if (_this2.camera.isOrthographicCamera) {\n          factor = (_this2.camera.top - _this2.camera.bottom) / _this2.camera.zoom;\n        } else {\n          factor = _this2.worldPosition.distanceTo(_this2.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * _this2.camera.fov / 360) / _this2.camera.zoom, 7);\n        }\n        handle.scale.set(1, 1, 1).multiplyScalar(factor * _this2.size / 7); // TODO: simplify helpers and consider decoupling from gizmo\n\n        if (handle.tag === 'helper') {\n          handle.visible = false;\n          if (handle.name === 'AXIS') {\n            handle.position.copy(_this2.worldPositionStart);\n            handle.visible = !!_this2.axis;\n            if (_this2.axis === 'X') {\n              _this2.tempQuaternion.setFromEuler(_this2.tempEuler.set(0, 0, 0));\n              handle.quaternion.copy(quaternion).multiply(_this2.tempQuaternion);\n              if (Math.abs(_this2.alignVector.copy(_this2.unitX).applyQuaternion(quaternion).dot(_this2.eye)) > 0.9) {\n                handle.visible = false;\n              }\n            }\n            if (_this2.axis === 'Y') {\n              _this2.tempQuaternion.setFromEuler(_this2.tempEuler.set(0, 0, Math.PI / 2));\n              handle.quaternion.copy(quaternion).multiply(_this2.tempQuaternion);\n              if (Math.abs(_this2.alignVector.copy(_this2.unitY).applyQuaternion(quaternion).dot(_this2.eye)) > 0.9) {\n                handle.visible = false;\n              }\n            }\n            if (_this2.axis === 'Z') {\n              _this2.tempQuaternion.setFromEuler(_this2.tempEuler.set(0, Math.PI / 2, 0));\n              handle.quaternion.copy(quaternion).multiply(_this2.tempQuaternion);\n              if (Math.abs(_this2.alignVector.copy(_this2.unitZ).applyQuaternion(quaternion).dot(_this2.eye)) > 0.9) {\n                handle.visible = false;\n              }\n            }\n            if (_this2.axis === 'XYZE') {\n              _this2.tempQuaternion.setFromEuler(_this2.tempEuler.set(0, Math.PI / 2, 0));\n              _this2.alignVector.copy(_this2.rotationAxis);\n              handle.quaternion.setFromRotationMatrix(_this2.lookAtMatrix.lookAt(_this2.zeroVector, _this2.alignVector, _this2.unitY));\n              handle.quaternion.multiply(_this2.tempQuaternion);\n              handle.visible = _this2.dragging;\n            }\n            if (_this2.axis === 'E') {\n              handle.visible = false;\n            }\n          } else if (handle.name === 'START') {\n            handle.position.copy(_this2.worldPositionStart);\n            handle.visible = _this2.dragging;\n          } else if (handle.name === 'END') {\n            handle.position.copy(_this2.worldPosition);\n            handle.visible = _this2.dragging;\n          } else if (handle.name === 'DELTA') {\n            handle.position.copy(_this2.worldPositionStart);\n            handle.quaternion.copy(_this2.worldQuaternionStart);\n            _this2.tempVector.set(1e-10, 1e-10, 1e-10).add(_this2.worldPositionStart).sub(_this2.worldPosition).multiplyScalar(-1);\n            _this2.tempVector.applyQuaternion(_this2.worldQuaternionStart.clone().invert());\n            handle.scale.copy(_this2.tempVector);\n            handle.visible = _this2.dragging;\n          } else {\n            handle.quaternion.copy(quaternion);\n            if (_this2.dragging) {\n              handle.position.copy(_this2.worldPositionStart);\n            } else {\n              handle.position.copy(_this2.worldPosition);\n            }\n            if (_this2.axis) {\n              handle.visible = _this2.axis.search(handle.name) !== -1;\n            }\n          } // If updating helper, skip rest of the loop\n\n          return \"continue\";\n        } // Align handles to current local or world rotation\n\n        handle.quaternion.copy(quaternion);\n        if (_this2.mode === 'translate' || _this2.mode === 'scale') {\n          // Hide translate and scale axis facing the camera\n          var AXIS_HIDE_TRESHOLD = 0.99;\n          var PLANE_HIDE_TRESHOLD = 0.2;\n          var AXIS_FLIP_TRESHOLD = 0.0;\n          if (handle.name === 'X' || handle.name === 'XYZX') {\n            if (Math.abs(_this2.alignVector.copy(_this2.unitX).applyQuaternion(quaternion).dot(_this2.eye)) > AXIS_HIDE_TRESHOLD) {\n              handle.scale.set(1e-10, 1e-10, 1e-10);\n              handle.visible = false;\n            }\n          }\n          if (handle.name === 'Y' || handle.name === 'XYZY') {\n            if (Math.abs(_this2.alignVector.copy(_this2.unitY).applyQuaternion(quaternion).dot(_this2.eye)) > AXIS_HIDE_TRESHOLD) {\n              handle.scale.set(1e-10, 1e-10, 1e-10);\n              handle.visible = false;\n            }\n          }\n          if (handle.name === 'Z' || handle.name === 'XYZZ') {\n            if (Math.abs(_this2.alignVector.copy(_this2.unitZ).applyQuaternion(quaternion).dot(_this2.eye)) > AXIS_HIDE_TRESHOLD) {\n              handle.scale.set(1e-10, 1e-10, 1e-10);\n              handle.visible = false;\n            }\n          }\n          if (handle.name === 'XY') {\n            if (Math.abs(_this2.alignVector.copy(_this2.unitZ).applyQuaternion(quaternion).dot(_this2.eye)) < PLANE_HIDE_TRESHOLD) {\n              handle.scale.set(1e-10, 1e-10, 1e-10);\n              handle.visible = false;\n            }\n          }\n          if (handle.name === 'YZ') {\n            if (Math.abs(_this2.alignVector.copy(_this2.unitX).applyQuaternion(quaternion).dot(_this2.eye)) < PLANE_HIDE_TRESHOLD) {\n              handle.scale.set(1e-10, 1e-10, 1e-10);\n              handle.visible = false;\n            }\n          }\n          if (handle.name === 'XZ') {\n            if (Math.abs(_this2.alignVector.copy(_this2.unitY).applyQuaternion(quaternion).dot(_this2.eye)) < PLANE_HIDE_TRESHOLD) {\n              handle.scale.set(1e-10, 1e-10, 1e-10);\n              handle.visible = false;\n            }\n          } // Flip translate and scale axis ocluded behind another axis\n\n          if (handle.name.search('X') !== -1) {\n            if (_this2.alignVector.copy(_this2.unitX).applyQuaternion(quaternion).dot(_this2.eye) < AXIS_FLIP_TRESHOLD) {\n              if (handle.tag === 'fwd') {\n                handle.visible = false;\n              } else {\n                handle.scale.x *= -1;\n              }\n            } else if (handle.tag === 'bwd') {\n              handle.visible = false;\n            }\n          }\n          if (handle.name.search('Y') !== -1) {\n            if (_this2.alignVector.copy(_this2.unitY).applyQuaternion(quaternion).dot(_this2.eye) < AXIS_FLIP_TRESHOLD) {\n              if (handle.tag === 'fwd') {\n                handle.visible = false;\n              } else {\n                handle.scale.y *= -1;\n              }\n            } else if (handle.tag === 'bwd') {\n              handle.visible = false;\n            }\n          }\n          if (handle.name.search('Z') !== -1) {\n            if (_this2.alignVector.copy(_this2.unitZ).applyQuaternion(quaternion).dot(_this2.eye) < AXIS_FLIP_TRESHOLD) {\n              if (handle.tag === 'fwd') {\n                handle.visible = false;\n              } else {\n                handle.scale.z *= -1;\n              }\n            } else if (handle.tag === 'bwd') {\n              handle.visible = false;\n            }\n          }\n        } else if (_this2.mode === 'rotate') {\n          // Align handles to current local or world rotation\n          _this2.tempQuaternion2.copy(quaternion);\n          _this2.alignVector.copy(_this2.eye).applyQuaternion(_this2.tempQuaternion.copy(quaternion).invert());\n          if (handle.name.search('E') !== -1) {\n            handle.quaternion.setFromRotationMatrix(_this2.lookAtMatrix.lookAt(_this2.eye, _this2.zeroVector, _this2.unitY));\n          }\n          if (handle.name === 'X') {\n            _this2.tempQuaternion.setFromAxisAngle(_this2.unitX, Math.atan2(-_this2.alignVector.y, _this2.alignVector.z));\n            _this2.tempQuaternion.multiplyQuaternions(_this2.tempQuaternion2, _this2.tempQuaternion);\n            handle.quaternion.copy(_this2.tempQuaternion);\n          }\n          if (handle.name === 'Y') {\n            _this2.tempQuaternion.setFromAxisAngle(_this2.unitY, Math.atan2(_this2.alignVector.x, _this2.alignVector.z));\n            _this2.tempQuaternion.multiplyQuaternions(_this2.tempQuaternion2, _this2.tempQuaternion);\n            handle.quaternion.copy(_this2.tempQuaternion);\n          }\n          if (handle.name === 'Z') {\n            _this2.tempQuaternion.setFromAxisAngle(_this2.unitZ, Math.atan2(_this2.alignVector.y, _this2.alignVector.x));\n            _this2.tempQuaternion.multiplyQuaternions(_this2.tempQuaternion2, _this2.tempQuaternion);\n            handle.quaternion.copy(_this2.tempQuaternion);\n          }\n        } // Hide disabled axes\n\n        handle.visible = handle.visible && (handle.name.indexOf('X') === -1 || _this2.showX);\n        handle.visible = handle.visible && (handle.name.indexOf('Y') === -1 || _this2.showY);\n        handle.visible = handle.visible && (handle.name.indexOf('Z') === -1 || _this2.showZ);\n        handle.visible = handle.visible && (handle.name.indexOf('E') === -1 || _this2.showX && _this2.showY && _this2.showZ); // highlight selected axis\n        //@ts-ignore\n\n        handle.material.tempOpacity = handle.material.tempOpacity || handle.material.opacity; //@ts-ignore\n\n        handle.material.tempColor = handle.material.tempColor || handle.material.color.clone(); //@ts-ignore\n\n        handle.material.color.copy(handle.material.tempColor); //@ts-ignore\n\n        handle.material.opacity = handle.material.tempOpacity;\n        if (!_this2.enabled) {\n          //@ts-ignore\n          handle.material.opacity *= 0.5; //@ts-ignore\n\n          handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n        } else if (_this2.axis) {\n          if (handle.name === _this2.axis) {\n            //@ts-ignore\n            handle.material.opacity = 1.0; //@ts-ignore\n\n            handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n          } else if (_this2.axis.split('').some(function (a) {\n            return handle.name === a;\n          })) {\n            //@ts-ignore\n            handle.material.opacity = 1.0; //@ts-ignore\n\n            handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n          } else {\n            //@ts-ignore\n            handle.material.opacity *= 0.25; //@ts-ignore\n\n            handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n          }\n        }\n      };\n      for (var i = 0; i < handles.length; i++) {\n        var _ret = _loop(i);\n        if (_ret === \"continue\") continue;\n      }\n      _get((_thisSuper2 = _assertThisInitialized(_this2), _getPrototypeOf(TransformControlsGizmo.prototype)), \"updateMatrixWorld\", _thisSuper2).call(_thisSuper2);\n    });\n    var gizmoMaterial = new MeshBasicMaterial({\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n      side: DoubleSide,\n      fog: false,\n      toneMapped: false\n    });\n    var gizmoLineMaterial = new LineBasicMaterial({\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n      linewidth: 1,\n      fog: false,\n      toneMapped: false\n    }); // Make unique material for each axis/color\n\n    var matInvisible = gizmoMaterial.clone();\n    matInvisible.opacity = 0.15;\n    var matHelper = gizmoMaterial.clone();\n    matHelper.opacity = 0.33;\n    var matRed = gizmoMaterial.clone();\n    matRed.color.set(0xff0000);\n    var matGreen = gizmoMaterial.clone();\n    matGreen.color.set(0x00ff00);\n    var matBlue = gizmoMaterial.clone();\n    matBlue.color.set(0x0000ff);\n    var matWhiteTransparent = gizmoMaterial.clone();\n    matWhiteTransparent.opacity = 0.25;\n    var matYellowTransparent = matWhiteTransparent.clone();\n    matYellowTransparent.color.set(0xffff00);\n    var matCyanTransparent = matWhiteTransparent.clone();\n    matCyanTransparent.color.set(0x00ffff);\n    var matMagentaTransparent = matWhiteTransparent.clone();\n    matMagentaTransparent.color.set(0xff00ff);\n    var matYellow = gizmoMaterial.clone();\n    matYellow.color.set(0xffff00);\n    var matLineRed = gizmoLineMaterial.clone();\n    matLineRed.color.set(0xff0000);\n    var matLineGreen = gizmoLineMaterial.clone();\n    matLineGreen.color.set(0x00ff00);\n    var matLineBlue = gizmoLineMaterial.clone();\n    matLineBlue.color.set(0x0000ff);\n    var matLineCyan = gizmoLineMaterial.clone();\n    matLineCyan.color.set(0x00ffff);\n    var matLineMagenta = gizmoLineMaterial.clone();\n    matLineMagenta.color.set(0xff00ff);\n    var matLineYellow = gizmoLineMaterial.clone();\n    matLineYellow.color.set(0xffff00);\n    var matLineGray = gizmoLineMaterial.clone();\n    matLineGray.color.set(0x787878);\n    var matLineYellowTransparent = matLineYellow.clone();\n    matLineYellowTransparent.opacity = 0.25; // reusable geometry\n\n    var arrowGeometry = new CylinderGeometry(0, 0.05, 0.2, 12, 1, false);\n    var scaleHandleGeometry = new BoxGeometry(0.125, 0.125, 0.125);\n    var lineGeometry = new BufferGeometry();\n    lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));\n    var CircleGeometry = function CircleGeometry(radius, arc) {\n      var geometry = new BufferGeometry();\n      var vertices = [];\n      for (var i = 0; i <= 64 * arc; ++i) {\n        vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);\n      }\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n      return geometry;\n    }; // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\n\n    var TranslateHelperGeometry = function TranslateHelperGeometry() {\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));\n      return geometry;\n    }; // Gizmo definitions - custom hierarchy definitions for setupGizmo() function\n\n    var gizmoTranslate = {\n      X: [[new Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, -Math.PI / 2], null, 'fwd'], [new Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, Math.PI / 2], null, 'bwd'], [new Line(lineGeometry, matLineRed)]],\n      Y: [[new Mesh(arrowGeometry, matGreen), [0, 1, 0], null, null, 'fwd'], [new Mesh(arrowGeometry, matGreen), [0, 1, 0], [Math.PI, 0, 0], null, 'bwd'], [new Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2]]],\n      Z: [[new Mesh(arrowGeometry, matBlue), [0, 0, 1], [Math.PI / 2, 0, 0], null, 'fwd'], [new Mesh(arrowGeometry, matBlue), [0, 0, 1], [-Math.PI / 2, 0, 0], null, 'bwd'], [new Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0]]],\n      XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0], [0, 0, 0]]],\n      XY: [[new Mesh(new PlaneGeometry(0.295, 0.295), matYellowTransparent.clone()), [0.15, 0.15, 0]], [new Line(lineGeometry, matLineYellow), [0.18, 0.3, 0], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineYellow), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],\n      YZ: [[new Mesh(new PlaneGeometry(0.295, 0.295), matCyanTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new Line(lineGeometry, matLineCyan), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line(lineGeometry, matLineCyan), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],\n      XZ: [[new Mesh(new PlaneGeometry(0.295, 0.295), matMagentaTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new Line(lineGeometry, matLineMagenta), [0.18, 0, 0.3], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineMagenta), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]]\n    };\n    var pickerTranslate = {\n      X: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0.6, 0]]],\n      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n      XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]],\n      XY: [[new Mesh(new PlaneGeometry(0.4, 0.4), matInvisible), [0.2, 0.2, 0]]],\n      YZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), matInvisible), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],\n      XZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), matInvisible), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]\n    };\n    var helperTranslate = {\n      START: [[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, 'helper']],\n      END: [[new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, 'helper']],\n      DELTA: [[new Line(TranslateHelperGeometry(), matHelper), null, null, null, 'helper']],\n      X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],\n      Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],\n      Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]\n    };\n    var gizmoRotate = {\n      X: [[new Line(CircleGeometry(1, 0.5), matLineRed)], [new Mesh(new OctahedronGeometry(0.04, 0), matRed), [0, 0, 0.99], null, [1, 3, 1]]],\n      Y: [[new Line(CircleGeometry(1, 0.5), matLineGreen), null, [0, 0, -Math.PI / 2]], [new Mesh(new OctahedronGeometry(0.04, 0), matGreen), [0, 0, 0.99], null, [3, 1, 1]]],\n      Z: [[new Line(CircleGeometry(1, 0.5), matLineBlue), null, [0, Math.PI / 2, 0]], [new Mesh(new OctahedronGeometry(0.04, 0), matBlue), [0.99, 0, 0], null, [1, 3, 1]]],\n      E: [[new Line(CircleGeometry(1.25, 1), matLineYellowTransparent), null, [0, Math.PI / 2, 0]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [1.17, 0, 0], [0, 0, -Math.PI / 2], [1, 1, 0.001]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [-1.17, 0, 0], [0, 0, Math.PI / 2], [1, 1, 0.001]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, -1.17, 0], [Math.PI, 0, 0], [1, 1, 0.001]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, 1.17, 0], [0, 0, 0], [1, 1, 0.001]]],\n      XYZE: [[new Line(CircleGeometry(1, 1), matLineGray), null, [0, Math.PI / 2, 0]]]\n    };\n    var helperRotate = {\n      AXIS: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']]\n    };\n    var pickerRotate = {\n      X: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],\n      Y: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]],\n      Z: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]],\n      E: [[new Mesh(new TorusGeometry(1.25, 0.1, 2, 24), matInvisible)]],\n      XYZE: [[new Mesh(new SphereGeometry(0.7, 10, 8), matInvisible)]]\n    };\n    var gizmoScale = {\n      X: [[new Mesh(scaleHandleGeometry, matRed), [0.8, 0, 0], [0, 0, -Math.PI / 2]], [new Line(lineGeometry, matLineRed), null, null, [0.8, 1, 1]]],\n      Y: [[new Mesh(scaleHandleGeometry, matGreen), [0, 0.8, 0]], [new Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]],\n      Z: [[new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.8], [Math.PI / 2, 0, 0]], [new Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]],\n      XY: [[new Mesh(scaleHandleGeometry, matYellowTransparent), [0.85, 0.85, 0], null, [2, 2, 0.2]], [new Line(lineGeometry, matLineYellow), [0.855, 0.98, 0], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineYellow), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],\n      YZ: [[new Mesh(scaleHandleGeometry, matCyanTransparent), [0, 0.85, 0.85], null, [0.2, 2, 2]], [new Line(lineGeometry, matLineCyan), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line(lineGeometry, matLineCyan), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],\n      XZ: [[new Mesh(scaleHandleGeometry, matMagentaTransparent), [0.85, 0, 0.85], null, [2, 0.2, 2]], [new Line(lineGeometry, matLineMagenta), [0.855, 0, 0.98], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineMagenta), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],\n      XYZX: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [1.1, 0, 0]]],\n      XYZY: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 1.1, 0]]],\n      XYZZ: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 0, 1.1]]]\n    };\n    var pickerScale = {\n      X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],\n      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0.5, 0]]],\n      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],\n      XY: [[new Mesh(scaleHandleGeometry, matInvisible), [0.85, 0.85, 0], null, [3, 3, 0.2]]],\n      YZ: [[new Mesh(scaleHandleGeometry, matInvisible), [0, 0.85, 0.85], null, [0.2, 3, 3]]],\n      XZ: [[new Mesh(scaleHandleGeometry, matInvisible), [0.85, 0, 0.85], null, [3, 0.2, 3]]],\n      XYZX: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [1.1, 0, 0]]],\n      XYZY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 1.1, 0]]],\n      XYZZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 1.1]]]\n    };\n    var helperScale = {\n      X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],\n      Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],\n      Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]\n    }; // Creates an Object3D with gizmos described in custom hierarchy definition.\n    // this is nearly impossible to Type so i'm leaving it\n\n    var setupGizmo = function setupGizmo(gizmoMap) {\n      var gizmo = new Object3D();\n      for (var name in gizmoMap) {\n        for (var i = gizmoMap[name].length; i--;) {\n          var object = gizmoMap[name][i][0].clone();\n          var position = gizmoMap[name][i][1];\n          var rotation = gizmoMap[name][i][2];\n          var scale = gizmoMap[name][i][3];\n          var tag = gizmoMap[name][i][4]; // name and tag properties are essential for picking and updating logic.\n\n          object.name = name; // @ts-ignore\n\n          object.tag = tag;\n          if (position) {\n            object.position.set(position[0], position[1], position[2]);\n          }\n          if (rotation) {\n            object.rotation.set(rotation[0], rotation[1], rotation[2]);\n          }\n          if (scale) {\n            object.scale.set(scale[0], scale[1], scale[2]);\n          }\n          object.updateMatrix();\n          var tempGeometry = object.geometry.clone();\n          tempGeometry.applyMatrix4(object.matrix);\n          object.geometry = tempGeometry;\n          object.renderOrder = Infinity;\n          object.position.set(0, 0, 0);\n          object.rotation.set(0, 0, 0);\n          object.scale.set(1, 1, 1);\n          gizmo.add(object);\n        }\n      }\n      return gizmo;\n    };\n    _this2.gizmo = {};\n    _this2.picker = {};\n    _this2.helper = {};\n    _this2.add(_this2.gizmo['translate'] = setupGizmo(gizmoTranslate));\n    _this2.add(_this2.gizmo['rotate'] = setupGizmo(gizmoRotate));\n    _this2.add(_this2.gizmo['scale'] = setupGizmo(gizmoScale));\n    _this2.add(_this2.picker['translate'] = setupGizmo(pickerTranslate));\n    _this2.add(_this2.picker['rotate'] = setupGizmo(pickerRotate));\n    _this2.add(_this2.picker['scale'] = setupGizmo(pickerScale));\n    _this2.add(_this2.helper['translate'] = setupGizmo(helperTranslate));\n    _this2.add(_this2.helper['rotate'] = setupGizmo(helperRotate));\n    _this2.add(_this2.helper['scale'] = setupGizmo(helperScale)); // Pickers should be hidden always\n\n    _this2.picker['translate'].visible = false;\n    _this2.picker['rotate'].visible = false;\n    _this2.picker['scale'].visible = false;\n    return _this2;\n  } // updateMatrixWorld will update transformations and appearance of individual handles\n  return TransformControlsGizmo;\n}(Object3D);\nvar TransformControlsPlane = /*#__PURE__*/function (_Mesh) {\n  _inherits(TransformControlsPlane, _Mesh);\n  function TransformControlsPlane() {\n    var _thisSuper3, _this3;\n    _classCallCheck(this, TransformControlsPlane);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TransformControlsPlane).call(this, new PlaneGeometry(100000, 100000, 2, 2), new MeshBasicMaterial({\n      visible: false,\n      wireframe: true,\n      side: DoubleSide,\n      transparent: true,\n      opacity: 0.1,\n      toneMapped: false\n    })));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"isTransformControlsPlane\", true);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"type\", 'TransformControlsPlane');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"unitX\", new Vector3(1, 0, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"unitY\", new Vector3(0, 1, 0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"unitZ\", new Vector3(0, 0, 1));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"tempVector\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"dirVector\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"alignVector\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"tempMatrix\", new Matrix4());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"identityQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"cameraQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"worldPosition\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"worldQuaternion\", new Quaternion());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"eye\", new Vector3());\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"axis\", null);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"mode\", 'translate');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"space\", 'world');\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), \"updateMatrixWorld\", function () {\n      var space = _this3.space;\n      _this3.position.copy(_this3.worldPosition);\n      if (_this3.mode === 'scale') space = 'local'; // scale always oriented to local rotation\n\n      _this3.unitX.set(1, 0, 0).applyQuaternion(space === 'local' ? _this3.worldQuaternion : _this3.identityQuaternion);\n      _this3.unitY.set(0, 1, 0).applyQuaternion(space === 'local' ? _this3.worldQuaternion : _this3.identityQuaternion);\n      _this3.unitZ.set(0, 0, 1).applyQuaternion(space === 'local' ? _this3.worldQuaternion : _this3.identityQuaternion); // Align the plane for current transform mode, axis and space.\n\n      _this3.alignVector.copy(_this3.unitY);\n      switch (_this3.mode) {\n        case 'translate':\n        case 'scale':\n          switch (_this3.axis) {\n            case 'X':\n              _this3.alignVector.copy(_this3.eye).cross(_this3.unitX);\n              _this3.dirVector.copy(_this3.unitX).cross(_this3.alignVector);\n              break;\n            case 'Y':\n              _this3.alignVector.copy(_this3.eye).cross(_this3.unitY);\n              _this3.dirVector.copy(_this3.unitY).cross(_this3.alignVector);\n              break;\n            case 'Z':\n              _this3.alignVector.copy(_this3.eye).cross(_this3.unitZ);\n              _this3.dirVector.copy(_this3.unitZ).cross(_this3.alignVector);\n              break;\n            case 'XY':\n              _this3.dirVector.copy(_this3.unitZ);\n              break;\n            case 'YZ':\n              _this3.dirVector.copy(_this3.unitX);\n              break;\n            case 'XZ':\n              _this3.alignVector.copy(_this3.unitZ);\n              _this3.dirVector.copy(_this3.unitY);\n              break;\n            case 'XYZ':\n            case 'E':\n              _this3.dirVector.set(0, 0, 0);\n              break;\n          }\n          break;\n        case 'rotate':\n        default:\n          // special case for rotate\n          _this3.dirVector.set(0, 0, 0);\n      }\n      if (_this3.dirVector.length() === 0) {\n        // If in rotate mode, make the plane parallel to camera\n        _this3.quaternion.copy(_this3.cameraQuaternion);\n      } else {\n        _this3.tempMatrix.lookAt(_this3.tempVector.set(0, 0, 0), _this3.dirVector, _this3.alignVector);\n        _this3.quaternion.setFromRotationMatrix(_this3.tempMatrix);\n      }\n      _get((_thisSuper3 = _assertThisInitialized(_this3), _getPrototypeOf(TransformControlsPlane.prototype)), \"updateMatrixWorld\", _thisSuper3).call(_thisSuper3);\n    });\n    return _this3;\n  }\n  return TransformControlsPlane;\n}(Mesh);\nexport { TransformControls, TransformControlsGizmo, TransformControlsPlane };","map":null,"metadata":{},"sourceType":"module"}