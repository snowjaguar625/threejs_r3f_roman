{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Vector3, BoxGeometry } from 'three';\nvar tempNormal = new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  var totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\n\n  var centerLength = Math.max(sideLength - 2 * radius, 0);\n  var halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\n\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\n\n  var arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\n\n  var arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    var lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\nvar RoundedBoxGeometry = /*#__PURE__*/function (_BoxGeometry) {\n  _inherits(RoundedBoxGeometry, _BoxGeometry);\n  function RoundedBoxGeometry() {\n    var _this;\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\n    _classCallCheck(this, RoundedBoxGeometry);\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\n\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RoundedBoxGeometry).call(this, 1, 1, 1, segments, segments, segments)); // if we just have one segment we're the same as a regular box\n\n    if (segments === 1) return _possibleConstructorReturn(_this);\n    var geometry2 = _this.toNonIndexed();\n    _this.index = null;\n    _this.attributes.position = geometry2.attributes.position;\n    _this.attributes.normal = geometry2.attributes.normal;\n    _this.attributes.uv = geometry2.attributes.uv; //\n\n    var position = new Vector3();\n    var normal = new Vector3();\n    var box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    var positions = _this.attributes.position.array;\n    var normals = _this.attributes.normal.array;\n    var uvs = _this.attributes.uv.array;\n    var faceTris = positions.length / 6;\n    var faceDirVector = new Vector3();\n    var halfSegmentSize = 0.5 / segments;\n    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      var side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n        case 1:\n          // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n        case 2:\n          // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n        case 3:\n          // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n        case 4:\n          // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n        case 5:\n          // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n    return _this;\n  }\n  return RoundedBoxGeometry;\n}(BoxGeometry);\nexport { RoundedBoxGeometry };","map":null,"metadata":{},"sourceType":"module"}