{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from 'three';\nvar PCDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PCDLoader, _Loader);\n  function PCDLoader(manager) {\n    var _this;\n    _classCallCheck(this, PCDLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PCDLoader).call(this, manager));\n    _this.littleEndian = true;\n    return _this;\n  }\n  _createClass(PCDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data, url));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, url) {\n      // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n      function decompressLZF(inData, outLength) {\n        var inLength = inData.length;\n        var outData = new Uint8Array(outLength);\n        var inPtr = 0;\n        var outPtr = 0;\n        var ctrl;\n        var len;\n        var ref;\n        do {\n          ctrl = inData[inPtr++];\n          if (ctrl < 1 << 5) {\n            ctrl++;\n            if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n            if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n            do {\n              outData[outPtr++] = inData[inPtr++];\n            } while (--ctrl);\n          } else {\n            len = ctrl >> 5;\n            ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n            if (len === 7) {\n              len += inData[inPtr++];\n              if (inPtr >= inLength) throw new Error('Invalid compressed data');\n            }\n            ref -= inData[inPtr++];\n            if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n            if (ref < 0) throw new Error('Invalid compressed data');\n            if (ref >= outPtr) throw new Error('Invalid compressed data');\n            do {\n              outData[outPtr++] = outData[ref++];\n            } while (--len + 2);\n          }\n        } while (inPtr < inLength);\n        return outData;\n      }\n      function parseHeader(data) {\n        var PCDheader = {};\n        var result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n        var result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n        PCDheader.data = result2[1];\n        PCDheader.headerLen = result2[0].length + result1;\n        PCDheader.str = data.substr(0, PCDheader.headerLen); // remove comments\n\n        PCDheader.str = PCDheader.str.replace(/\\#.*/gi, ''); // parse\n\n        PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n        PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n        PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n        PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n        PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n        PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n        PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n        PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n        PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str); // evaluate\n\n        if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n        if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n        if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n        if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n        if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n        if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n        if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n        if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n        if (PCDheader.size !== null) {\n          PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n            return parseInt(x, 10);\n          });\n        }\n        if (PCDheader.count !== null) {\n          PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n            return parseInt(x, 10);\n          });\n        } else {\n          PCDheader.count = [];\n          for (var i = 0, l = PCDheader.fields.length; i < l; i++) {\n            PCDheader.count.push(1);\n          }\n        }\n        PCDheader.offset = {};\n        var sizeSum = 0;\n        for (var _i = 0, _l = PCDheader.fields.length; _i < _l; _i++) {\n          if (PCDheader.data === 'ascii') {\n            PCDheader.offset[PCDheader.fields[_i]] = _i;\n          } else {\n            PCDheader.offset[PCDheader.fields[_i]] = sizeSum;\n            sizeSum += PCDheader.size[_i] * PCDheader.count[_i];\n          }\n        } // for binary only\n\n        PCDheader.rowSize = sizeSum;\n        return PCDheader;\n      }\n      var textData = LoaderUtils.decodeText(new Uint8Array(data)); // parse header (always ascii format)\n\n      var PCDheader = parseHeader(textData); // parse data\n\n      var position = [];\n      var normal = [];\n      var color = []; // ascii\n\n      if (PCDheader.data === 'ascii') {\n        var offset = PCDheader.offset;\n        var pcdData = textData.substr(PCDheader.headerLen);\n        var lines = pcdData.split('\\n');\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (lines[i] === '') continue;\n          var line = lines[i].split(' ');\n          if (offset.x !== undefined) {\n            position.push(parseFloat(line[offset.x]));\n            position.push(parseFloat(line[offset.y]));\n            position.push(parseFloat(line[offset.z]));\n          }\n          if (offset.rgb !== undefined) {\n            var rgb = parseFloat(line[offset.rgb]);\n            var r = rgb >> 16 & 0x0000ff;\n            var g = rgb >> 8 & 0x0000ff;\n            var b = rgb >> 0 & 0x0000ff;\n            color.push(r / 255, g / 255, b / 255);\n          }\n          if (offset.normal_x !== undefined) {\n            normal.push(parseFloat(line[offset.normal_x]));\n            normal.push(parseFloat(line[offset.normal_y]));\n            normal.push(parseFloat(line[offset.normal_z]));\n          }\n        }\n      } // binary-compressed\n      // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n      // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n      // that requires a totally different parsing approach compared to non-compressed data\n\n      if (PCDheader.data === 'binary_compressed') {\n        var sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n        var compressedSize = sizes[0];\n        var decompressedSize = sizes[1];\n        var decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n        var dataview = new DataView(decompressed.buffer);\n        var _offset = PCDheader.offset;\n        for (var _i2 = 0; _i2 < PCDheader.points; _i2++) {\n          if (_offset.x !== undefined) {\n            position.push(dataview.getFloat32(PCDheader.points * _offset.x + PCDheader.size[0] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.y + PCDheader.size[1] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.z + PCDheader.size[2] * _i2, this.littleEndian));\n          }\n          if (_offset.rgb !== undefined) {\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 2) / 255.0);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 1) / 255.0);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 0) / 255.0);\n          }\n          if (_offset.normal_x !== undefined) {\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_x + PCDheader.size[4] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_y + PCDheader.size[5] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_z + PCDheader.size[6] * _i2, this.littleEndian));\n          }\n        }\n      } // binary\n\n      if (PCDheader.data === 'binary') {\n        var _dataview = new DataView(data, PCDheader.headerLen);\n        var _offset2 = PCDheader.offset;\n        for (var _i3 = 0, row = 0; _i3 < PCDheader.points; _i3++, row += PCDheader.rowSize) {\n          if (_offset2.x !== undefined) {\n            position.push(_dataview.getFloat32(row + _offset2.x, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.y, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.z, this.littleEndian));\n          }\n          if (_offset2.rgb !== undefined) {\n            color.push(_dataview.getUint8(row + _offset2.rgb + 2) / 255.0);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 1) / 255.0);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 0) / 255.0);\n          }\n          if (_offset2.normal_x !== undefined) {\n            normal.push(_dataview.getFloat32(row + _offset2.normal_x, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_y, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_z, this.littleEndian));\n          }\n        }\n      } // build geometry\n\n      var geometry = new BufferGeometry();\n      if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n      if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n      geometry.computeBoundingSphere(); // build material\n\n      var material = new PointsMaterial({\n        size: 0.005\n      });\n      if (color.length > 0) {\n        material.vertexColors = true;\n      } else {\n        material.color.setHex(Math.random() * 0xffffff);\n      } // build point cloud\n\n      var mesh = new Points(geometry, material);\n      var name = url.split('').reverse().join('');\n      name = /([^\\/]*)/.exec(name);\n      name = name[1].split('').reverse().join('');\n      mesh.name = name;\n      return mesh;\n    }\n  }]);\n  return PCDLoader;\n}(Loader);\nexport { PCDLoader };","map":null,"metadata":{},"sourceType":"module"}