{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n    /**\n     * Static utility functions\n     */\n  }]);\n  return GLTFExporter;\n}(); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 0.001; // 1ms\n\n    var valueSize = track.getValueSize(); // @ts-expect-error\n\n    var times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\n     */\n    // @ts-expect-error\n\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i = 0; _i < track.times.length; _i++) {\n        if (Math.abs(track.times[_i] - time) < tolerance) return _i;\n        if (track.times[_i] < time && track.times[_i + 1] > time) {\n          times.set(track.times.slice(0, _i + 1), 0);\n          times[_i + 1] = time;\n          times.set(track.times.slice(_i + 1), _i + 2);\n          values.set(track.values.slice(0, (_i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i + 1) * valueSize);\n          values.set(track.values.slice((_i + 1) * valueSize), (_i + 2) * valueSize);\n          index = _i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (\n      // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete &&\n      // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n      var mergedTrack = void 0; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n});\nvar WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 0x46546c67;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nvar GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\n * Writer\n */\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n    _defineProperty(this, \"plugins\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"pending\", void 0);\n    _defineProperty(this, \"buffers\", void 0);\n    _defineProperty(this, \"byteOffset\", void 0);\n    _defineProperty(this, \"nodeMap\", void 0);\n    _defineProperty(this, \"skins\", void 0);\n    _defineProperty(this, \"extensionsUsed\", void 0);\n    _defineProperty(this, \"uids\", void 0);\n    _defineProperty(this, \"uid\", void 0);\n    _defineProperty(this, \"json\", void 0);\n    _defineProperty(this, \"cache\", void 0);\n    _defineProperty(this, \"cachedCanvas\", void 0);\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"write\",\n    value: function write(input, onDone, options) {\n      var _this = this;\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n      if (this.options.animations !== undefined && this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n      this.processInput(input);\n      var writer = this;\n      Promise.all(this.pending).then(function () {\n        var buffers = writer.buffers;\n        var json = writer.json;\n        var options = writer.options;\n        var extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        var blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        var extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n        if (options.binary) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n          reader.onloadend = function () {\n            if (reader.result !== null && typeof reader.result !== 'string') {\n              // Binary chunk.\n              var binaryChunk = _this.getPaddedArrayBuffer(reader.result);\n              var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n              binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n              binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n              var jsonChunk = _this.getPaddedArrayBuffer(_this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n              var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n              jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n              jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n              var header = new ArrayBuffer(GLB_HEADER_BYTES);\n              var headerView = new DataView(header);\n              headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n              headerView.setUint32(4, GLB_VERSION, true);\n              var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n              headerView.setUint32(8, totalByteLength, true);\n              var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                type: 'application/octet-stream'\n              });\n              var glbReader = new window.FileReader();\n              glbReader.readAsArrayBuffer(glbBlob);\n              glbReader.onloadend = function () {\n                if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                  onDone(glbReader.result);\n                }\n              };\n            }\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var _reader = new window.FileReader();\n            _reader.readAsDataURL(blob);\n            _reader.onloadend = function () {\n              var base64data = _reader.result;\n              if (json.buffers !== undefined && base64data !== null) {\n                json.buffers[0].uri = base64data;\n                onDone(json);\n              }\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    }\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        if (error instanceof Error) {\n          console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n        }\n      }\n    }\n    /**\n     * Assign and return a temporal unique id for an object\n     * especially which doesn't have .uuid\n     * @param  {Object} object\n     * @return {Integer}\n     */\n  }, {\n    key: \"getUID\",\n    value: function getUID(object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    }\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n      for (var i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n      return true;\n    }\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    }\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      var componentSize;\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n      var byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n          if (value !== undefined) {\n            if (componentType === WEBGL_CONSTANTS.FLOAT) {\n              dataView.setFloat32(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n              dataView.setUint32(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n              dataView.setUint16(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n              dataView.setUint8(offset, value);\n            }\n          }\n          offset += componentSize;\n        }\n      }\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var _this2 = this;\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n        reader.onloadend = function () {\n          if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n            var buffer = _this2.getPaddedArrayBuffer(reader.result);\n            var bufferViewDef = {\n              buffer: writer.processBuffer(buffer),\n              byteOffset: writer.byteOffset,\n              byteLength: buffer.byteLength\n            };\n            writer.byteOffset += buffer.byteLength;\n            resolve(json.bufferViews.push(bufferViewDef) - 1);\n          }\n        };\n      });\n    }\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var options = this.options;\n      var json = this.json;\n      var types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      var componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        var end = start + count;\n        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n      if (count === 0) return null;\n      var minMax = this.getMinMax(attribute, start, count);\n      var bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      if (bufferViewTarget !== undefined) {\n        var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n        var accessorDef = {\n          bufferView: bufferView.id,\n          byteOffset: bufferView.byteOffset,\n          componentType: componentType,\n          count: count,\n          max: minMax.max,\n          min: minMax.min,\n          type: types[attribute.itemSize]\n        };\n        if (attribute.normalized) accessorDef.normalized = true;\n        if (!json.accessors) json.accessors = [];\n        return json.accessors.push(accessorDef) - 1;\n      }\n    }\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var writer = this;\n      var cache = writer.cache;\n      var json = writer.json;\n      var options = writer.options;\n      var pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      var cachedImages = cache.images.get(image);\n      var mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n      var key = mimeType + ':flipY/' + flipY.toString();\n      if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      var imageDef = {\n        mimeType: mimeType\n      };\n      if (options.embedImages && options.maxTextureSize !== undefined) {\n        var canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext('2d');\n        if (flipY) {\n          ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n          ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n        }\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== RGBAFormat) {\n            console.error('GLTFExporter: Only RGBA format is supported.');\n          }\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n          if (image instanceof ImageData) {\n            for (var i = 0; i < data.length; i += 4) {\n              data[i + 0] = image.data[i + 0];\n              data[i + 1] = image.data[i + 1];\n              data[i + 2] = image.data[i + 2];\n              data[i + 3] = image.data[i + 3];\n            }\n          }\n          ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n        if (options.binary) {\n          pending.push(new Promise(function (resolve) {\n            canvas.toBlob(function (blob) {\n              if (blob !== null) {\n                writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                  imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                  resolve();\n                });\n              }\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else if (image instanceof Image) {\n        imageDef.uri = image.src;\n      }\n      var index = json.images.push(imageDef) - 1;\n      if (cachedImages !== undefined) cachedImages[key] = index;\n      return index;\n    }\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial &&\n      // @ts-expect-error\n      material.isMeshBasicMaterial)) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      }\n      if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n        // pbrMetallicRoughness.baseColorFactor\n        var color = material.color.toArray().concat([material.opacity]);\n        if (!this.equalArray(color, [1, 1, 1, 1])) {\n          materialDef.pbrMetallicRoughness.baseColorFactor = color;\n        }\n      }\n      if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n      if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n          var metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n      if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n        // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n        if (maxEmissiveComponent > 1) {\n          emissive.multiplyScalar(1 / maxEmissiveComponent);\n          console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n        }\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = emissive.toArray();\n        } // emissiveTexture\n\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n      if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n        if (material.normalScale && material.normalScale.x !== 1) {\n          // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n          // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n      if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      var meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode; // Use the correct mode\n\n      if (mesh instanceof LineSegments && mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh instanceof Line && mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh instanceof Points && mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      if (!geometry.isBufferGeometry) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      var nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      var originalNormal = geometry.getAttribute('normal');\n      if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n      var modifiedAttribute = null;\n      for (var attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n        modifiedAttribute = null;\n        var array = attribute.array;\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        var accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (var _i2 = 0; _i2 < mesh.morphTargetInfluences.length; ++_i2) {\n          var target = {};\n          var warned = false;\n          for (var _attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (_attributeName !== 'position' && _attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n              continue;\n            }\n            var _attribute = geometry.morphAttributes[_attributeName][_i2];\n            var gltfAttributeName = _attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n            var baseAttribute = geometry.attributes[_attributeName];\n            if (cache.attributes.has(this.getUID(_attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute));\n              continue;\n            } // Clones attribute not to override\n\n            var relativeAttribute = _attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, _attribute.getX(j) - baseAttribute.getX(j), _attribute.getY(j) - baseAttribute.getY(j), _attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n            var _accessor = this.processAccessor(relativeAttribute, geometry);\n            if (_accessor != undefined) {\n              target[gltfAttributeName] = _accessor;\n            }\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i2]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[_i2]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n      for (var _i3 = 0, il = groups.length; _i3 < il; _i3++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        if (geometry instanceof Object3D || geometry instanceof Material) {\n          this.serializeUserData(geometry, primitive);\n        }\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n          if (groups[_i3].start !== undefined || groups[_i3].count !== undefined) {\n            // @ts-expect-error\n            cacheKey += \":\".concat(groups[_i3].start, \":\").concat(groups[_i3].count);\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i3].start, groups[_i3].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        var materialIndex = groups[_i3].materialIndex;\n        if (materialIndex !== undefined && Array.isArray(materials)) {\n          var targetMaterials = materials[materialIndex];\n          if (!Array.isArray(targetMaterials)) {\n            var material = this.processMaterial(targetMaterials);\n            if (material !== null) primitive.material = material;\n            primitives.push(primitive);\n          }\n        }\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n      if (camera instanceof OrthographicCamera && isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else if (camera instanceof PerspectiveCamera) {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        var interpolation = void 0; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n        // @ts-expect-error\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || 'clip_' + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n        var node = json.nodes[nodeMap.get(object)];\n        var skeleton = object.skeleton;\n        if (skeleton === undefined) return null;\n        var rootJoint = object.skeleton.bones[0];\n        if (rootJoint === undefined) return null;\n        var joints = [];\n        var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n        var temporaryBoneInverse = new Matrix4();\n        for (var i = 0; i < skeleton.bones.length; ++i) {\n          joints.push(nodeMap.get(skeleton.bones[i]));\n          temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n          temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n        }\n        if (json.skins === undefined) json.skins = [];\n        json.skins.push({\n          inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n          joints: joints,\n          skeleton: nodeMap.get(rootJoint)\n        });\n        var skinIndex = node.skin = json.skins.length - 1;\n        return skinIndex;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n        if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!this.equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!this.equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (!this.isIdentityMatrix(object.matrix)) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object instanceof Camera && object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        var children = [];\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n          if (child.visible || !options.onlyVisible) {\n            var _nodeIndex = this.processNode(child);\n            if (_nodeIndex !== null) children.push(_nodeIndex);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      var sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n        if (child.visible || !options.onlyVisible) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = 'AuxScene';\n      for (var i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    }\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      var objectsWithoutScene = [];\n      for (var i = 0; i < input.length; i++) {\n        var inputScene = input[i];\n        if (inputScene instanceof Scene) {\n          this.processScene(inputScene);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (var _i4 = 0; _i4 < this.skins.length; ++_i4) {\n        this.processSkin(this.skins[_i4]);\n      }\n      for (var _i5 = 0; options.animations !== undefined && _i5 < options.animations.length; ++_i5) {\n        this.processAnimation(options.animations[_i5], input[0]);\n      }\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    } //------------------------------------------------------------------------------\n    // Utility functions\n    //------------------------------------------------------------------------------\n    /**\n     * Compare two arrays\n     * @param  {Array} array1 Array 1 to compare\n     * @param  {Array} array2 Array 2 to compare\n     * @return {Boolean}        Returns true if both arrays are equal\n     */\n  }, {\n    key: \"equalArray\",\n    value: function equalArray(array1, array2) {\n      return array1.length === array2.length && array1.every(function (element, index) {\n        return element === array2[index];\n      });\n    }\n    /**\n     * Converts a string to an ArrayBuffer.\n     * @param  {string} text\n     * @return {ArrayBuffer}\n     */\n  }, {\n    key: \"stringToArrayBuffer\",\n    value: function stringToArrayBuffer(text) {\n      if (window.TextEncoder !== undefined) {\n        return new TextEncoder().encode(text).buffer;\n      }\n      var array = new Uint8Array(new ArrayBuffer(text.length));\n      for (var i = 0, il = text.length; i < il; i++) {\n        var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n        array[i] = value > 0xff ? 0x20 : value;\n      }\n      return array.buffer;\n    }\n  }, {\n    key: \"isIdentityMatrix\",\n    value: function isIdentityMatrix(matrix) {\n      return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(attribute, start, count) {\n      var output = {\n        min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n        max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n      };\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n          if (value !== undefined) {\n            output.min[a] = Math.min(output.min[a], value);\n            output.max[a] = Math.max(output.max[a], value);\n          }\n        }\n      }\n      return output;\n    }\n    /**\n     * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n     */\n  }, {\n    key: \"getPaddedBufferSize\",\n    value: function getPaddedBufferSize(bufferSize) {\n      return Math.ceil(bufferSize / 4) * 4;\n    }\n    /**\n     * Returns a buffer aligned to 4-byte boundary.\n     *\n     * @param {ArrayBuffer} arrayBuffer Buffer to pad\n     * @param {Integer} paddingByte (Optional)\n     * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n     */\n  }, {\n    key: \"getPaddedArrayBuffer\",\n    value: function getPaddedArrayBuffer(arrayBuffer) {\n      var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n      if (paddedLength !== arrayBuffer.byteLength) {\n        var array = new Uint8Array(paddedLength);\n        array.set(new Uint8Array(arrayBuffer));\n        if (paddingByte !== 0) {\n          for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n            array[i] = paddingByte;\n          }\n        }\n        return array.buffer;\n      }\n      return arrayBuffer;\n    }\n  }]);\n  return GLTFWriter;\n}();\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n      if (!(light instanceof DirectionalLight && light.isDirectionalLight) &&\n      // @ts-expect-error\n      !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light instanceof DirectionalLight && light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light instanceof PointLight &&\n      // @ts-expect-error\n      light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light instanceof SpotLight && light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n      if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      if (json.extensions !== undefined) {\n        var lights = json.extensions[this.name].lights;\n        lights.push(lightDef);\n        nodeDef.extensions = nodeDef.extensions || {};\n        nodeDef.extensions[this.name] = {\n          light: lights.length - 1\n        };\n      }\n    }\n  }]);\n  return GLTFLightExtension;\n}();\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshBasicMaterial &&\n      // @ts-expect-error\n      material.isMeshBasicMaterial)) {\n        return;\n      }\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n  return GLTFMaterialsUnlitExtension;\n}();\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\nvar GLTFMaterialsPBRSpecularGlossiness = /*#__PURE__*/function () {\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    _classCallCheck(this, GLTFMaterialsPBRSpecularGlossiness);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n  _createClass(GLTFMaterialsPBRSpecularGlossiness, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      // @ts-expect-error\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n      if (material instanceof MeshPhongMaterial) {\n        var specularFactor = [1, 1, 1];\n        material.specular.toArray(specularFactor, 0);\n        extensionDef.specularFactor = specularFactor;\n        extensionDef.glossinessFactor =\n        // @ts-expect-error\n        material.glossiness;\n      }\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n      if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n        var specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsPBRSpecularGlossiness;\n}();\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshPhysicalMaterial &&\n      // @ts-expect-error\n      material.isMeshPhysicalMaterial) || material.transmission === 0) {\n        return;\n      }\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap)\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsTransmissionExtension;\n}();\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n    _defineProperty(this, \"writer\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshPhysicalMaterial &&\n      // @ts-expect-error\n      material.isMeshPhysicalMaterial) || material.thickness === 0) {\n        return;\n      }\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thickness = material.thickness;\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap)\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor =\n      //@ts-expect-error\n      material.attenuationTint.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsVolumeExtension;\n}();\nexport { GLTFExporter };","map":null,"metadata":{},"sourceType":"module"}