{"ast":null,"code":"import _toConsumableArray from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST, BYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG } from './Constants.js';\nfunction ensureIndex(geo, options) {\n  if (!geo.index) {\n    var vertexCount = geo.attributes.position.count;\n    var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    var index;\n    if (vertexCount > 65535) {\n      index = new Uint32Array(new BufferConstructor(4 * vertexCount));\n    } else {\n      index = new Uint16Array(new BufferConstructor(2 * vertexCount));\n    }\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (var i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{\n      offset: 0,\n      count: geo.index.count / 3\n    }];\n  }\n  var ranges = [];\n  var rangeBoundaries = new Set();\n  var _iterator = _createForOfIteratorHelper(geo.groups),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      rangeBoundaries.add(group.start);\n      rangeBoundaries.add(group.start + group.count);\n    }\n\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\n    return a - b;\n  });\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\n    var start = sortedBoundaries[i],\n      end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: start / 3,\n      count: (end - start) / 3\n    });\n  }\n  return ranges;\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds(triangleBounds, offset, count, target) {\n  var centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var minx = Infinity;\n  var miny = Infinity;\n  var minz = Infinity;\n  var maxx = -Infinity;\n  var maxy = -Infinity;\n  var maxz = -Infinity;\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  var includeCentroid = centroidTarget !== null;\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    var hx = triangleBounds[i + 1];\n    var lx = cx - hx;\n    var rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    var hy = triangleBounds[i + 3];\n    var ly = cy - hy;\n    var ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    var hz = triangleBounds[i + 5];\n    var lz = cz - hz;\n    var rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition(index, triangleBounds, offset, count, split) {\n  var left = offset;\n  var right = offset + count - 1;\n  var pos = split.pos;\n  var axisOffset = split.axis * 2;\n\n  // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    }\n\n    // if a triangle center lies on the partition plane it is considered to be on the right side\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n\n      for (var i = 0; i < 3; i++) {\n        var t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        var t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        var t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\nvar BIN_COUNT = 32;\nvar binsSort = function binsSort(a, b) {\n  return a.candidate - b.candidate;\n};\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nvar leftBounds = new Float32Array(6);\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  var axis = -1;\n  var pos = 0;\n\n  // Center\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    var rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    var bestCost = TRIANGLE_INTERSECT_COST * count;\n\n    // iterate over all axes\n    var cStart = offset * 6;\n    var cEnd = (offset + count) * 6;\n    for (var a = 0; a < 3; a++) {\n      var axisLeft = centroidBoundingData[a];\n      var axisRight = centroidBoundingData[a + 3];\n      var axisLength = axisRight - axisLeft;\n      var binWidth = axisLength / BIN_COUNT;\n\n      // If we have fewer triangles than we're planning to split then just check all\n      // the triangle positions because it will be faster.\n      if (count < BIN_COUNT / 4) {\n        // initialize the bin candidates\n        var truncatedBins = _toConsumableArray(sahBins);\n        truncatedBins.length = count;\n\n        // set the candidates\n        var b = 0;\n        for (var c = cStart; c < cEnd; c += 6, b++) {\n          var bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          var bounds = bin.bounds,\n            leftCacheBounds = bin.leftCacheBounds,\n            rightCacheBounds = bin.rightCacheBounds;\n          for (var d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n        truncatedBins.sort(binsSort);\n\n        // remove redundant splits\n        var splitCount = count;\n        for (var bi = 0; bi < splitCount; bi++) {\n          var _bin = truncatedBins[bi];\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === _bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        }\n\n        // find the appropriate bin for each triangle and expand the bounds.\n        for (var _c = cStart; _c < cEnd; _c += 6) {\n          var center = triangleBounds[_c + 2 * a];\n          for (var _bi = 0; _bi < splitCount; _bi++) {\n            var _bin2 = truncatedBins[_bi];\n            if (center >= _bin2.candidate) {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.leftCacheBounds);\n              _bin2.count++;\n            }\n          }\n        }\n\n        // expand all the bounds\n        for (var _bi2 = 0; _bi2 < splitCount; _bi2++) {\n          var _bin3 = truncatedBins[_bi2];\n          var leftCount = _bin3.count;\n          var rightCount = count - _bin3.count;\n\n          // check the cost of this split\n          var _leftBounds = _bin3.leftCacheBounds;\n          var rightBounds = _bin3.rightCacheBounds;\n          var leftProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(_leftBounds) / rootSurfaceArea;\n          }\n          var rightProb = 0;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          var cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = _bin3.candidate;\n          }\n        }\n      } else {\n        // reset the bins\n        for (var i = 0; i < BIN_COUNT; i++) {\n          var _bin4 = sahBins[i];\n          _bin4.count = 0;\n          _bin4.candidate = axisLeft + binWidth + i * binWidth;\n          var _bounds = _bin4.bounds;\n          for (var _d = 0; _d < 3; _d++) {\n            _bounds[_d] = Infinity;\n            _bounds[_d + 3] = -Infinity;\n          }\n        }\n\n        // iterate over all center positions\n        for (var _c2 = cStart; _c2 < cEnd; _c2 += 6) {\n          var triCenter = triangleBounds[_c2 + 2 * a];\n          var relativeCenter = triCenter - axisLeft;\n\n          // in the partition function if the centroid lies on the split plane then it is\n          // considered to be on the right side of the split\n          var binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n          var _bin5 = sahBins[binIndex];\n          _bin5.count++;\n          expandByTriangleBounds(_c2, triangleBounds, _bin5.bounds);\n        }\n\n        // cache the unioned bounds from right to left so we don't have to regenerate them each time\n        var lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n        for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\n          var _bin6 = sahBins[_i];\n          var nextBin = sahBins[_i + 1];\n          unionBounds(_bin6.bounds, nextBin.rightCacheBounds, _bin6.rightCacheBounds);\n        }\n        var _leftCount = 0;\n        for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\n          var _bin7 = sahBins[_i2];\n          var binCount = _bin7.count;\n          var _bounds2 = _bin7.bounds;\n          var _nextBin = sahBins[_i2 + 1];\n          var _rightBounds = _nextBin.rightCacheBounds;\n\n          // dont do anything with the bounds if the new bounds have no triangles\n          if (binCount !== 0) {\n            if (_leftCount === 0) {\n              copyBounds(_bounds2, leftBounds);\n            } else {\n              unionBounds(_bounds2, leftBounds, leftBounds);\n            }\n          }\n          _leftCount += binCount;\n\n          // check the cost of this split\n          var _leftProb = 0;\n          var _rightProb = 0;\n          if (_leftCount !== 0) {\n            _leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          var _rightCount = count - _leftCount;\n          if (_rightCount !== 0) {\n            _rightProb = computeSurfaceArea(_rightBounds) / rootSurfaceArea;\n          }\n          var _cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (_leftProb * _leftCount + _rightProb * _rightCount);\n          if (_cost < bestCost) {\n            axis = a;\n            bestCost = _cost;\n            pos = _bin7.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(\"MeshBVH: Invalid build strategy value \".concat(strategy, \" used.\"));\n  }\n  return {\n    axis: axis,\n    pos: pos\n  };\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n  var avg = 0;\n  for (var i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds(geo, fullBounds) {\n  var posAttr = geo.attributes.position;\n  var index = geo.index.array;\n  var triCount = index.length / 3;\n  var triangleBounds = new Float32Array(triCount * 6);\n  var normalized = posAttr.normalized;\n\n  // used for non-normalized positions\n  var posArr = posAttr.array;\n\n  // support for an interleaved position buffer\n  var bufferOffset = posAttr.offset || 0;\n  var stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  // used for normalized positions\n  var getters = ['getX', 'getY', 'getZ'];\n  for (var tri = 0; tri < triCount; tri++) {\n    var tri3 = tri * 3;\n    var tri6 = tri * 6;\n    var ai = void 0,\n      bi = void 0,\n      ci = void 0;\n    if (normalized) {\n      ai = index[tri3 + 0];\n      bi = index[tri3 + 1];\n      ci = index[tri3 + 2];\n    } else {\n      ai = index[tri3 + 0] * stride + bufferOffset;\n      bi = index[tri3 + 1] * stride + bufferOffset;\n      ci = index[tri3 + 2] * stride + bufferOffset;\n    }\n    for (var el = 0; el < 3; el++) {\n      var a = void 0,\n        b = void 0,\n        c = void 0;\n      if (normalized) {\n        a = posAttr[getters[el]](ai);\n        b = posAttr[getters[el]](bi);\n        c = posAttr[getters[el]](ci);\n      } else {\n        a = posArr[ai + el];\n        b = posArr[bi + el];\n        c = posArr[ci + el];\n      }\n      var min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      var max = a;\n      if (b > max) max = b;\n      if (c > max) max = c;\n\n      // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n      var halfExtents = (max - min) / 2;\n      var el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el]) fullBounds[el] = min;\n      if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n    }\n  }\n  return triangleBounds;\n}\nexport function buildTree(geo, options) {\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geo);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    var splitOffset = partition(indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      var left = new MeshBVHNode();\n      var lstart = offset;\n      var lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      var right = new MeshBVHNode();\n      var rstart = splitOffset;\n      var rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n  ensureIndex(geo, options);\n\n  // Compute the full bounds of the geometry at the same time as triangle bounds because\n  // we'll need it for the root bounds in the case with no groups and it should be fast here.\n  // We can't use the geometrying bounding box if it's available because it may be out of date.\n  var fullBounds = new Float32Array(6);\n  var cacheCentroidBoundingData = new Float32Array(6);\n  var triangleBounds = computeTriangleBounds(geo, fullBounds);\n  var indexArray = geo.index.array;\n  var maxDepth = options.maxDepth;\n  var verbose = options.verbose;\n  var maxLeafTris = options.maxLeafTris;\n  var strategy = options.strategy;\n  var onProgress = options.onProgress;\n  var totalTriangles = geo.index.count / 3;\n  var reachedMaxDepth = false;\n  var roots = [];\n  var ranges = getRootIndexRanges(geo);\n  if (ranges.length === 1) {\n    var range = ranges[0];\n    var root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    var _iterator2 = _createForOfIteratorHelper(ranges),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _range = _step2.value;\n        var _root = new MeshBVHNode();\n        _root.boundingData = new Float32Array(6);\n        getBounds(triangleBounds, _range.offset, _range.count, _root.boundingData, cacheCentroidBoundingData);\n        splitNode(_root, _range.offset, _range.count, cacheCentroidBoundingData);\n        roots.push(_root);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return roots;\n}\nexport function buildPackedTree(geo, options) {\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  var roots = buildTree(geo, options);\n  var float32Array;\n  var uint32Array;\n  var uint16Array;\n  var packedRoots = [];\n  var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  for (var i = 0; i < roots.length; i++) {\n    var root = roots[i];\n    var nodeCount = countNodes(root);\n    var buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  return packedRoots;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    var stride4Offset = byteOffset / 4;\n    var stride2Offset = byteOffset / 2;\n    var isLeaf = !!node.count;\n    var boundingData = node.boundingData;\n    for (var _i3 = 0; _i3 < 6; _i3++) {\n      float32Array[stride4Offset + _i3] = boundingData[_i3];\n    }\n    if (isLeaf) {\n      var offset = node.offset;\n      var count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      var left = node.left;\n      var right = node.right;\n      var splitAxis = node.splitAxis;\n      var nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}