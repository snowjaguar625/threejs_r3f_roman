{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { strToU8, zipSync } from 'fflate';\nimport { Mesh, MeshPhysicalMaterial } from 'three';\nvar USDZExporter = /*#__PURE__*/function () {\n  function USDZExporter() {\n    _classCallCheck(this, USDZExporter);\n    _defineProperty(this, \"PRECISION\", 7);\n    _defineProperty(this, \"materials\", void 0);\n    _defineProperty(this, \"textures\", void 0);\n    _defineProperty(this, \"files\", void 0);\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  _createClass(USDZExporter, [{\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(scene) {\n        var _this = this;\n        var modelFileName, output, _loop, id, offset, filename, file, headerSize, offsetMod64, padLength, padding;\n        return _regeneratorRuntime().wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                modelFileName = 'model.usda'; // model file should be first in USDZ archive so we init it here\n                this.files[modelFileName] = null;\n                output = this.buildHeader();\n                scene.traverseVisible(function (object) {\n                  if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n                    var geometry = object.geometry;\n                    var material = object.material;\n                    var geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd';\n                    if (!(geometryFileName in _this.files)) {\n                      var meshObject = _this.buildMeshObject(geometry);\n                      _this.files[geometryFileName] = _this.buildUSDFileAsString(meshObject);\n                    }\n                    if (!(material.uuid in _this.materials)) {\n                      _this.materials[material.uuid] = material;\n                    }\n                    output += _this.buildXform(object, geometry, material);\n                  }\n                });\n                output += this.buildMaterials(this.materials);\n                this.files[modelFileName] = strToU8(output);\n                output = null;\n                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(id) {\n                  var texture, color, isRGBA, canvas, blob;\n                  return _regeneratorRuntime().wrap(function _loop$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          texture = _this.textures[id];\n                          color = id.split('_')[1];\n                          isRGBA = texture.format === 1023;\n                          canvas = _this.imageToCanvas(texture.image, color);\n                          _context.next = 6;\n                          return new Promise(function (resolve) {\n                            return canvas === null || canvas === void 0 ? void 0 : canvas.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1);\n                          });\n                        case 6:\n                          blob = _context.sent;\n                          if (!blob) {\n                            _context.next = 13;\n                            break;\n                          }\n                          _context.t0 = Uint8Array;\n                          _context.next = 11;\n                          return blob.arrayBuffer();\n                        case 11:\n                          _context.t1 = _context.sent;\n                          _this.files[\"textures/Texture_\".concat(id, \".\").concat(isRGBA ? 'png' : 'jpg')] = new _context.t0(_context.t1);\n                        case 13:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _context2.t0 = _regeneratorRuntime().keys(this.textures);\n              case 9:\n                if ((_context2.t1 = _context2.t0()).done) {\n                  _context2.next = 14;\n                  break;\n                }\n                id = _context2.t1.value;\n                return _context2.delegateYield(_loop(id), \"t2\", 12);\n              case 12:\n                _context2.next = 9;\n                break;\n              case 14:\n                // 64 byte alignment\n                // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n                offset = 0;\n                for (filename in this.files) {\n                  file = this.files[filename];\n                  headerSize = 34 + filename.length;\n                  offset += headerSize;\n                  offsetMod64 = offset & 63;\n                  if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n                    padLength = 64 - offsetMod64;\n                    padding = new Uint8Array(padLength);\n                    this.files[filename] = [file, {\n                      extra: {\n                        12345: padding\n                      }\n                    }];\n                  }\n                  if (file && typeof file.length === 'number') {\n                    offset = file.length;\n                  }\n                }\n                return _context2.abrupt(\"return\", zipSync(this.files, {\n                  level: 0\n                }));\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function parse(_x) {\n        return _parse.apply(this, arguments);\n      }\n      return parse;\n    }()\n  }, {\n    key: \"imageToCanvas\",\n    value: function imageToCanvas(image, color) {\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        var scale = 1024 / Math.max(image.width, image.height);\n        var canvas = document.createElement('canvas');\n        canvas.width = image.width * Math.min(1, scale);\n        canvas.height = image.height * Math.min(1, scale);\n        var context = canvas.getContext('2d');\n        context === null || context === void 0 ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n        if (color !== undefined) {\n          var hex = parseInt(color, 16);\n          var r = (hex >> 16 & 255) / 255;\n          var g = (hex >> 8 & 255) / 255;\n          var b = (hex & 255) / 255;\n          var imagedata = context === null || context === void 0 ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n          if (imagedata) {\n            var data = imagedata === null || imagedata === void 0 ? void 0 : imagedata.data;\n            for (var i = 0; i < data.length; i += 4) {\n              data[i + 0] = data[i + 0] * r;\n              data[i + 1] = data[i + 1] * g;\n              data[i + 2] = data[i + 2] * b;\n            }\n            context === null || context === void 0 ? void 0 : context.putImageData(imagedata, 0, 0);\n          }\n        }\n        return canvas;\n      }\n    }\n  }, {\n    key: \"buildHeader\",\n    value: function buildHeader() {\n      return \"#usda 1.0\\n(\\n    customLayerData = {\\n        string creator = \\\"Three.js USDZExporter\\\"\\n    }\\n    metersPerUnit = 1\\n    upAxis = \\\"Y\\\"\\n)\\n\";\n    }\n  }, {\n    key: \"buildUSDFileAsString\",\n    value: function buildUSDFileAsString(dataToInsert) {\n      var output = this.buildHeader();\n      output += dataToInsert;\n      return strToU8(output);\n    } // Xform\n  }, {\n    key: \"buildXform\",\n    value: function buildXform(object, geometry, material) {\n      var name = 'Object_' + object.id;\n      var transform = this.buildMatrix(object.matrixWorld);\n      if (object.matrixWorld.determinant() < 0) {\n        console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n      }\n      return \"def Xform \\\"\".concat(name, \"\\\" (\\n    prepend references = @./geometries/Geometry_\").concat(geometry.id, \".usd@</Geometry>\\n)\\n{\\n    matrix4d xformOp:transform = \").concat(transform, \"\\n    uniform token[] xformOpOrder = [\\\"xformOp:transform\\\"]\\n    rel material:binding = </Materials/Material_\").concat(material.id, \">\\n}\\n\");\n    }\n  }, {\n    key: \"buildMatrix\",\n    value: function buildMatrix(matrix) {\n      var array = matrix.elements;\n      return \"( \".concat(this.buildMatrixRow(array, 0), \", \").concat(this.buildMatrixRow(array, 4), \", \").concat(this.buildMatrixRow(array, 8), \", \").concat(this.buildMatrixRow(array, 12), \" )\");\n    }\n  }, {\n    key: \"buildMatrixRow\",\n    value: function buildMatrixRow(array, offset) {\n      return \"(\".concat(array[offset + 0], \", \").concat(array[offset + 1], \", \").concat(array[offset + 2], \", \").concat(array[offset + 3], \")\");\n    } // Mesh\n  }, {\n    key: \"buildMeshObject\",\n    value: function buildMeshObject(geometry) {\n      var mesh = this.buildMesh(geometry);\n      return \"\\ndef \\\"Geometry\\\"\\n{\\n  \".concat(mesh, \"\\n}\\n\");\n    }\n  }, {\n    key: \"buildMesh\",\n    value: function buildMesh(geometry) {\n      var name = 'Geometry';\n      var attributes = geometry.attributes;\n      var count = attributes.position.count;\n      return \"\\n    def Mesh \\\"\".concat(name, \"\\\"\\n    {\\n        int[] faceVertexCounts = [\").concat(this.buildMeshVertexCount(geometry), \"]\\n        int[] faceVertexIndices = [\").concat(this.buildMeshVertexIndices(geometry), \"]\\n        normal3f[] normals = [\").concat(this.buildVector3Array(attributes.normal, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        point3f[] points = [\").concat(this.buildVector3Array(attributes.position, count), \"]\\n        float2[] primvars:st = [\").concat(this.buildVector2Array(attributes.uv, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        uniform token subdivisionScheme = \\\"none\\\"\\n    }\\n\");\n    }\n  }, {\n    key: \"buildMeshVertexCount\",\n    value: function buildMeshVertexCount(geometry) {\n      var count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n      return Array(count / 3).fill(3).join(', ');\n    }\n  }, {\n    key: \"buildMeshVertexIndices\",\n    value: function buildMeshVertexIndices(geometry) {\n      if (geometry.index !== null) {\n        // @ts-expect-error\n        return geometry.index.array.join(', ');\n      }\n      var array = [];\n      var length = geometry.attributes.position.count;\n      for (var i = 0; i < length; i++) {\n        array.push(i);\n      }\n      return array.join(', ');\n    }\n  }, {\n    key: \"buildVector3Array\",\n    value: function buildVector3Array(attribute, count) {\n      if (attribute === undefined) {\n        console.warn('USDZExporter: Normals missing.');\n        return Array(count).fill('(0, 0, 0)').join(', ');\n      }\n      var array = [];\n      var data = attribute.array;\n      for (var i = 0; i < data.length; i += 3) {\n        array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(data[i + 1].toPrecision(this.PRECISION), \", \").concat(data[i + 2].toPrecision(this.PRECISION), \")\"));\n      }\n      return array.join(', ');\n    }\n  }, {\n    key: \"buildVector2Array\",\n    value: function buildVector2Array(attribute, count) {\n      if (attribute === undefined) {\n        console.warn('USDZExporter: UVs missing.');\n        return Array(count).fill('(0, 0)').join(', ');\n      }\n      var array = [];\n      var data = attribute.array;\n      for (var i = 0; i < data.length; i += 2) {\n        // @ts-expect-error\n        array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(1 - data[i + 1].toPrecision(this.PRECISION), \")\"));\n      }\n      return array.join(', ');\n    } // Materials\n  }, {\n    key: \"buildMaterials\",\n    value: function buildMaterials(materials) {\n      var array = [];\n      for (var uuid in materials) {\n        var material = materials[uuid];\n        array.push(this.buildMaterial(material));\n      }\n      return \"def \\\"Materials\\\"\\n{\\n\".concat(array.join(''), \"\\n}\\n\");\n    }\n  }, {\n    key: \"buildMaterial\",\n    value: function buildMaterial(material) {\n      // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n      var pad = '            ';\n      var inputs = [];\n      var samplers = [];\n      if (material.map !== null) {\n        inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.map.id, \"_diffuse.outputs:rgb>\"));\n        samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color));\n      } else {\n        inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor = \").concat(this.buildColor(material.color)));\n      }\n      if (material.emissiveMap !== null) {\n        inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.emissiveMap.id, \"_emissive.outputs:rgb>\"));\n        samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'));\n      } else if (material.emissive.getHex() > 0) {\n        inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor = \").concat(this.buildColor(material.emissive)));\n      }\n      if (material.normalMap !== null) {\n        inputs.push(\"\".concat(pad, \"normal3f inputs:normal.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.normalMap.id, \"_normal.outputs:rgb>\"));\n        samplers.push(this.buildTexture(material, material.normalMap, 'normal'));\n      }\n      if (material.aoMap !== null) {\n        inputs.push(\"\".concat(pad, \"float inputs:occlusion.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.aoMap.id, \"_occlusion.outputs:r>\"));\n        samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'));\n      }\n      if (material.roughnessMap !== null && material.roughness === 1) {\n        inputs.push(\"\".concat(pad, \"float inputs:roughness.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.roughnessMap.id, \"_roughness.outputs:g>\"));\n        samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'));\n      } else {\n        inputs.push(\"\".concat(pad, \"float inputs:roughness = \").concat(material.roughness));\n      }\n      if (material.metalnessMap !== null && material.metalness === 1) {\n        inputs.push(\"\".concat(pad, \"float inputs:metallic.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.metalnessMap.id, \"_metallic.outputs:b>\"));\n        samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'));\n      } else {\n        inputs.push(\"\".concat(pad, \"float inputs:metallic = \").concat(material.metalness));\n      }\n      inputs.push(\"\".concat(pad, \"float inputs:opacity = \").concat(material.opacity));\n      if (material instanceof MeshPhysicalMaterial) {\n        inputs.push(\"\".concat(pad, \"float inputs:clearcoat = \").concat(material.clearcoat));\n        inputs.push(\"\".concat(pad, \"float inputs:clearcoatRoughness = \").concat(material.clearcoatRoughness));\n        inputs.push(\"\".concat(pad, \"float inputs:ior = \").concat(material.ior));\n      }\n      return \"\\n    def Material \\\"Material_\".concat(material.id, \"\\\"\\n    {\\n        def Shader \\\"PreviewSurface\\\"\\n        {\\n            uniform token info:id = \\\"UsdPreviewSurface\\\"\\n\").concat(inputs.join('\\n'), \"\\n            int inputs:useSpecularWorkflow = 0\\n            token outputs:surface\\n        }\\n        token outputs:surface.connect = </Materials/Material_\").concat(material.id, \"/PreviewSurface.outputs:surface>\\n        token inputs:frame:stPrimvarName = \\\"st\\\"\\n        def Shader \\\"uvReader_st\\\"\\n        {\\n            uniform token info:id = \\\"UsdPrimvarReader_float2\\\"\\n            token inputs:varname.connect = </Materials/Material_\").concat(material.id, \".inputs:frame:stPrimvarName>\\n            float2 inputs:fallback = (0.0, 0.0)\\n            float2 outputs:result\\n        }\\n\").concat(samplers.join('\\n'), \"\\n    }\\n\");\n    }\n  }, {\n    key: \"buildTexture\",\n    value: function buildTexture(material, texture, mapType, color) {\n      var id = texture.id + (color ? '_' + color.getHexString() : '');\n      var isRGBA = texture.format === 1023;\n      this.textures[id] = texture;\n      return \"\\n      def Shader \\\"Transform2d_\".concat(mapType, \"\\\" (\\n          sdrMetadata = {\\n              string role = \\\"math\\\"\\n          }\\n      )\\n      {\\n          uniform token info:id = \\\"UsdTransform2d\\\"\\n          float2 inputs:in.connect = </Materials/Material_\").concat(material.id, \"/uvReader_st.outputs:result>\\n          float2 inputs:scale = \").concat(this.buildVector2(texture.repeat), \"\\n          float2 inputs:translation = \").concat(this.buildVector2(texture.offset), \"\\n          float2 outputs:result\\n      }\\n      def Shader \\\"Texture_\").concat(texture.id, \"_\").concat(mapType, \"\\\"\\n      {\\n          uniform token info:id = \\\"UsdUVTexture\\\"\\n          asset inputs:file = @textures/Texture_\").concat(id, \".\").concat(isRGBA ? 'png' : 'jpg', \"@\\n          float2 inputs:st.connect = </Materials/Material_\").concat(material.id, \"/Transform2d_\").concat(mapType, \".outputs:result>\\n          token inputs:wrapS = \\\"repeat\\\"\\n          token inputs:wrapT = \\\"repeat\\\"\\n          float outputs:r\\n          float outputs:g\\n          float outputs:b\\n          float3 outputs:rgb\\n      }\");\n    }\n  }, {\n    key: \"buildColor\",\n    value: function buildColor(color) {\n      return \"(\".concat(color.r, \", \").concat(color.g, \", \").concat(color.b, \")\");\n    }\n  }, {\n    key: \"buildVector2\",\n    value: function buildVector2(vector) {\n      return \"(\".concat(vector.x, \", \").concat(vector.y, \")\");\n    }\n  }]);\n  return USDZExporter;\n}();\nexport { USDZExporter };","map":null,"metadata":{},"sourceType":"module"}