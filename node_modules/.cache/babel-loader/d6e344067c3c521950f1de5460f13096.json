{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from 'three';\nvar isCubeTexture = function isCubeTexture(def) {\n  return def && def.isCubeTexture;\n};\nvar GroundProjectedEnv = /*#__PURE__*/function (_Mesh) {\n  _inherits(GroundProjectedEnv, _Mesh);\n  function GroundProjectedEnv(texture, options) {\n    _classCallCheck(this, GroundProjectedEnv);\n    var _ref, _texture$image$;\n    var isCubeMap = isCubeTexture(texture);\n    var w = (_ref = isCubeMap ? (_texture$image$ = texture.image[0]) === null || _texture$image$ === void 0 ? void 0 : _texture$image$.width : texture.image.width) != null ? _ref : 1024;\n    var cubeSize = w / 4;\n    var _lodMax = Math.floor(Math.log2(cubeSize));\n    var _cubeSize = Math.pow(2, _lodMax);\n    var width = 3 * Math.max(_cubeSize, 16 * 7);\n    var height = 4 * _cubeSize;\n    var defines = [isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '', \"#define CUBEUV_TEXEL_WIDTH \".concat(1.0 / width), \"#define CUBEUV_TEXEL_HEIGHT \".concat(1.0 / height), \"#define CUBEUV_MAX_MIP \".concat(_lodMax, \".0\")];\n    var vertexShader = /* glsl */\"\\n        varying vec3 vWorldPosition;\\n        void main() \\n        {\\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\\n            vWorldPosition = worldPosition.xyz;\\n            \\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\\n        \";\n    var fragmentShader = defines.join('\\n') + /* glsl */\"\\n        #define ENVMAP_TYPE_CUBE_UV\\n        varying vec3 vWorldPosition;\\n        uniform float radius;\\n        uniform float height;\\n        uniform float angle;\\n        #ifdef ENVMAP_TYPE_CUBE\\n            uniform samplerCube map;\\n        #else\\n            uniform sampler2D map;\\n        #endif\\n        // From: https://www.shadertoy.com/view/4tsBD7\\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \\n        {\\n            float d = dot ( rd, n );\\n            \\n            if( d > 0.0 ) { return 1e6; }\\n            \\n            vec3  o = ro - c;\\n            float t = - dot( n, o ) / d;\\n            vec3  q = o + rd * t;\\n            \\n            return ( dot( q, q ) < r * r ) ? t : 1e6;\\n        }\\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \\n        {\\n            vec3 oc = ro - ce;\\n            float b = dot( oc, rd );\\n            float c = dot( oc, oc ) - ra * ra;\\n            float h = b * b - c;\\n            \\n            if( h < 0.0 ) { return -1.0; }\\n            \\n            h = sqrt( h );\\n            \\n            return - b + h;\\n        }\\n        vec3 project() \\n        {\\n            vec3 p = normalize( vWorldPosition );\\n            vec3 camPos = cameraPosition;\\n            camPos.y -= height;\\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\\n            if( intersection > 0.0 ) {\\n                \\n                vec3 h = vec3( 0.0, - height, 0.0 );\\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\\n            } else {\\n                p = vec3( 0.0, 1.0, 0.0 );\\n            }\\n            return p;\\n        }\\n        #include <common>\\n        #include <cube_uv_reflection_fragment>\\n        void main() \\n        {\\n            vec3 projectedWorldPosition = project();\\n            \\n            #ifdef ENVMAP_TYPE_CUBE\\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\\n            #else\\n                vec3 direction = normalize( projectedWorldPosition );\\n                vec2 uv = equirectUv( direction );\\n                vec3 outcolor = texture2D( map, uv ).rgb;\\n            #endif\\n            gl_FragColor = vec4( outcolor, 1.0 );\\n            #include <tonemapping_fragment>\\n            #include <encodings_fragment>\\n        }\\n        \";\n    var uniforms = {\n      map: {\n        value: texture\n      },\n      height: {\n        value: (options === null || options === void 0 ? void 0 : options.height) || 15\n      },\n      radius: {\n        value: (options === null || options === void 0 ? void 0 : options.radius) || 100\n      }\n    };\n    var geometry = new IcosahedronGeometry(1, 16);\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      fragmentShader: fragmentShader,\n      vertexShader: vertexShader,\n      side: DoubleSide\n    });\n    return _possibleConstructorReturn(this, _getPrototypeOf(GroundProjectedEnv).call(this, geometry, material));\n  }\n  _createClass(GroundProjectedEnv, [{\n    key: \"radius\",\n    set: function set(radius) {\n      this.material.uniforms.radius.value = radius;\n    },\n    get: function get() {\n      return this.material.uniforms.radius.value;\n    }\n  }, {\n    key: \"height\",\n    set: function set(height) {\n      this.material.uniforms.height.value = height;\n    },\n    get: function get() {\n      return this.material.uniforms.height.value;\n    }\n  }]);\n  return GroundProjectedEnv;\n}(Mesh);\nexport { GroundProjectedEnv };","map":null,"metadata":{},"sourceType":"module"}