{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { DataTexture, FloatType, IntType, UnsignedIntType, ByteType, UnsignedByteType, ShortType, UnsignedShortType, RedFormat, RGFormat, RGBAFormat, RedIntegerFormat, RGIntegerFormat, RGBAIntegerFormat, NearestFilter } from 'three';\nfunction countToStringFormat(count) {\n  switch (count) {\n    case 1:\n      return 'R';\n    case 2:\n      return 'RG';\n    case 3:\n      return 'RGBA';\n    case 4:\n      return 'RGBA';\n  }\n  throw new Error();\n}\nfunction countToFormat(count) {\n  switch (count) {\n    case 1:\n      return RedFormat;\n    case 2:\n      return RGFormat;\n    case 3:\n      return RGBAFormat;\n    case 4:\n      return RGBAFormat;\n  }\n}\nfunction countToIntFormat(count) {\n  switch (count) {\n    case 1:\n      return RedIntegerFormat;\n    case 2:\n      return RGIntegerFormat;\n    case 3:\n      return RGBAIntegerFormat;\n    case 4:\n      return RGBAIntegerFormat;\n  }\n}\nexport var VertexAttributeTexture = /*#__PURE__*/function (_DataTexture) {\n  _inherits(VertexAttributeTexture, _DataTexture);\n  function VertexAttributeTexture() {\n    var _this;\n    _classCallCheck(this, VertexAttributeTexture);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexAttributeTexture).call(this));\n    _this.minFilter = NearestFilter;\n    _this.magFilter = NearestFilter;\n    _this.generateMipmaps = false;\n    _this.overrideItemSize = null;\n    _this._forcedType = null;\n    return _this;\n  }\n  _createClass(VertexAttributeTexture, [{\n    key: \"updateFrom\",\n    value: function updateFrom(attr) {\n      var overrideItemSize = this.overrideItemSize;\n      var originalItemSize = attr.itemSize;\n      var originalCount = attr.count;\n      if (overrideItemSize !== null) {\n        if (originalItemSize * originalCount % overrideItemSize !== 0.0) {\n          throw new Error('VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.');\n        }\n        attr.itemSize = overrideItemSize;\n        attr.count = originalCount * originalItemSize / overrideItemSize;\n      }\n      var itemSize = attr.itemSize;\n      var count = attr.count;\n      var normalized = attr.normalized;\n      var originalBufferCons = attr.array.constructor;\n      var byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n      var targetType = this._forcedType;\n      var finalStride = itemSize;\n\n      // derive the type of texture this should be in the shader\n      if (targetType === null) {\n        switch (originalBufferCons) {\n          case Float32Array:\n            targetType = FloatType;\n            break;\n          case Uint8Array:\n          case Uint16Array:\n          case Uint32Array:\n            targetType = UnsignedIntType;\n            break;\n          case Int8Array:\n          case Int16Array:\n          case Int32Array:\n            targetType = IntType;\n            break;\n        }\n      }\n\n      // get the target format to store the texture as\n      var type, format, normalizeValue, targetBufferCons;\n      var internalFormat = countToStringFormat(itemSize);\n      switch (targetType) {\n        case FloatType:\n          normalizeValue = 1.0;\n          format = countToFormat(itemSize);\n          if (normalized && byteCount === 1) {\n            targetBufferCons = originalBufferCons;\n            internalFormat += '8';\n            if (originalBufferCons === Uint8Array) {\n              type = UnsignedByteType;\n            } else {\n              type = ByteType;\n              internalFormat += '_SNORM';\n            }\n          } else {\n            targetBufferCons = Float32Array;\n            internalFormat += '32F';\n            type = FloatType;\n          }\n          break;\n        case IntType:\n          internalFormat += byteCount * 8 + 'I';\n          normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n          format = countToIntFormat(itemSize);\n          if (byteCount === 1) {\n            targetBufferCons = Int8Array;\n            type = ByteType;\n          } else if (byteCount === 2) {\n            targetBufferCons = Int16Array;\n            type = ShortType;\n          } else {\n            targetBufferCons = Int32Array;\n            type = IntType;\n          }\n          break;\n        case UnsignedIntType:\n          internalFormat += byteCount * 8 + 'UI';\n          normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n          format = countToIntFormat(itemSize);\n          if (byteCount === 1) {\n            targetBufferCons = Uint8Array;\n            type = UnsignedByteType;\n          } else if (byteCount === 2) {\n            targetBufferCons = Uint16Array;\n            type = UnsignedShortType;\n          } else {\n            targetBufferCons = Uint32Array;\n            type = UnsignedIntType;\n          }\n          break;\n      }\n\n      // there will be a mismatch between format length and final length because\n      // RGBFormat and RGBIntegerFormat was removed\n      if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {\n        finalStride = 4;\n      }\n\n      // copy the data over to the new texture array\n      var dimension = Math.ceil(Math.sqrt(count));\n      var length = finalStride * dimension * dimension;\n      var dataArray = new targetBufferCons(length);\n\n      // temporarily set the normalized state to false since we have custom normalization logic\n      var originalNormalized = attr.normalized;\n      attr.normalized = false;\n      for (var i = 0; i < count; i++) {\n        var ii = finalStride * i;\n        dataArray[ii] = attr.getX(i) / normalizeValue;\n        if (itemSize >= 2) {\n          dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n        }\n        if (itemSize >= 3) {\n          dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n          if (finalStride === 4) {\n            dataArray[ii + 3] = 1.0;\n          }\n        }\n        if (itemSize >= 4) {\n          dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n        }\n      }\n      attr.normalized = originalNormalized;\n      this.internalFormat = internalFormat;\n      this.format = format;\n      this.type = type;\n      this.image.width = dimension;\n      this.image.height = dimension;\n      this.image.data = dataArray;\n      this.needsUpdate = true;\n      this.dispose();\n      attr.itemSize = originalItemSize;\n      attr.count = originalCount;\n    }\n  }]);\n  return VertexAttributeTexture;\n}(DataTexture);\nexport var UIntVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu) {\n  _inherits(UIntVertexAttributeTexture, _VertexAttributeTextu);\n  function UIntVertexAttributeTexture() {\n    var _this2;\n    _classCallCheck(this, UIntVertexAttributeTexture);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(UIntVertexAttributeTexture).call(this));\n    _this2._forcedType = UnsignedIntType;\n    return _this2;\n  }\n  return UIntVertexAttributeTexture;\n}(VertexAttributeTexture);\nexport var IntVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu2) {\n  _inherits(IntVertexAttributeTexture, _VertexAttributeTextu2);\n  function IntVertexAttributeTexture() {\n    var _this3;\n    _classCallCheck(this, IntVertexAttributeTexture);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(IntVertexAttributeTexture).call(this));\n    _this3._forcedType = IntType;\n    return _this3;\n  }\n  return IntVertexAttributeTexture;\n}(VertexAttributeTexture);\nexport var FloatVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu3) {\n  _inherits(FloatVertexAttributeTexture, _VertexAttributeTextu3);\n  function FloatVertexAttributeTexture() {\n    var _this4;\n    _classCallCheck(this, FloatVertexAttributeTexture);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(FloatVertexAttributeTexture).call(this));\n    _this4._forcedType = FloatType;\n    return _this4;\n  }\n  return FloatVertexAttributeTexture;\n}(VertexAttributeTexture);","map":null,"metadata":{},"sourceType":"module"}