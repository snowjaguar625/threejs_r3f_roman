{"ast":null,"code":"import _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Vector3, Curve } from 'three';\nimport { ParametricGeometry } from './ParametricGeometry.js';\n\n/**\n * Experimenting of primitive geometry creation using Surface Parametric equations\n */\n\nvar ParametricGeometries = {\n  klein: function klein(v, u, target) {\n    u *= Math.PI;\n    v *= 2 * Math.PI;\n    u = u * 2;\n    var x, z;\n    if (u < Math.PI) {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);\n      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);\n    } else {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);\n      z = -8 * Math.sin(u);\n    }\n    var y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);\n    target.set(x, y, z);\n  },\n  plane: function plane(width, height) {\n    return function (u, v, target) {\n      var x = u * width;\n      var y = 0;\n      var z = v * height;\n      target.set(x, y, z);\n    };\n  },\n  mobius: function mobius(u, t, target) {\n    // flat mobius strip\n    // http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-\n    u = u - 0.5;\n    var v = 2 * Math.PI * t;\n    var a = 2;\n    var x = Math.cos(v) * (a + u * Math.cos(v / 2));\n    var y = Math.sin(v) * (a + u * Math.cos(v / 2));\n    var z = u * Math.sin(v / 2);\n    target.set(x, y, z);\n  },\n  mobius3d: function mobius3d(u, t, target) {\n    // volumetric mobius strip\n    u *= Math.PI;\n    t *= 2 * Math.PI;\n    u = u * 2;\n    var phi = u / 2;\n    var major = 2.25,\n      a = 0.125,\n      b = 0.65;\n    var x = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);\n    var z = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);\n    var y = (major + x) * Math.sin(u);\n    x = (major + x) * Math.cos(u);\n    target.set(x, y, z);\n  }\n};\n/*********************************************\n *\n * Parametric Replacement for TubeGeometry\n *\n *********************************************/\n\nParametricGeometries.TubeGeometry = /*#__PURE__*/function (_ParametricGeometry) {\n  _inherits(TubeGeometry, _ParametricGeometry);\n  function TubeGeometry(path) {\n    var _this;\n    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var segmentsRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    var closed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    _classCallCheck(this, TubeGeometry);\n    var numpoints = segments + 1;\n    var frames = path.computeFrenetFrames(segments, closed),\n      tangents = frames.tangents,\n      normals = frames.normals,\n      binormals = frames.binormals;\n    var position = new Vector3();\n    function ParametricTube(u, v, target) {\n      v *= 2 * Math.PI;\n      var i = Math.floor(u * (numpoints - 1));\n      path.getPointAt(u, position);\n      var normal = normals[i];\n      var binormal = binormals[i];\n      var cx = -radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n\n      var cy = radius * Math.sin(v);\n      position.x += cx * normal.x + cy * binormal.x;\n      position.y += cx * normal.y + cy * binormal.y;\n      position.z += cx * normal.z + cy * binormal.z;\n      target.copy(position);\n    }\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TubeGeometry).call(this, ParametricTube, segments, segmentsRadius)); // proxy internals\n\n    _this.tangents = tangents;\n    _this.normals = normals;\n    _this.binormals = binormals;\n    _this.path = path;\n    _this.segments = segments;\n    _this.radius = radius;\n    _this.segmentsRadius = segmentsRadius;\n    _this.closed = closed;\n    return _this;\n  }\n  return TubeGeometry;\n}(ParametricGeometry);\n/*********************************************\n *\n * Parametric Replacement for TorusKnotGeometry\n *\n *********************************************/\n\nParametricGeometries.TorusKnotGeometry = /*#__PURE__*/function (_ParametricGeometries) {\n  _inherits(TorusKnotGeometry, _ParametricGeometries);\n  function TorusKnotGeometry() {\n    var _this2;\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;\n    var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 40;\n    var segmentsT = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;\n    var segmentsR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    var p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;\n    var q = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;\n    _classCallCheck(this, TorusKnotGeometry);\n    var TorusKnotCurve = /*#__PURE__*/function (_Curve) {\n      _inherits(TorusKnotCurve, _Curve);\n      function TorusKnotCurve() {\n        _classCallCheck(this, TorusKnotCurve);\n        return _possibleConstructorReturn(this, _getPrototypeOf(TorusKnotCurve).apply(this, arguments));\n      }\n      _createClass(TorusKnotCurve, [{\n        key: \"getPoint\",\n        value: function getPoint(t) {\n          var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n          var point = optionalTarget;\n          t *= Math.PI * 2;\n          var r = 0.5;\n          var x = (1 + r * Math.cos(q * t)) * Math.cos(p * t);\n          var y = (1 + r * Math.cos(q * t)) * Math.sin(p * t);\n          var z = r * Math.sin(q * t);\n          return point.set(x, y, z).multiplyScalar(radius);\n        }\n      }]);\n      return TorusKnotCurve;\n    }(Curve);\n    var segments = segmentsT;\n    var radiusSegments = segmentsR;\n    var extrudePath = new TorusKnotCurve();\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(TorusKnotGeometry).call(this, extrudePath, segments, tube, radiusSegments, true, false));\n    _this2.radius = radius;\n    _this2.tube = tube;\n    _this2.segmentsT = segmentsT;\n    _this2.segmentsR = segmentsR;\n    _this2.p = p;\n    _this2.q = q;\n    return _this2;\n  }\n  return TorusKnotGeometry;\n}(ParametricGeometries.TubeGeometry);\n/*********************************************\n *\n * Parametric Replacement for SphereGeometry\n *\n *********************************************/\n\nParametricGeometries.SphereGeometry = /*#__PURE__*/function (_ParametricGeometry2) {\n  _inherits(SphereGeometry, _ParametricGeometry2);\n  function SphereGeometry(size, u, v) {\n    _classCallCheck(this, SphereGeometry);\n    function sphere(u, v, target) {\n      u *= Math.PI;\n      v *= 2 * Math.PI;\n      var x = size * Math.sin(u) * Math.cos(v);\n      var y = size * Math.sin(u) * Math.sin(v);\n      var z = size * Math.cos(u);\n      target.set(x, y, z);\n    }\n    return _possibleConstructorReturn(this, _getPrototypeOf(SphereGeometry).call(this, sphere, u, v));\n  }\n  return SphereGeometry;\n}(ParametricGeometry);\n/*********************************************\n *\n * Parametric Replacement for PlaneGeometry\n *\n *********************************************/\n\nParametricGeometries.PlaneGeometry = /*#__PURE__*/function (_ParametricGeometry3) {\n  _inherits(PlaneGeometry, _ParametricGeometry3);\n  function PlaneGeometry(width, depth, segmentsWidth, segmentsDepth) {\n    _classCallCheck(this, PlaneGeometry);\n    function plane(u, v, target) {\n      var x = u * width;\n      var y = 0;\n      var z = v * depth;\n      target.set(x, y, z);\n    }\n    return _possibleConstructorReturn(this, _getPrototypeOf(PlaneGeometry).call(this, plane, segmentsWidth, segmentsDepth));\n  }\n  return PlaneGeometry;\n}(ParametricGeometry);\nexport { ParametricGeometries };","map":null,"metadata":{},"sourceType":"module"}