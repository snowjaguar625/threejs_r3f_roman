{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\nvar ColladaLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(ColladaLoader, _Loader);\n  function ColladaLoader(manager) {\n    _classCallCheck(this, ColladaLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ColladaLoader).call(this, manager));\n  }\n  _createClass(ColladaLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      function getElementsByTagName(xml, name) {\n        // Non recursive xml.getElementsByTagName() ...\n        var array = [];\n        var childNodes = xml.childNodes;\n        for (var i = 0, l = childNodes.length; i < l; i++) {\n          var child = childNodes[i];\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n        return array;\n      }\n      function parseStrings(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n        return array;\n      }\n      function parseFloats(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n        return array;\n      }\n      function parseInts(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n        return array;\n      }\n      function parseId(text) {\n        return text.substring(1);\n      }\n      function generateId() {\n        return 'three_default_' + count++;\n      }\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      } // asset\n\n      function parseAsset(xml) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n        };\n      }\n      function parseAssetUnit(xml) {\n        if (xml !== undefined && xml.hasAttribute('meter') === true) {\n          return parseFloat(xml.getAttribute('meter'));\n        } else {\n          return 1; // default 1 meter\n        }\n      }\n\n      function parseAssetUpAxis(xml) {\n        return xml !== undefined ? xml.textContent : 'Y_UP';\n      } // library\n\n      function parseLibrary(xml, libraryName, nodeName, parser) {\n        var library = getElementsByTagName(xml, libraryName)[0];\n        if (library !== undefined) {\n          var elements = getElementsByTagName(library, nodeName);\n          for (var i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n      function buildLibrary(data, builder) {\n        for (var name in data) {\n          var object = data[name];\n          object.build = builder(data[name]);\n        }\n      } // get\n\n      function getBuild(data, builder) {\n        if (data.build !== undefined) return data.build;\n        data.build = builder(data);\n        return data.build;\n      } // animation\n\n      function parseAnimation(xml) {\n        var data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        var hasChildren = false;\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = void 0;\n          switch (child.nodeName) {\n            case 'source':\n              id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n            case 'sampler':\n              id = child.getAttribute('id');\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n            case 'channel':\n              id = child.getAttribute('target');\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n            case 'animation':\n              // hierarchy of related animations\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasChildren === false) {\n          // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n          library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n        }\n      }\n      function parseAnimationSampler(xml) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var id = parseId(child.getAttribute('source'));\n              var semantic = child.getAttribute('semantic');\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseAnimationChannel(xml) {\n        var data = {};\n        var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n        var parts = target.split('/');\n        var id = parts.shift();\n        var sid = parts.shift(); // check selection syntax\n\n        var arraySyntax = sid.indexOf('(') !== -1;\n        var memberSyntax = sid.indexOf('.') !== -1;\n        if (memberSyntax) {\n          //  member selection access\n          parts = sid.split('.');\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n          var indices = sid.split('(');\n          sid = indices.shift();\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n          }\n          data.indices = indices;\n        }\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml.getAttribute('source'));\n        return data;\n      }\n      function buildAnimation(data) {\n        var tracks = [];\n        var channels = data.channels;\n        var samplers = data.samplers;\n        var sources = data.sources;\n        for (var target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            var channel = channels[target];\n            var sampler = samplers[channel.sampler];\n            var inputId = sampler.inputs.INPUT;\n            var outputId = sampler.inputs.OUTPUT;\n            var inputSource = sources[inputId];\n            var outputSource = sources[outputId];\n            var animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n        return tracks;\n      }\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        var node = library.nodes[channel.id];\n        var object3D = getNode(node.id);\n        var transform = node.transforms[channel.sid];\n        var defaultMatrix = node.matrix.clone().transpose();\n        var time, stride;\n        var i, il, j, jl;\n        var data = {}; // the collada spec allows the animation of data in various ways.\n        // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n        switch (transform) {\n          case 'matrix':\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === undefined) data[time] = {};\n              if (channel.arraySyntax === true) {\n                var value = outputSource.array[stride];\n                var index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n            break;\n          case 'translate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case 'rotate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case 'scale':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n        var keyframes = prepareAnimationData(data, defaultMatrix);\n        var animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n      function prepareAnimationData(data, defaultMatrix) {\n        var keyframes = []; // transfer data into a sortable array\n\n        for (var time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        } // ensure keyframes are sorted by time\n\n        keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n        for (var i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n        return keyframes; // array sort function\n\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n      var position = new Vector3();\n      var scale = new Vector3();\n      var quaternion = new Quaternion();\n      function createKeyframeTracks(animation, tracks) {\n        var keyframes = animation.keyframes;\n        var name = animation.name;\n        var times = [];\n        var positionData = [];\n        var quaternionData = [];\n        var scaleData = [];\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          var time = keyframe.time;\n          var value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n        if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n        if (quaternionData.length > 0) {\n          tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n        }\n        if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n        return tracks;\n      }\n      function transformAnimationData(keyframes, property, defaultValue) {\n        var keyframe;\n        var empty = true;\n        var i, l; // check, if values of a property are missing in our keyframes\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          if (keyframe.value[property] === undefined) {\n            keyframe.value[property] = null; // mark as missing\n          } else {\n            empty = false;\n          }\n        }\n        if (empty === true) {\n          // no values at all, so we set a default value\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          // filling gaps\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n      function createMissingKeyframes(keyframes, property) {\n        var prev, next;\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n        return null;\n      }\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n        return null;\n      }\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      } // animation clips\n\n      function parseAnimationClip(xml) {\n        var data = {\n          name: xml.getAttribute('id') || 'default',\n          start: parseFloat(xml.getAttribute('start') || 0),\n          end: parseFloat(xml.getAttribute('end') || 0),\n          animations: []\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'instance_animation':\n              data.animations.push(parseId(child.getAttribute('url')));\n              break;\n          }\n        }\n        library.clips[xml.getAttribute('id')] = data;\n      }\n      function buildAnimationClip(data) {\n        var tracks = [];\n        var name = data.name;\n        var duration = data.end - data.start || -1;\n        var animations = data.animations;\n        for (var i = 0, il = animations.length; i < il; i++) {\n          var animationTracks = getAnimation(animations[i]);\n          for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n        return new AnimationClip(name, duration, tracks);\n      }\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      } // controller\n\n      function parseController(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'skin':\n              // there is exactly one skin per controller\n              data.id = parseId(child.getAttribute('source'));\n              data.skin = parseSkin(child);\n              break;\n            case 'morph':\n              data.id = parseId(child.getAttribute('source'));\n              console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n              break;\n          }\n        }\n        library.controllers[xml.getAttribute('id')] = data;\n      }\n      function parseSkin(xml) {\n        var data = {\n          sources: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'bind_shape_matrix':\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n            case 'source':\n              var id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n            case 'joints':\n              data.joints = parseJoints(child);\n              break;\n            case 'vertex_weights':\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseJoints(xml) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var semantic = child.getAttribute('semantic');\n              var id = parseId(child.getAttribute('source'));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseVertexWeights(xml) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var semantic = child.getAttribute('semantic');\n              var id = parseId(child.getAttribute('source'));\n              var offset = parseInt(child.getAttribute('offset'));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n            case 'vcount':\n              data.vcount = parseInts(child.textContent);\n              break;\n            case 'v':\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildController(data) {\n        var build = {\n          id: data.id\n        };\n        var geometry = library.geometries[build.id];\n        if (data.skin !== undefined) {\n          build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n        return build;\n      }\n      function buildSkin(data) {\n        var BONE_LIMIT = 4;\n        var build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        var sources = data.sources;\n        var vertexWeights = data.vertexWeights;\n        var vcount = vertexWeights.vcount;\n        var v = vertexWeights.v;\n        var jointOffset = vertexWeights.inputs.JOINT.offset;\n        var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        var jointSource = data.sources[data.joints.inputs.JOINT];\n        var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        var stride = 0;\n        var i, j, l; // procces skin data for each vertex\n\n        for (i = 0, l = vcount.length; i < l; i++) {\n          var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n          var vertexSkinData = [];\n          for (j = 0; j < jointCount; j++) {\n            var skinIndex = v[stride + jointOffset];\n            var weightId = v[stride + weightOffset];\n            var skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          } // we sort the joints in descending order based on the weights.\n          // this ensures, we only procced the most important joints of the vertex\n\n          vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n          // the order of the skin data matches the order of vertices\n\n          for (j = 0; j < BONE_LIMIT; j++) {\n            var d = vertexSkinData[j];\n            if (d !== undefined) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        } // setup bind matrix\n\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new Matrix4().identity();\n        } // process bones and inverse bind matrix data\n\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          var name = jointSource.array[i];\n          var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n        return build; // array sort function\n\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      } // image\n\n      function parseImage(xml) {\n        var data = {\n          init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n        };\n        library.images[xml.getAttribute('id')] = data;\n      }\n      function buildImage(data) {\n        if (data.build !== undefined) return data.build;\n        return data.init_from;\n      }\n      function getImage(id) {\n        var data = library.images[id];\n        if (data !== undefined) {\n          return getBuild(data, buildImage);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n        return null;\n      } // effect\n\n      function parseEffect(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'profile_COMMON':\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n        library.effects[xml.getAttribute('id')] = data;\n      }\n      function parseEffectProfileCOMMON(xml) {\n        var data = {\n          surfaces: {},\n          samplers: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'newparam':\n              parseEffectNewparam(child, data);\n              break;\n            case 'technique':\n              data.technique = parseEffectTechnique(child);\n              break;\n            case 'extra':\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectNewparam(xml, data) {\n        var sid = xml.getAttribute('sid');\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'surface':\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n            case 'sampler2D':\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n      function parseEffectSurface(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'init_from':\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectSampler(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'source':\n              data.source = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectTechnique(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'constant':\n            case 'lambert':\n            case 'blinn':\n            case 'phong':\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n            case 'extra':\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameters(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'emission':\n            case 'diffuse':\n            case 'specular':\n            case 'bump':\n            case 'ambient':\n            case 'shininess':\n            case 'transparency':\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n            case 'transparent':\n              data[child.nodeName] = {\n                opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameter(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'color':\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n            case 'float':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case 'texture':\n              data[child.nodeName] = {\n                id: child.getAttribute('texture'),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTexture(xml) {\n        var data = {\n          technique: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'extra':\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTextureExtra(xml, data) {\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique':\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n      function parseEffectParameterTextureExtraTechnique(xml, data) {\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'repeatU':\n            case 'repeatV':\n            case 'offsetU':\n            case 'offsetV':\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case 'wrapU':\n            case 'wrapV':\n              // some files have values for wrapU/wrapV which become NaN via parseInt\n              if (child.textContent.toUpperCase() === 'TRUE') {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === 'FALSE') {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n              break;\n            case 'bump':\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n      }\n      function parseEffectExtra(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique':\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechnique(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'double_sided':\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n            case 'bump':\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechniqueBump(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'texture':\n              data[child.nodeName] = {\n                id: child.getAttribute('texture'),\n                texcoord: child.getAttribute('texcoord'),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function buildEffect(data) {\n        return data;\n      }\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      } // material\n\n      function parseMaterial(xml) {\n        var data = {\n          name: xml.getAttribute('name')\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'instance_effect':\n              data.url = parseId(child.getAttribute('url'));\n              break;\n          }\n        }\n        library.materials[xml.getAttribute('id')] = data;\n      }\n      function getTextureLoader(image) {\n        var loader;\n        var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n        extension = extension.toLowerCase();\n        switch (extension) {\n          case 'tga':\n            loader = tgaLoader;\n            break;\n          default:\n            loader = textureLoader;\n        }\n        return loader;\n      }\n      function buildMaterial(data) {\n        var effect = getEffect(data.url);\n        var technique = effect.profile.technique;\n        var material;\n        switch (technique.type) {\n          case 'phong':\n          case 'blinn':\n            material = new MeshPhongMaterial();\n            break;\n          case 'lambert':\n            material = new MeshLambertMaterial();\n            break;\n          default:\n            material = new MeshBasicMaterial();\n            break;\n        }\n        material.name = data.name || '';\n        function getTexture(textureObject) {\n          var sampler = effect.profile.samplers[textureObject.id];\n          var image = null; // get image\n\n          if (sampler !== undefined) {\n            var surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n            image = getImage(textureObject.id);\n          } // create texture if image is avaiable\n\n          if (image !== null) {\n            var loader = getTextureLoader(image);\n            if (loader !== undefined) {\n              var texture = loader.load(image);\n              var extra = textureObject.extra;\n              if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n                var _technique = extra.technique;\n                texture.wrapS = _technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.wrapT = _technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.offset.set(_technique.offsetU || 0, _technique.offsetV || 0);\n                texture.repeat.set(_technique.repeatU || 1, _technique.repeatV || 1);\n              } else {\n                texture.wrapS = RepeatWrapping;\n                texture.wrapT = RepeatWrapping;\n              }\n              return texture;\n            } else {\n              console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n              return null;\n            }\n          } else {\n            console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n            return null;\n          }\n        }\n        var parameters = technique.parameters;\n        for (var key in parameters) {\n          var parameter = parameters[key];\n          switch (key) {\n            case 'diffuse':\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n            case 'specular':\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n            case 'bump':\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n            case 'ambient':\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n            case 'shininess':\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n            case 'emission':\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        } //\n\n        var transparent = parameters['transparent'];\n        var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n        if (transparency === undefined && transparent) {\n          transparency = {\n            float: 1\n          };\n        } // <transparent> does not exist but <transparency>\n\n        if (transparent === undefined && transparency) {\n          transparent = {\n            opaque: 'A_ONE',\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n        if (transparent && transparency) {\n          // handle case if a texture exists but no color\n          if (transparent.data.texture) {\n            // we do not set an alpha map (see #13792)\n            material.transparent = true;\n          } else {\n            var color = transparent.data.color;\n            switch (transparent.opaque) {\n              case 'A_ONE':\n                material.opacity = color[3] * transparency.float;\n                break;\n              case 'RGB_ZERO':\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n              case 'A_ZERO':\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n              case 'RGB_ONE':\n                material.opacity = color[0] * transparency.float;\n                break;\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n            if (material.opacity < 1) material.transparent = true;\n          }\n        } //\n\n        if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n          var techniques = technique.extra.technique;\n          for (var k in techniques) {\n            var v = techniques[k];\n            switch (k) {\n              case 'double_sided':\n                material.side = v === 1 ? DoubleSide : FrontSide;\n                break;\n              case 'bump':\n                material.normalMap = getTexture(v.texture);\n                material.normalScale = new Vector2(1, 1);\n                break;\n            }\n          }\n        }\n        return material;\n      }\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      } // camera\n\n      function parseCamera(xml) {\n        var data = {\n          name: xml.getAttribute('name')\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'optics':\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n        library.cameras[xml.getAttribute('id')] = data;\n      }\n      function parseCameraOptics(xml) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'technique_common':\n              return parseCameraTechnique(child);\n          }\n        }\n        return {};\n      }\n      function parseCameraTechnique(xml) {\n        var data = {};\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'perspective':\n            case 'orthographic':\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseCameraParameters(xml) {\n        var data = {};\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'xfov':\n            case 'yfov':\n            case 'xmag':\n            case 'ymag':\n            case 'znear':\n            case 'zfar':\n            case 'aspect_ratio':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildCamera(data) {\n        var camera;\n        switch (data.optics.technique) {\n          case 'perspective':\n            camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          case 'orthographic':\n            var ymag = data.optics.parameters.ymag;\n            var xmag = data.optics.parameters.xmag;\n            var aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n            ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          default:\n            camera = new PerspectiveCamera();\n            break;\n        }\n        camera.name = data.name || '';\n        return camera;\n      }\n      function getCamera(id) {\n        var data = library.cameras[id];\n        if (data !== undefined) {\n          return getBuild(data, buildCamera);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n        return null;\n      } // light\n\n      function parseLight(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n        library.lights[xml.getAttribute('id')] = data;\n      }\n      function parseLightTechnique(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'directional':\n            case 'point':\n            case 'spot':\n            case 'ambient':\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n        return data;\n      }\n      function parseLightParameters(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'color':\n              var array = parseFloats(child.textContent);\n              data.color = new Color().fromArray(array);\n              break;\n            case 'falloff_angle':\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n            case 'quadratic_attenuation':\n              var f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n        return data;\n      }\n      function buildLight(data) {\n        var light;\n        switch (data.technique) {\n          case 'directional':\n            light = new DirectionalLight();\n            break;\n          case 'point':\n            light = new PointLight();\n            break;\n          case 'spot':\n            light = new SpotLight();\n            break;\n          case 'ambient':\n            light = new AmbientLight();\n            break;\n        }\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n      function getLight(id) {\n        var data = library.lights[id];\n        if (data !== undefined) {\n          return getBuild(data, buildLight);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n        return null;\n      } // geometry\n\n      function parseGeometry(xml) {\n        var data = {\n          name: xml.getAttribute('name'),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n        if (mesh === undefined) return;\n        for (var i = 0; i < mesh.childNodes.length; i++) {\n          var child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = child.getAttribute('id');\n          switch (child.nodeName) {\n            case 'source':\n              data.sources[id] = parseSource(child);\n              break;\n            case 'vertices':\n              // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n              data.vertices = parseGeometryVertices(child);\n              break;\n            case 'polygons':\n              console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n              break;\n            case 'lines':\n            case 'linestrips':\n            case 'polylist':\n            case 'triangles':\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        library.geometries[xml.getAttribute('id')] = data;\n      }\n      function parseSource(xml) {\n        var data = {\n          array: [],\n          stride: 3\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'float_array':\n              data.array = parseFloats(child.textContent);\n              break;\n            case 'Name_array':\n              data.array = parseStrings(child.textContent);\n              break;\n            case 'technique_common':\n              var accessor = getElementsByTagName(child, 'accessor')[0];\n              if (accessor !== undefined) {\n                data.stride = parseInt(accessor.getAttribute('stride'));\n              }\n              break;\n          }\n        }\n        return data;\n      }\n      function parseGeometryVertices(xml) {\n        var data = {};\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n        }\n        return data;\n      }\n      function parseGeometryPrimitive(xml) {\n        var primitive = {\n          type: xml.nodeName,\n          material: xml.getAttribute('material'),\n          count: parseInt(xml.getAttribute('count')),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var id = parseId(child.getAttribute('source'));\n              var semantic = child.getAttribute('semantic');\n              var offset = parseInt(child.getAttribute('offset'));\n              var set = parseInt(child.getAttribute('set'));\n              var inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === 'TEXCOORD') primitive.hasUV = true;\n              break;\n            case 'vcount':\n              primitive.vcount = parseInts(child.textContent);\n              break;\n            case 'p':\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n        return primitive;\n      }\n      function groupPrimitives(primitives) {\n        var build = {};\n        for (var i = 0; i < primitives.length; i++) {\n          var primitive = primitives[i];\n          if (build[primitive.type] === undefined) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n        return build;\n      }\n      function checkUVCoordinates(primitives) {\n        var count = 0;\n        for (var i = 0, l = primitives.length; i < l; i++) {\n          var primitive = primitives[i];\n          if (primitive.hasUV === true) {\n            count++;\n          }\n        }\n        if (count > 0 && count < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n      function buildGeometry(data) {\n        var build = {};\n        var sources = data.sources;\n        var vertices = data.vertices;\n        var primitives = data.primitives;\n        if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n        // first, we group all primitives by their type\n\n        var groupedPrimitives = groupPrimitives(primitives);\n        for (var type in groupedPrimitives) {\n          var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n          checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n        return build;\n      }\n      function buildGeometryType(primitives, sources, vertices) {\n        var build = {};\n        var position = {\n          array: [],\n          stride: 0\n        };\n        var normal = {\n          array: [],\n          stride: 0\n        };\n        var uv = {\n          array: [],\n          stride: 0\n        };\n        var uv2 = {\n          array: [],\n          stride: 0\n        };\n        var color = {\n          array: [],\n          stride: 0\n        };\n        var skinIndex = {\n          array: [],\n          stride: 4\n        };\n        var skinWeight = {\n          array: [],\n          stride: 4\n        };\n        var geometry = new BufferGeometry();\n        var materialKeys = [];\n        var start = 0;\n        for (var p = 0; p < primitives.length; p++) {\n          var primitive = primitives[p];\n          var inputs = primitive.inputs; // groups\n\n          var _count = 0;\n          switch (primitive.type) {\n            case 'lines':\n            case 'linestrips':\n              _count = primitive.count * 2;\n              break;\n            case 'triangles':\n              _count = primitive.count * 3;\n              break;\n            case 'polylist':\n              for (var g = 0; g < primitive.count; g++) {\n                var vc = primitive.vcount[g];\n                switch (vc) {\n                  case 3:\n                    _count += 3; // single triangle\n\n                    break;\n                  case 4:\n                    _count += 6; // quad, subdivided into two triangles\n\n                    break;\n                  default:\n                    _count += (vc - 2) * 3; // polylist with more than four vertices\n\n                    break;\n                }\n              }\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n          }\n          geometry.addGroup(start, _count, p);\n          start += _count; // material\n\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          } // geometry data\n\n          for (var name in inputs) {\n            var input = inputs[name];\n            switch (name) {\n              case 'VERTEX':\n                for (var key in vertices) {\n                  var id = vertices[key];\n                  switch (key) {\n                    case 'POSITION':\n                      var prevLength = position.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position.array);\n                      position.stride = sources[id].stride;\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      } // see #3803\n\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        var _count2 = (position.array.length - prevLength) / position.stride;\n                        for (var i = 0; i < _count2; i++) {\n                          // fill missing uv coordinates\n                          uv.array.push(0, 0);\n                        }\n                      }\n                      break;\n                    case 'NORMAL':\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n                    case 'COLOR':\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n                    case 'TEXCOORD':\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    case 'TEXCOORD1':\n                      buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n                break;\n              case 'NORMAL':\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n              case 'COLOR':\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n              case 'TEXCOORD':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n              case 'TEXCOORD1':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n                uv2.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        } // build geometry\n\n        if (position.array.length > 0) {\n          geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n        }\n        if (normal.array.length > 0) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n        }\n        if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n        if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n        if (skinIndex.array.length > 0) {\n          geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        }\n        if (skinWeight.array.length > 0) {\n          geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        }\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n      function buildGeometryData(primitive, source, offset, array) {\n        var indices = primitive.p;\n        var stride = primitive.stride;\n        var vcount = primitive.vcount;\n        function pushVector(i) {\n          var index = indices[i + offset] * sourceStride;\n          var length = index + sourceStride;\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n        var sourceArray = source.array;\n        var sourceStride = source.stride;\n        if (primitive.vcount !== undefined) {\n          var index = 0;\n          for (var i = 0, l = vcount.length; i < l; i++) {\n            var _count3 = vcount[i];\n            if (_count3 === 4) {\n              var a = index + stride * 0;\n              var b = index + stride * 1;\n              var c = index + stride * 2;\n              var d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (_count3 === 3) {\n              var _a = index + stride * 0;\n              var _b = index + stride * 1;\n              var _c = index + stride * 2;\n              pushVector(_a);\n              pushVector(_b);\n              pushVector(_c);\n            } else if (_count3 > 4) {\n              for (var k = 1, kl = _count3 - 2; k <= kl; k++) {\n                var _a2 = index + stride * 0;\n                var _b2 = index + stride * k;\n                var _c2 = index + stride * (k + 1);\n                pushVector(_a2);\n                pushVector(_b2);\n                pushVector(_c2);\n              }\n            }\n            index += stride * _count3;\n          }\n        } else {\n          for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n            pushVector(_i);\n          }\n        }\n      }\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      } // kinematics\n\n      function parseKinematicsModel(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          joints: {},\n          links: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n        library.kinematicsModels[xml.getAttribute('id')] = data;\n      }\n      function buildKinematicsModel(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n      function parseKinematicsTechniqueCommon(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'joint':\n              data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n              break;\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n      function parseKinematicsJoint(xml) {\n        var data;\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'prismatic':\n            case 'revolute':\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsJointParameter(xml) {\n        var data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          axis: new Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'axis':\n              var array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n            case 'limits':\n              var max = child.getElementsByTagName('max')[0];\n              var min = child.getElementsByTagName('min')[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        } // if min is equal to or greater than max, consider the joint static\n\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        } // calculate middle position\n\n        data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n        return data;\n      }\n      function parseKinematicsLink(xml) {\n        var data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          attachments: [],\n          transforms: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'attachment_full':\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsAttachment(xml) {\n        var data = {\n          joint: xml.getAttribute('joint').split('/').pop(),\n          transforms: [],\n          links: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsTransform(xml) {\n        var data = {\n          type: xml.nodeName\n        };\n        var array = parseFloats(xml.textContent);\n        switch (data.type) {\n          case 'matrix':\n            data.obj = new Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n          case 'translate':\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            break;\n          case 'rotate':\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            data.angle = MathUtils.degToRad(array[3]);\n            break;\n        }\n        return data;\n      } // physics\n\n      function parsePhysicsModel(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          rigidBodies: {}\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'rigid_body':\n              data.rigidBodies[child.getAttribute('name')] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n              break;\n          }\n        }\n        library.physicsModels[xml.getAttribute('id')] = data;\n      }\n      function parsePhysicsRigidBody(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n      function parsePhysicsTechniqueCommon(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'inertia':\n              data.inertia = parseFloats(child.textContent);\n              break;\n            case 'mass':\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      } // scene\n\n      function parseKinematicsScene(xml) {\n        var data = {\n          bindJointAxis: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'bind_joint_axis':\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n        library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n      }\n      function parseKinematicsBindJointAxis(xml) {\n        var data = {\n          target: xml.getAttribute('target').split('/').pop()\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'axis':\n              var param = child.getElementsByTagName('param')[0];\n              data.axis = param.textContent;\n              var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildKinematicsScene(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n      function setupKinematics() {\n        var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        var visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n        var kinematicsModel = getKinematicsModel(kinematicsModelId);\n        var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        var visualScene = getVisualScene(visualSceneId);\n        var bindJointAxis = kinematicsScene.bindJointAxis;\n        var jointMap = {};\n        for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n          var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n          var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n          if (targetElement) {\n            // get the parent of the transform element\n            var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n        function connect(jointIndex, visualElement) {\n          var visualElementName = visualElement.getAttribute('name');\n          var joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n        var m0 = new Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function getJointValue(jointIndex) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n            }\n          },\n          setJointValue: function setJointValue(jointIndex, value) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              var joint = jointData.joint;\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n              } else if (joint.static) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n              } else {\n                var object = jointData.object;\n                var _axis = joint.axis;\n                var transforms = jointData.transforms;\n                matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n                for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                  var transform = transforms[_i2]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case 'revolute':\n                        matrix.multiply(m0.makeRotationAxis(_axis, MathUtils.degToRad(value)));\n                        break;\n                      case 'prismatic':\n                        matrix.multiply(m0.makeTranslation(_axis.x * value, _axis.y * value, _axis.z * value));\n                        break;\n                      default:\n                        console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case 'matrix':\n                        matrix.multiply(transform.obj);\n                        break;\n                      case 'translate':\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n                      case 'scale':\n                        matrix.scale(transform.obj);\n                        break;\n                      case 'rotate':\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n            }\n          }\n        };\n      }\n      function buildTransformList(node) {\n        var transforms = [];\n        var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0,\n            _vector = void 0;\n          switch (child.nodeName) {\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              var _matrix = new Matrix4().fromArray(array).transpose();\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _matrix\n              });\n              break;\n            case 'translate':\n            case 'scale':\n              array = parseFloats(child.textContent);\n              _vector = new Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _vector\n              });\n              break;\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              _vector = new Vector3().fromArray(array);\n              var angle = MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _vector,\n                angle: angle\n              });\n              break;\n          }\n        }\n        return transforms;\n      } // nodes\n\n      function prepareNodes(xml) {\n        var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n          if (element.hasAttribute('id') === false) {\n            element.setAttribute('id', generateId());\n          }\n        }\n      }\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n      function parseNode(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          type: xml.getAttribute('type'),\n          id: xml.getAttribute('id'),\n          sid: xml.getAttribute('sid'),\n          matrix: new Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0;\n          switch (child.nodeName) {\n            case 'node':\n              data.nodes.push(child.getAttribute('id'));\n              parseNode(child);\n              break;\n            case 'instance_camera':\n              data.instanceCameras.push(parseId(child.getAttribute('url')));\n              break;\n            case 'instance_controller':\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n            case 'instance_light':\n              data.instanceLights.push(parseId(child.getAttribute('url')));\n              break;\n            case 'instance_geometry':\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n            case 'instance_node':\n              data.instanceNodes.push(parseId(child.getAttribute('url')));\n              break;\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'translate':\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              var angle = MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'scale':\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'extra':\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasNode(data.id)) {\n          console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n        return data;\n      }\n      function parseNodeInstance(xml) {\n        var data = {\n          id: parseId(xml.getAttribute('url')),\n          materials: {},\n          skeletons: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'bind_material':\n              var instances = child.getElementsByTagName('instance_material');\n              for (var j = 0; j < instances.length; j++) {\n                var instance = instances[j];\n                var symbol = instance.getAttribute('symbol');\n                var target = instance.getAttribute('target');\n                data.materials[symbol] = parseId(target);\n              }\n              break;\n            case 'skeleton':\n              data.skeletons.push(parseId(child.textContent));\n              break;\n          }\n        }\n        return data;\n      }\n      function buildSkeleton(skeletons, joints) {\n        var boneData = [];\n        var sortedBoneData = [];\n        var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n        // situtation with multiple \"skeleton\" tags per controller instance\n\n        for (i = 0; i < skeletons.length; i++) {\n          var skeleton = skeletons[i];\n          var root = void 0;\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            // handle case where the skeleton refers to the visual scene (#13335)\n            var visualScene = library.visualScenes[skeleton];\n            var children = visualScene.children;\n            for (var _j = 0; _j < children.length; _j++) {\n              var child = children[_j];\n              if (child.type === 'JOINT') {\n                var _root = getNode(child.id);\n                buildBoneHierarchy(_root, joints, boneData);\n              }\n            }\n          } else {\n            console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n          }\n        } // sort bone data (the order is defined in the corresponding controller)\n\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        } // add unprocessed bone data at the end of the list\n\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        } // setup arrays for skeleton creation\n\n        var bones = [];\n        var boneInverses = [];\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n        return new Skeleton(bones, boneInverses);\n      }\n      function buildBoneHierarchy(root, joints, boneData) {\n        // setup bone data from visual scene\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            var boneInverse; // retrieve the boneInverse from the controller data\n\n            for (var i = 0; i < joints.length; i++) {\n              var joint = joints[i];\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n            if (boneInverse === undefined) {\n              // Unfortunately, there can be joints in the visual scene that are not part of the\n              // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n              // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n              // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n              // ensure a correct animation of the model.\n              boneInverse = new Matrix4();\n            }\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n      function buildNode(data) {\n        var objects = [];\n        var matrix = data.matrix;\n        var nodes = data.nodes;\n        var type = data.type;\n        var instanceCameras = data.instanceCameras;\n        var instanceControllers = data.instanceControllers;\n        var instanceLights = data.instanceLights;\n        var instanceGeometries = data.instanceGeometries;\n        var instanceNodes = data.instanceNodes; // nodes\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        } // instance cameras\n\n        for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n          var instanceCamera = getCamera(instanceCameras[_i3]);\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        } // instance controllers\n\n        for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n          var instance = instanceControllers[_i4];\n          var controller = getController(instance.id);\n          var geometries = getGeometry(controller.id);\n          var newObjects = buildObjects(geometries, instance.materials);\n          var skeletons = instance.skeletons;\n          var joints = controller.skin.joints;\n          var skeleton = buildSkeleton(skeletons, joints);\n          for (var j = 0, jl = newObjects.length; j < jl; j++) {\n            var _object = newObjects[j];\n            if (_object.isSkinnedMesh) {\n              _object.bind(skeleton, controller.skin.bindMatrix);\n              _object.normalizeSkinWeights();\n            }\n            objects.push(_object);\n          }\n        } // instance lights\n\n        for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n          var instanceLight = getLight(instanceLights[_i5]);\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        } // instance geometries\n\n        for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n          var _instance = instanceGeometries[_i6]; // a single geometry instance in collada can lead to multiple object3Ds.\n          // this is the case when primitives are combined like triangles and lines\n\n          var _geometries = getGeometry(_instance.id);\n          var _newObjects = buildObjects(_geometries, _instance.materials);\n          for (var _j2 = 0, _jl = _newObjects.length; _j2 < _jl; _j2++) {\n            objects.push(_newObjects[_j2]);\n          }\n        } // instance nodes\n\n        for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n          objects.push(getNode(instanceNodes[_i7]).clone());\n        }\n        var object;\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === 'JOINT' ? new Bone() : new Group();\n          for (var _i8 = 0; _i8 < objects.length; _i8++) {\n            object.add(objects[_i8]);\n          }\n        }\n        object.name = type === 'JOINT' ? data.sid : data.name;\n        object.matrix.copy(matrix);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n      var fallbackMaterial = new MeshBasicMaterial({\n        color: 0xff00ff\n      });\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        var materials = [];\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var id = instanceMaterials[keys[i]];\n          if (id === undefined) {\n            console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n        return materials;\n      }\n      function buildObjects(geometries, instanceMaterials) {\n        var objects = [];\n        for (var type in geometries) {\n          var geometry = geometries[type];\n          var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n          if (materials.length === 0) {\n            if (type === 'lines' || type === 'linestrips') {\n              materials.push(new LineBasicMaterial());\n            } else {\n              materials.push(new MeshPhongMaterial());\n            }\n          } // regard skinning\n\n          var skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\n\n          var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n          var object = void 0;\n          switch (type) {\n            case 'lines':\n              object = new LineSegments(geometry.data, material);\n              break;\n            case 'linestrips':\n              object = new Line(geometry.data, material);\n              break;\n            case 'triangles':\n            case 'polylist':\n              if (skinning) {\n                object = new SkinnedMesh(geometry.data, material);\n              } else {\n                object = new Mesh(geometry.data, material);\n              }\n              break;\n          }\n          objects.push(object);\n        }\n        return objects;\n      }\n      function hasNode(id) {\n        return library.nodes[id] !== undefined;\n      }\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      } // visual scenes\n\n      function parseVisualScene(xml) {\n        var data = {\n          name: xml.getAttribute('name'),\n          children: []\n        };\n        prepareNodes(xml);\n        var elements = getElementsByTagName(xml, 'node');\n        for (var i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n        library.visualScenes[xml.getAttribute('id')] = data;\n      }\n      function buildVisualScene(data) {\n        var group = new Group();\n        group.name = data.name;\n        var children = data.children;\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          group.add(getNode(child.id));\n        }\n        return group;\n      }\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== undefined;\n      }\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      } // scenes\n\n      function parseScene(xml) {\n        var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n        return getVisualScene(parseId(instance.getAttribute('url')));\n      }\n      function setupAnimations() {\n        var clips = library.clips;\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            // if there are animations but no clips, we create a default clip for playback\n            var tracks = [];\n            for (var id in library.animations) {\n              var animationTracks = getAnimation(id);\n              for (var i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n            animations.push(new AnimationClip('default', -1, tracks));\n          }\n        } else {\n          for (var _id in clips) {\n            animations.push(getAnimationClip(_id));\n          }\n        }\n      } // convert the parser error element into text with each child elements text\n      // separated by new lines.\n\n      function parserErrorToText(parserError) {\n        var result = '';\n        var stack = [parserError];\n        while (stack.length) {\n          var node = stack.shift();\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += '\\n';\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n        return result.trim();\n      }\n      if (text.length === 0) {\n        return {\n          scene: new Scene()\n        };\n      }\n      var xml = new DOMParser().parseFromString(text, 'application/xml');\n      var collada = getElementsByTagName(xml, 'COLLADA')[0];\n      var parserError = xml.getElementsByTagName('parsererror')[0];\n      if (parserError !== undefined) {\n        // Chrome will return parser error with a div in it\n        var errorElement = getElementsByTagName(parserError, 'div')[0];\n        var errorText;\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n        console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n        return null;\n      } // metadata\n\n      var version = collada.getAttribute('version');\n      console.log('THREE.ColladaLoader: File version', version);\n      var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var tgaLoader;\n      if (TGALoader) {\n        tgaLoader = new TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      } //\n\n      var animations = [];\n      var kinematics = {};\n      var count = 0; //\n\n      var library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n      parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n      parseLibrary(collada, 'library_controllers', 'controller', parseController);\n      parseLibrary(collada, 'library_images', 'image', parseImage);\n      parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n      parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n      parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n      parseLibrary(collada, 'library_lights', 'light', parseLight);\n      parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n      parseLibrary(collada, 'library_nodes', 'node', parseNode);\n      parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n      parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n      parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n      parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n      scene.animations = animations;\n      if (asset.upAxis === 'Z_UP') {\n        scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      }\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n          return animations;\n        },\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }]);\n  return ColladaLoader;\n}(Loader);\nexport { ColladaLoader };","map":null,"metadata":{},"sourceType":"module"}