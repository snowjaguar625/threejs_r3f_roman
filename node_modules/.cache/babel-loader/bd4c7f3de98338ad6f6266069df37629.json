{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ShaderChunk, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, Matrix4, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\nvar voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\nfunction expandShaderIncludes(source) {\n  var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    var chunk = ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n  return source.replace(pattern, replace);\n}\n\n/*\r\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\r\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\r\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\r\n */\n\nvar _lut = [];\nfor (var i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\nfunction generateUUID() {\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  var d0 = Math.random() * 0xffffffff | 0;\n  var d1 = Math.random() * 0xffffffff | 0;\n  var d2 = Math.random() * 0xffffffff | 0;\n  var d3 = Math.random() * 0xffffffff | 0;\n  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase();\n}\n\n// Local assign polyfill to avoid importing troika-core\nvar assign = Object.assign || function /*target, ...sources*/\n() {\n  var target = arguments[0];\n  for (var _i = 1, len = arguments.length; _i < len; _i++) {\n    var source = arguments[_i];\n    if (source) {\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target;\n};\nvar epoch = Date.now();\nvar CONSTRUCTOR_CACHE = new WeakMap();\nvar SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nvar materialInstanceId = 1e10;\n\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  var optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  var ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n  var privateBeforeCompileProp = \"_onBeforeCompile\".concat(optionsKey);\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  var onBeforeCompile = function onBeforeCompile(shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    var cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    var upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      var upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n  var DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n  var derive = function derive(base) {\n    // Prototype chain to the base material\n    var derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[\"TROIKA_DERIVED_MATERIAL_\".concat(optionsKey)] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n    return derived;\n  };\n  var descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        return optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get: function get() {\n        return onBeforeCompile;\n      },\n      set: function set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function value(source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\n        }\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({\n            depthPacking: RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return depthMaterial;\n      }\n    },\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var _depthMaterial = this._depthMaterial,\n          _distanceMaterial = this._distanceMaterial;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\nfunction upgradeShaders(_ref, options, key) {\n  var vertexShader = _ref.vertexShader,\n    fragmentShader = _ref.fragmentShader;\n  var vertexDefs = options.vertexDefs,\n    vertexMainIntro = options.vertexMainIntro,\n    vertexMainOutro = options.vertexMainOutro,\n    vertexTransform = options.vertexTransform,\n    fragmentDefs = options.fragmentDefs,\n    fragmentMainIntro = options.fragmentMainIntro,\n    fragmentMainOutro = options.fragmentMainOutro,\n    fragmentColorTransform = options.fragmentColorTransform,\n    customRewriter = options.customRewriter,\n    timeUniform = options.timeUniform;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    var res = customRewriter({\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    var postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,\n    // [^]+? = non-greedy match of any chars including newlines\n    function (match) {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = \"\".concat(fragmentColorTransform, \"\\n\").concat(postChunks.join('\\n'), \"\\n\").concat(fragmentMainOutro);\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    var code = \"\\nuniform float \".concat(timeUniform, \";\\n\");\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = \"vec3 troika_position_\".concat(key, \";\\nvec3 troika_normal_\").concat(key, \";\\nvec2 troika_uv_\").concat(key, \";\\n\").concat(vertexShader, \"\\n\");\n    vertexDefs = \"\".concat(vertexDefs, \"\\nvoid troikaVertexTransform\").concat(key, \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \").concat(vertexTransform, \"\\n}\\n\");\n    vertexMainIntro = \"\\ntroika_position_\".concat(key, \" = vec3(position);\\ntroika_normal_\").concat(key, \" = vec3(normal);\\ntroika_uv_\").concat(key, \" = vec2(uv);\\ntroikaVertexTransform\").concat(key, \"(troika_position_\").concat(key, \", troika_normal_\").concat(key, \", troika_uv_\").concat(key, \");\\n\").concat(vertexMainIntro, \"\\n\");\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : \"troika_\".concat(match1, \"_\").concat(key);\n    });\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader\n  };\n}\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, \"\\n\".concat(defs, \"\\nvoid troikaOrigMain\").concat(id, \"() {\"));\n    shaderCode += \"\\nvoid main() {\\n  \".concat(intro, \"\\n  troikaOrigMain\").concat(id, \"();\\n  \").concat(outro, \"\\n}\");\n  }\n  return shaderCode;\n}\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\nvar _idCtr = 0;\nvar optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  var optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  var id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n  return id;\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nvar MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\nfunction getShadersForMaterial(material) {\n  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\nfunction getShaderUniformTypes(shader) {\n  var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n  var uniforms = Object.create(null);\n  var match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms;\n}\n\n/**\r\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\r\n * that happened in ThreeJS r123.\r\n * @param {Matrix4} srcMatrix\r\n * @param {Matrix4} [tgtMatrix]\r\n */\nfunction invertMatrix4(srcMatrix) {\n  var tgtMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix;\n}\n\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\n\nvar vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\nvar vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\nvar fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\nvar fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new Vector3()\n      },\n      controlA: {\n        value: new Vector3()\n      },\n      controlB: {\n        value: new Vector3()\n      },\n      pointB: {\n        value: new Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new Vector3()\n      } //on, off, offset\n    },\n\n    vertexDefs: vertexDefs,\n    vertexTransform: vertexTransform,\n    fragmentDefs: fragmentDefs,\n    fragmentMainIntro: fragmentMainIntro\n  });\n}\nvar geometry = null;\nvar defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({\n  color: 0xffffff,\n  side: DoubleSide\n});\n\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\nvar BezierMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(BezierMesh, _Mesh);\n  _createClass(BezierMesh, null, [{\n    key: \"getGeometry\",\n    value: function getGeometry() {\n      return geometry || (geometry = new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    }\n  }]);\n  function BezierMesh() {\n    var _this;\n    _classCallCheck(this, BezierMesh);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BezierMesh).call(this, BezierMesh.getGeometry(), defaultBaseMaterial));\n    _this.pointA = new Vector3();\n    _this.controlA = new Vector3();\n    _this.controlB = new Vector3();\n    _this.pointB = new Vector3();\n    _this.radius = 0.01;\n    _this.dashArray = new Vector2();\n    _this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    _this.frustumCulled = false;\n    return _this;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  _createClass(BezierMesh, [{\n    key: \"onBeforeRender\",\n    value: function onBeforeRender(shaderInfo) {\n      var uniforms = this.material.uniforms;\n      var pointA = this.pointA,\n        controlA = this.controlA,\n        controlB = this.controlB,\n        pointB = this.pointB,\n        radius = this.radius,\n        dashArray = this.dashArray,\n        dashOffset = this.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      // TODO - just fail for now\n    }\n  }, {\n    key: \"material\",\n    get: function get() {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial;\n    },\n    set: function set(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    } // Create and update material for shadows upon request:\n  }, {\n    key: \"customDepthMaterial\",\n    get: function get() {\n      return this.material.getDepthMaterial();\n    }\n  }, {\n    key: \"customDistanceMaterial\",\n    get: function get() {\n      return this.material.getDistanceMaterial();\n    }\n  }]);\n  return BezierMesh;\n}(Mesh);\nexport { BezierMesh, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, invertMatrix4, voidMainRegExp };","map":null,"metadata":{},"sourceType":"module"}