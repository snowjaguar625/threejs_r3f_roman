{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, Group, MeshPhongMaterial, Float32BufferAttribute, Color, BufferGeometry, Mesh, LoaderUtils } from 'three';\nimport { unzipSync } from 'fflate';\n\n/**\n * Description: Early release of an AMF Loader following the pattern of the\n * example loaders in the three.js project.\n *\n * Usage:\n *\tconst loader = new AMFLoader();\n *\tloader.load('/path/to/project.amf', function(objecttree) {\n *\t\tscene.add(objecttree);\n *\t});\n *\n * Materials now supported, material colors supported\n * Zip support, requires fflate\n * No constellation support (yet)!\n *\n */\nvar AMFLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(AMFLoader, _Loader);\n  function AMFLoader(manager) {\n    _classCallCheck(this, AMFLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(AMFLoader).call(this, manager));\n  }\n  _createClass(AMFLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function loadDocument(data) {\n        var view = new DataView(data);\n        var magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n        if (magic === 'PK') {\n          var zip = null;\n          var file = null;\n          console.log('THREE.AMFLoader: Loading Zip');\n          try {\n            zip = unzipSync(new Uint8Array(data));\n          } catch (e) {\n            if (e instanceof ReferenceError) {\n              console.log('THREE.AMFLoader: fflate missing and file is compressed.');\n              return null;\n            }\n          }\n          for (file in zip) {\n            if (file.toLowerCase().substr(-4) === '.amf') {\n              break;\n            }\n          }\n          console.log('THREE.AMFLoader: Trying to load file asset: ' + file);\n          view = new DataView(zip[file].buffer);\n        }\n        var fileText = LoaderUtils.decodeText(view);\n        var xmlData = new DOMParser().parseFromString(fileText, 'application/xml');\n        if (xmlData.documentElement.nodeName.toLowerCase() !== 'amf') {\n          console.log('THREE.AMFLoader: Error loading AMF - no AMF document found.');\n          return null;\n        }\n        return xmlData;\n      }\n      function loadDocumentScale(node) {\n        var scale = 1.0;\n        var unit = 'millimeter';\n        if (node.documentElement.attributes.unit !== undefined) {\n          unit = node.documentElement.attributes.unit.value.toLowerCase();\n        }\n        var scaleUnits = {\n          millimeter: 1.0,\n          inch: 25.4,\n          feet: 304.8,\n          meter: 1000.0,\n          micron: 0.001\n        };\n        if (scaleUnits[unit] !== undefined) {\n          scale = scaleUnits[unit];\n        }\n        console.log('THREE.AMFLoader: Unit scale: ' + scale);\n        return scale;\n      }\n      function loadMaterials(node) {\n        var matName = 'AMF Material';\n        var matId = node.attributes.id.textContent;\n        var color = {\n          r: 1.0,\n          g: 1.0,\n          b: 1.0,\n          a: 1.0\n        };\n        var loadedMaterial = null;\n        for (var _i = 0; _i < node.childNodes.length; _i++) {\n          var matChildEl = node.childNodes[_i];\n          if (matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined) {\n            if (matChildEl.attributes.type.value === 'name') {\n              matName = matChildEl.textContent;\n            }\n          } else if (matChildEl.nodeName === 'color') {\n            color = loadColor(matChildEl);\n          }\n        }\n        loadedMaterial = new MeshPhongMaterial({\n          flatShading: true,\n          color: new Color(color.r, color.g, color.b),\n          name: matName\n        });\n        if (color.a !== 1.0) {\n          loadedMaterial.transparent = true;\n          loadedMaterial.opacity = color.a;\n        }\n        return {\n          id: matId,\n          material: loadedMaterial\n        };\n      }\n      function loadColor(node) {\n        var color = {\n          r: 1.0,\n          g: 1.0,\n          b: 1.0,\n          a: 1.0\n        };\n        for (var _i2 = 0; _i2 < node.childNodes.length; _i2++) {\n          var matColor = node.childNodes[_i2];\n          if (matColor.nodeName === 'r') {\n            color.r = matColor.textContent;\n          } else if (matColor.nodeName === 'g') {\n            color.g = matColor.textContent;\n          } else if (matColor.nodeName === 'b') {\n            color.b = matColor.textContent;\n          } else if (matColor.nodeName === 'a') {\n            color.a = matColor.textContent;\n          }\n        }\n        return color;\n      }\n      function loadMeshVolume(node) {\n        var volume = {\n          name: '',\n          triangles: [],\n          materialid: null\n        };\n        var currVolumeNode = node.firstElementChild;\n        if (node.attributes.materialid !== undefined) {\n          volume.materialId = node.attributes.materialid.nodeValue;\n        }\n        while (currVolumeNode) {\n          if (currVolumeNode.nodeName === 'metadata') {\n            if (currVolumeNode.attributes.type !== undefined) {\n              if (currVolumeNode.attributes.type.value === 'name') {\n                volume.name = currVolumeNode.textContent;\n              }\n            }\n          } else if (currVolumeNode.nodeName === 'triangle') {\n            var v1 = currVolumeNode.getElementsByTagName('v1')[0].textContent;\n            var v2 = currVolumeNode.getElementsByTagName('v2')[0].textContent;\n            var v3 = currVolumeNode.getElementsByTagName('v3')[0].textContent;\n            volume.triangles.push(v1, v2, v3);\n          }\n          currVolumeNode = currVolumeNode.nextElementSibling;\n        }\n        return volume;\n      }\n      function loadMeshVertices(node) {\n        var vertArray = [];\n        var normalArray = [];\n        var currVerticesNode = node.firstElementChild;\n        while (currVerticesNode) {\n          if (currVerticesNode.nodeName === 'vertex') {\n            var vNode = currVerticesNode.firstElementChild;\n            while (vNode) {\n              if (vNode.nodeName === 'coordinates') {\n                var x = vNode.getElementsByTagName('x')[0].textContent;\n                var y = vNode.getElementsByTagName('y')[0].textContent;\n                var z = vNode.getElementsByTagName('z')[0].textContent;\n                vertArray.push(x, y, z);\n              } else if (vNode.nodeName === 'normal') {\n                var nx = vNode.getElementsByTagName('nx')[0].textContent;\n                var ny = vNode.getElementsByTagName('ny')[0].textContent;\n                var nz = vNode.getElementsByTagName('nz')[0].textContent;\n                normalArray.push(nx, ny, nz);\n              }\n              vNode = vNode.nextElementSibling;\n            }\n          }\n          currVerticesNode = currVerticesNode.nextElementSibling;\n        }\n        return {\n          vertices: vertArray,\n          normals: normalArray\n        };\n      }\n      function loadObject(node) {\n        var objId = node.attributes.id.textContent;\n        var loadedObject = {\n          name: 'amfobject',\n          meshes: []\n        };\n        var currColor = null;\n        var currObjNode = node.firstElementChild;\n        while (currObjNode) {\n          if (currObjNode.nodeName === 'metadata') {\n            if (currObjNode.attributes.type !== undefined) {\n              if (currObjNode.attributes.type.value === 'name') {\n                loadedObject.name = currObjNode.textContent;\n              }\n            }\n          } else if (currObjNode.nodeName === 'color') {\n            currColor = loadColor(currObjNode);\n          } else if (currObjNode.nodeName === 'mesh') {\n            var currMeshNode = currObjNode.firstElementChild;\n            var mesh = {\n              vertices: [],\n              normals: [],\n              volumes: [],\n              color: currColor\n            };\n            while (currMeshNode) {\n              if (currMeshNode.nodeName === 'vertices') {\n                var loadedVertices = loadMeshVertices(currMeshNode);\n                mesh.normals = mesh.normals.concat(loadedVertices.normals);\n                mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n              } else if (currMeshNode.nodeName === 'volume') {\n                mesh.volumes.push(loadMeshVolume(currMeshNode));\n              }\n              currMeshNode = currMeshNode.nextElementSibling;\n            }\n            loadedObject.meshes.push(mesh);\n          }\n          currObjNode = currObjNode.nextElementSibling;\n        }\n        return {\n          id: objId,\n          obj: loadedObject\n        };\n      }\n      var xmlData = loadDocument(data);\n      var amfName = '';\n      var amfAuthor = '';\n      var amfScale = loadDocumentScale(xmlData);\n      var amfMaterials = {};\n      var amfObjects = {};\n      var childNodes = xmlData.documentElement.childNodes;\n      var i, j;\n      for (i = 0; i < childNodes.length; i++) {\n        var child = childNodes[i];\n        if (child.nodeName === 'metadata') {\n          if (child.attributes.type !== undefined) {\n            if (child.attributes.type.value === 'name') {\n              amfName = child.textContent;\n            } else if (child.attributes.type.value === 'author') {\n              amfAuthor = child.textContent;\n            }\n          }\n        } else if (child.nodeName === 'material') {\n          var loadedMaterial = loadMaterials(child);\n          amfMaterials[loadedMaterial.id] = loadedMaterial.material;\n        } else if (child.nodeName === 'object') {\n          var loadedObject = loadObject(child);\n          amfObjects[loadedObject.id] = loadedObject.obj;\n        }\n      }\n      var sceneObject = new Group();\n      var defaultMaterial = new MeshPhongMaterial({\n        color: 0xaaaaff,\n        flatShading: true\n      });\n      sceneObject.name = amfName;\n      sceneObject.userData.author = amfAuthor;\n      sceneObject.userData.loader = 'AMF';\n      for (var id in amfObjects) {\n        var part = amfObjects[id];\n        var meshes = part.meshes;\n        var newObject = new Group();\n        newObject.name = part.name || '';\n        for (i = 0; i < meshes.length; i++) {\n          var objDefaultMaterial = defaultMaterial;\n          var mesh = meshes[i];\n          var vertices = new Float32BufferAttribute(mesh.vertices, 3);\n          var normals = null;\n          if (mesh.normals.length) {\n            normals = new Float32BufferAttribute(mesh.normals, 3);\n          }\n          if (mesh.color) {\n            var color = mesh.color;\n            objDefaultMaterial = defaultMaterial.clone();\n            objDefaultMaterial.color = new Color(color.r, color.g, color.b);\n            if (color.a !== 1.0) {\n              objDefaultMaterial.transparent = true;\n              objDefaultMaterial.opacity = color.a;\n            }\n          }\n          var volumes = mesh.volumes;\n          for (j = 0; j < volumes.length; j++) {\n            var volume = volumes[j];\n            var newGeometry = new BufferGeometry();\n            var material = objDefaultMaterial;\n            newGeometry.setIndex(volume.triangles);\n            newGeometry.setAttribute('position', vertices.clone());\n            if (normals) {\n              newGeometry.setAttribute('normal', normals.clone());\n            }\n            if (amfMaterials[volume.materialId] !== undefined) {\n              material = amfMaterials[volume.materialId];\n            }\n            newGeometry.scale(amfScale, amfScale, amfScale);\n            newObject.add(new Mesh(newGeometry, material.clone()));\n          }\n        }\n        sceneObject.add(newObject);\n      }\n      return sceneObject;\n    }\n  }]);\n  return AMFLoader;\n}(Loader);\nexport { AMFLoader };","map":null,"metadata":{},"sourceType":"module"}