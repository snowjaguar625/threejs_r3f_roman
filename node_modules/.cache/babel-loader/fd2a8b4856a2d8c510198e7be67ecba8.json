{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Vector3 } from 'three';\nexport var SeparatingAxisBounds = /*#__PURE__*/function () {\n  function SeparatingAxisBounds() {\n    _classCallCheck(this, SeparatingAxisBounds);\n    this.min = Infinity;\n    this.max = -Infinity;\n  }\n  _createClass(SeparatingAxisBounds, [{\n    key: \"setFromPointsField\",\n    value: function setFromPointsField(points, field) {\n      var min = Infinity;\n      var max = -Infinity;\n      for (var i = 0, l = points.length; i < l; i++) {\n        var p = points[i];\n        var val = p[field];\n        min = val < min ? val : min;\n        max = val > max ? val : max;\n      }\n      this.min = min;\n      this.max = max;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(axis, points) {\n      var min = Infinity;\n      var max = -Infinity;\n      for (var i = 0, l = points.length; i < l; i++) {\n        var p = points[i];\n        var val = axis.dot(p);\n        min = val < min ? val : min;\n        max = val > max ? val : max;\n      }\n      this.min = min;\n      this.max = max;\n    }\n  }, {\n    key: \"isSeparated\",\n    value: function isSeparated(other) {\n      return this.min > other.max || other.min > this.max;\n    }\n  }]);\n  return SeparatingAxisBounds;\n}();\nSeparatingAxisBounds.prototype.setFromBox = function () {\n  var p = new Vector3();\n  return function setFromBox(axis, box) {\n    var boxMin = box.min;\n    var boxMax = box.max;\n    var min = Infinity;\n    var max = -Infinity;\n    for (var x = 0; x <= 1; x++) {\n      for (var y = 0; y <= 1; y++) {\n        for (var z = 0; z <= 1; z++) {\n          p.x = boxMin.x * x + boxMax.x * (1 - x);\n          p.y = boxMin.y * y + boxMax.y * (1 - y);\n          p.z = boxMin.z * z + boxMax.z * (1 - z);\n          var val = axis.dot(p);\n          min = Math.min(val, min);\n          max = Math.max(val, max);\n        }\n      }\n    }\n    this.min = min;\n    this.max = max;\n  };\n}();\nexport var areIntersecting = function () {\n  var cacheSatBounds = new SeparatingAxisBounds();\n  return function areIntersecting(shape1, shape2) {\n    var points1 = shape1.points;\n    var satAxes1 = shape1.satAxes;\n    var satBounds1 = shape1.satBounds;\n    var points2 = shape2.points;\n    var satAxes2 = shape2.satAxes;\n    var satBounds2 = shape2.satBounds;\n\n    // check axes of the first shape\n    for (var i = 0; i < 3; i++) {\n      var sb = satBounds1[i];\n      var sa = satAxes1[i];\n      cacheSatBounds.setFromPoints(sa, points2);\n      if (sb.isSeparated(cacheSatBounds)) return false;\n    }\n\n    // check axes of the second shape\n    for (var _i = 0; _i < 3; _i++) {\n      var _sb = satBounds2[_i];\n      var _sa = satAxes2[_i];\n      cacheSatBounds.setFromPoints(_sa, points1);\n      if (_sb.isSeparated(cacheSatBounds)) return false;\n    }\n  };\n}();","map":null,"metadata":{},"sourceType":"module"}