{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LLkLookaheadStrategy = void 0;\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar errors_public_1 = require(\"../errors_public\");\nvar parser_1 = require(\"../parser/parser\");\nvar checks_1 = require(\"./checks\");\nvar lookahead_1 = require(\"./lookahead\");\nvar LLkLookaheadStrategy = /** @class */function () {\n  function LLkLookaheadStrategy(options) {\n    var _a;\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n  LLkLookaheadStrategy.prototype.validate = function (options) {\n    var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n    if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n      var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n      var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  };\n  LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n    return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n  };\n  LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n  };\n  LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n  };\n  return LLkLookaheadStrategy;\n}();\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;","map":null,"metadata":{},"sourceType":"script"}