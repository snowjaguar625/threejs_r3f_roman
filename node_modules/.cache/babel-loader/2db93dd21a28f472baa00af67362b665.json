{"ast":null,"code":"import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nvar SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new Color();\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\n};\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function dispose() {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function setSize(width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function render(renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        format: RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n      height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (var i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625,\n        // 0.0625 = 1 / 16\n        width, height);\n      }\n      var sampleWeight = baseSampleWeight;\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n      this.fsQuad.render(renderer);\n    }\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { SSAARenderPass };","map":null,"metadata":{},"sourceType":"module"}