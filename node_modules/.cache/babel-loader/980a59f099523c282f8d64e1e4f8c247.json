{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\nvar VTKLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VTKLoader, _Loader);\n  function VTKLoader(manager) {\n    _classCallCheck(this, VTKLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(VTKLoader).call(this, manager));\n  }\n  _createClass(VTKLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseASCII(data) {\n        // connectivity of the triangles\n        var indices = []; // triangles vertices\n\n        var positions = []; // red, green, blue colors in the range 0 to 1\n\n        var colors = []; // normal vector, one per vertex\n\n        var normals = [];\n        var result; // pattern for detecting the end of a number sequence\n\n        var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n        var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n        // the first integer is the number of polygon nodes\n\n        var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n        var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n        var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n        var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n        var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n        var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n        var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n        var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n        var inPointsSection = false;\n        var inPolygonsSection = false;\n        var inTriangleStripSection = false;\n        var inPointDataSection = false;\n        var inCellDataSection = false;\n        var inColorSection = false;\n        var inNormalsSection = false;\n        var lines = data.split('\\n');\n        for (var i in lines) {\n          var line = lines[i].trim();\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (inPointsSection) {\n            // get the vertices\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var x = parseFloat(result[1]);\n              var y = parseFloat(result[2]);\n              var z = parseFloat(result[3]);\n              positions.push(x, y, z);\n            }\n          } else if (inPolygonsSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n              if (numVertices >= 3) {\n                var i0 = parseInt(inds[0]);\n                var i1, i2;\n                var k = 1; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; ++j) {\n                  i1 = parseInt(inds[k]);\n                  i2 = parseInt(inds[k + 1]);\n                  indices.push(i0, i1, i2);\n                  k++;\n                }\n              }\n            }\n          } else if (inTriangleStripSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n              if (numVertices >= 3) {\n                var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; j++) {\n                  if (j % 2 === 1) {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 2]);\n                    i2 = parseInt(inds[j + 1]);\n                    indices.push(i0, i1, i2);\n                  } else {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 1]);\n                    i2 = parseInt(inds[j + 2]);\n                    indices.push(i0, i1, i2);\n                  }\n                }\n              }\n            }\n          } else if (inPointDataSection || inCellDataSection) {\n            if (inColorSection) {\n              // Get the colors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var r = parseFloat(result[1]);\n                var g = parseFloat(result[2]);\n                var b = parseFloat(result[3]);\n                colors.push(r, g, b);\n              }\n            } else if (inNormalsSection) {\n              // Get the normal vectors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var nx = parseFloat(result[1]);\n                var ny = parseFloat(result[2]);\n                var nz = parseFloat(result[3]);\n                normals.push(nx, ny, nz);\n              }\n            }\n          }\n          if (patPOLYGONS.exec(line) !== null) {\n            inPolygonsSection = true;\n            inPointsSection = false;\n            inTriangleStripSection = false;\n          } else if (patPOINTS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = true;\n            inTriangleStripSection = false;\n          } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = false;\n            inTriangleStripSection = true;\n          } else if (patPOINT_DATA.exec(line) !== null) {\n            inPointDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCELL_DATA.exec(line) !== null) {\n            inCellDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCOLOR_SCALARS.exec(line) !== null) {\n            inColorSection = true;\n            inNormalsSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patNORMALS.exec(line) !== null) {\n            inNormalsSection = true;\n            inColorSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(indices);\n        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n        if (normals.length === positions.length) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n        }\n        if (colors.length !== indices.length) {\n          // stagger\n          if (colors.length === positions.length) {\n            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n          }\n        } else {\n          // cell\n          geometry = geometry.toNonIndexed();\n          var numTriangles = geometry.attributes.position.count / 3;\n          if (colors.length === numTriangles * 3) {\n            var newColors = [];\n            for (var i = 0; i < numTriangles; i++) {\n              var r = colors[3 * i + 0];\n              var g = colors[3 * i + 1];\n              var b = colors[3 * i + 2];\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n            }\n            geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n          }\n        }\n        return geometry;\n      }\n      function parseBinary(data) {\n        var count, pointIndex, i, numberOfPoints, s;\n        var buffer = new Uint8Array(data);\n        var dataView = new DataView(data); // Points and normals, by default, are empty\n\n        var points = [];\n        var normals = [];\n        var indices = []; // Going to make a big array of strings\n        var index = 0;\n        function findString(buffer, start) {\n          var index = start;\n          var c = buffer[index];\n          var s = [];\n          while (c !== 10) {\n            s.push(String.fromCharCode(c));\n            index++;\n            c = buffer[index];\n          }\n          return {\n            start: start,\n            end: index,\n            next: index + 1,\n            parsedString: s.join('')\n          };\n        }\n        var state, line;\n        while (true) {\n          // Get a string\n          state = findString(buffer, index);\n          line = state.parsedString;\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (line.indexOf('POINTS') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n            count = numberOfPoints * 4 * 3;\n            points = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n            for (i = 0; i < numberOfPoints; i++) {\n              points[3 * i] = dataView.getFloat32(pointIndex, false);\n              points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex = pointIndex + 12;\n            } // increment our next pointer\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // retrieves the n-2 triangles from the triangle strip\n\n              for (var j = 0; j < indexCount - 2; j++) {\n                if (j % 2) {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 2];\n                  indices[indicesIndex++] = strip[j + 1];\n                } else {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 1];\n                  indices[indicesIndex++] = strip[j + 2];\n                }\n              }\n            } // increment our next pointer\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POLYGONS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // divide the polygon in n-2 triangle\n\n              for (var j = 1; j < indexCount - 1; j++) {\n                indices[indicesIndex++] = strip[0];\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n              }\n            } // increment our next pointer\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POINT_DATA') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n            state = findString(buffer, state.next); // Now grab the binary data\n\n            count = numberOfPoints * 4 * 3;\n            normals = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n            for (i = 0; i < numberOfPoints; i++) {\n              normals[3 * i] = dataView.getFloat32(pointIndex, false);\n              normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex += 12;\n            } // Increment past our data\n\n            state.next = state.next + count;\n          } // Increment index\n\n          index = state.next;\n          if (index >= buffer.byteLength) {\n            break;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n        return geometry;\n      }\n      function Float32Concat(first, second) {\n        var firstLength = first.length,\n          result = new Float32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n      function Int32Concat(first, second) {\n        var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n      function parseXML(stringFile) {\n        // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n        function xmlToJson(xml) {\n          // Create the return object\n          var obj = {};\n          if (xml.nodeType === 1) {\n            // element\n            // do attributes\n            if (xml.attributes) {\n              if (xml.attributes.length > 0) {\n                obj['attributes'] = {};\n                for (var j = 0; j < xml.attributes.length; j++) {\n                  var attribute = xml.attributes.item(j);\n                  obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n                }\n              }\n            }\n          } else if (xml.nodeType === 3) {\n            // text\n            obj = xml.nodeValue.trim();\n          } // do children\n\n          if (xml.hasChildNodes()) {\n            for (var i = 0; i < xml.childNodes.length; i++) {\n              var item = xml.childNodes.item(i);\n              var nodeName = item.nodeName;\n              if (typeof obj[nodeName] === 'undefined') {\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName] = tmp;\n              } else {\n                if (typeof obj[nodeName].push === 'undefined') {\n                  var old = obj[nodeName];\n                  obj[nodeName] = [old];\n                }\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName].push(tmp);\n              }\n            }\n          }\n          return obj;\n        } // Taken from Base64-js\n\n        function Base64toByteArray(b64) {\n          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n          var i;\n          var lookup = [];\n          var revLookup = [];\n          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n          var len = code.length;\n          for (i = 0; i < len; i++) {\n            lookup[i] = code[i];\n          }\n          for (i = 0; i < len; ++i) {\n            revLookup[code.charCodeAt(i)] = i;\n          }\n          revLookup['-'.charCodeAt(0)] = 62;\n          revLookup['_'.charCodeAt(0)] = 63;\n          var j, l, tmp, placeHolders, arr;\n          var len = b64.length;\n          if (len % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n          placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n          arr = new Arr(len * 3 / 4 - placeHolders);\n          l = placeHolders > 0 ? len - 4 : len;\n          var L = 0;\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n            arr[L++] = (tmp & 0xff0000) >> 16;\n            arr[L++] = (tmp & 0xff00) >> 8;\n            arr[L++] = tmp & 0xff;\n          }\n          if (placeHolders === 2) {\n            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n            arr[L++] = tmp & 0xff;\n          } else if (placeHolders === 1) {\n            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n            arr[L++] = tmp >> 8 & 0xff;\n            arr[L++] = tmp & 0xff;\n          }\n          return arr;\n        }\n        function parseDataArray(ele, compressed) {\n          var numBytes = 0;\n          if (json.attributes.header_type === 'UInt64') {\n            numBytes = 8;\n          } else if (json.attributes.header_type === 'UInt32') {\n            numBytes = 4;\n          } // Check the format\n\n          if (ele.attributes.format === 'binary' && compressed) {\n            var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array();\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array();\n            } // VTP data with the header has the following structure:\n            // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n            //\n            // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n            // [#blocks] = Number of blocks\n            // [#u-size] = Block size before compression\n            // [#p-size] = Size of last partial block (zero if it not needed)\n            // [#c-size-i] = Size in bytes of block i after compression\n            //\n            // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n            // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n            rawData = ele['#text'];\n            byteData = Base64toByteArray(rawData);\n            blocks = byteData[0];\n            for (var i = 1; i < numBytes - 1; i++) {\n              blocks = blocks | byteData[i] << i * numBytes;\n            }\n            headerSize = (blocks + 3) * numBytes;\n            padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n            headerSize = headerSize + padding;\n            dataOffsets = [];\n            currentOffset = headerSize;\n            dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n            // There are three blocks before c-size-i, so we skip 3*numBytes\n\n            cSizeStart = 3 * numBytes;\n            for (var i = 0; i < blocks; i++) {\n              var currentBlockSize = byteData[i * numBytes + cSizeStart];\n              for (var j = 1; j < numBytes - 1; j++) {\n                // Each data point consists of 8 bytes regardless of the header type\n                currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n              }\n              currentOffset = currentOffset + currentBlockSize;\n              dataOffsets.push(currentOffset);\n            }\n            for (var i = 0; i < dataOffsets.length - 1; i++) {\n              var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n              content = data.buffer;\n              if (ele.attributes.type === 'Float32') {\n                content = new Float32Array(content);\n                txt = Float32Concat(txt, content);\n              } else if (ele.attributes.type === 'Int64') {\n                content = new Int32Array(content);\n                txt = Int32Concat(txt, content);\n              }\n            }\n            delete ele['#text'];\n            if (ele.attributes.type === 'Int64') {\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } else {\n            if (ele.attributes.format === 'binary' && !compressed) {\n              var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n              // [#bytes][DATA]\n              // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n              content = content.slice(numBytes).buffer;\n            } else {\n              if (ele['#text']) {\n                var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                  if (el !== '') return el;\n                });\n              } else {\n                var content = new Int32Array(0).buffer;\n              }\n            }\n            delete ele['#text']; // Get the content and optimize it\n\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array(content);\n            } else if (ele.attributes.type === 'Int32') {\n              var txt = new Int32Array(content);\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array(content);\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } // endif ( ele.attributes.format === 'binary' && compressed )\n\n          return txt;\n        } // Main part\n        // Get Dom\n\n        var dom = null;\n        if (window.DOMParser) {\n          try {\n            dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n          } catch (e) {\n            dom = null;\n          }\n        } else if (window.ActiveXObject) {\n          try {\n            dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n            dom.async = false;\n            if (!dom.loadXML()) {\n              throw new Error(dom.parseError.reason + dom.parseError.srcText);\n            }\n          } catch (e) {\n            dom = null;\n          }\n        } else {\n          throw new Error('Cannot parse xml string!');\n        } // Get the doc\n\n        var doc = dom.documentElement; // Convert to json\n\n        var json = xmlToJson(doc);\n        var points = [];\n        var normals = [];\n        var indices = [];\n        if (json.PolyData) {\n          var piece = json.PolyData.Piece;\n          var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n          // Loop through the sections\n\n          var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n          var sectionIndex = 0,\n            numberOfSections = sections.length;\n          while (sectionIndex < numberOfSections) {\n            var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n            if (section && section.DataArray) {\n              // Depending on the number of DataArrays\n              if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n                var arr = section.DataArray;\n              } else {\n                var arr = [section.DataArray];\n              }\n              var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n              while (dataArrayIndex < numberOfDataArrays) {\n                // Parse the DataArray\n                if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                  arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n                }\n                dataArrayIndex++;\n              }\n              switch (sections[sectionIndex]) {\n                // if iti is point data\n                case 'PointData':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  var normalsName = section.attributes.Normals;\n                  if (numberOfPoints > 0) {\n                    for (var i = 0, len = arr.length; i < len; i++) {\n                      if (normalsName === arr[i].attributes.Name) {\n                        var components = arr[i].attributes.NumberOfComponents;\n                        normals = new Float32Array(numberOfPoints * components);\n                        normals.set(arr[i].text, 0);\n                      }\n                    }\n                  }\n                  break;\n                // if it is points\n\n                case 'Points':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  if (numberOfPoints > 0) {\n                    var components = section.DataArray.attributes.NumberOfComponents;\n                    points = new Float32Array(numberOfPoints * components);\n                    points.set(section.DataArray.text, 0);\n                  }\n                  break;\n                // if it is strips\n\n                case 'Strips':\n                  var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n                  if (numberOfStrips > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfStrips + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                    var indicesIndex = 0;\n                    for (var i = 0, len = numberOfStrips; i < len; i++) {\n                      var strip = [];\n                      for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                        strip.push(connectivity[s]);\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                      for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                        if (j % 2) {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 2];\n                          indices[indicesIndex++] = strip[j + 1];\n                        } else {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 1];\n                          indices[indicesIndex++] = strip[j + 2];\n                        }\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                    }\n                  }\n                  break;\n                // if it is polys\n\n                case 'Polys':\n                  var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n                  if (numberOfPolys > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfPolys + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                    var indicesIndex = 0,\n                      connectivityIndex = 0;\n                    var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n                    while (i < len) {\n                      var poly = [];\n                      var s = 0,\n                        len1 = offset[i];\n                      while (s < len1 - len0) {\n                        poly.push(connectivity[connectivityIndex++]);\n                        s++;\n                      }\n                      var j = 1;\n                      while (j < len1 - len0 - 1) {\n                        indices[indicesIndex++] = poly[0];\n                        indices[indicesIndex++] = poly[j];\n                        indices[indicesIndex++] = poly[j + 1];\n                        j++;\n                      }\n                      i++;\n                      len0 = offset[i - 1];\n                    }\n                  }\n                  break;\n              }\n            }\n            sectionIndex++;\n          }\n          var geometry = new BufferGeometry();\n          geometry.setIndex(new BufferAttribute(indices, 1));\n          geometry.setAttribute('position', new BufferAttribute(points, 3));\n          if (normals.length === points.length) {\n            geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n          }\n          return geometry;\n        } else {\n          throw new Error('Unsupported DATASET type');\n        }\n      } // get the 5 first lines of the files to check if there is the key word binary\n\n      var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n      if (meta[0].indexOf('xml') !== -1) {\n        return parseXML(LoaderUtils.decodeText(data));\n      } else if (meta[2].includes('ASCII')) {\n        return parseASCII(LoaderUtils.decodeText(data));\n      } else {\n        return parseBinary(data);\n      }\n    }\n  }]);\n  return VTKLoader;\n}(Loader);\nexport { VTKLoader };","map":null,"metadata":{},"sourceType":"module"}