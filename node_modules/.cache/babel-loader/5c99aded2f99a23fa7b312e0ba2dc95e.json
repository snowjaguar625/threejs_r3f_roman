{"ast":null,"code":"import _get from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nvar boundingBox = /* @__PURE__ */new Box3();\nvar MeshBVHRootVisualizer = /*#__PURE__*/function (_Object3D) {\n  _inherits(MeshBVHRootVisualizer, _Object3D);\n  _createClass(MeshBVHRootVisualizer, [{\n    key: \"isMesh\",\n    get: function get() {\n      return !this.displayEdges;\n    }\n  }, {\n    key: \"isLineSegments\",\n    get: function get() {\n      return this.displayEdges;\n    }\n  }, {\n    key: \"isLine\",\n    get: function get() {\n      return this.displayEdges;\n    }\n  }]);\n  function MeshBVHRootVisualizer(mesh, material) {\n    var _this;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    var group = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck(this, MeshBVHRootVisualizer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MeshBVHRootVisualizer).call(this));\n    _this.material = material;\n    _this.geometry = new BufferGeometry();\n    _this.name = 'MeshBVHRootVisualizer';\n    _this.depth = depth;\n    _this.displayParents = false;\n    _this.mesh = mesh;\n    _this.displayEdges = true;\n    _this._group = group;\n    return _this;\n  }\n  _createClass(MeshBVHRootVisualizer, [{\n    key: \"raycast\",\n    value: function raycast() {}\n  }, {\n    key: \"update\",\n    value: function update() {\n      var geometry = this.geometry;\n      var boundsTree = this.mesh.geometry.boundsTree;\n      var group = this._group;\n      geometry.dispose();\n      this.visible = false;\n      if (boundsTree) {\n        // count the number of bounds required\n        var targetDepth = this.depth - 1;\n        var displayParents = this.displayParents;\n        var boundsCount = 0;\n        boundsTree.traverse(function (depth, isLeaf) {\n          if (depth === targetDepth || isLeaf) {\n            boundsCount++;\n            return true;\n          } else if (displayParents) {\n            boundsCount++;\n          }\n        }, group);\n\n        // fill in the position buffer with the bounds corners\n        var posIndex = 0;\n        var positionArray = new Float32Array(8 * 3 * boundsCount);\n        boundsTree.traverse(function (depth, isLeaf, boundingData) {\n          var terminate = depth === targetDepth || isLeaf;\n          if (terminate || displayParents) {\n            arrayToBox(0, boundingData, boundingBox);\n            var min = boundingBox.min,\n              max = boundingBox.max;\n            for (var x = -1; x <= 1; x += 2) {\n              var xVal = x < 0 ? min.x : max.x;\n              for (var y = -1; y <= 1; y += 2) {\n                var yVal = y < 0 ? min.y : max.y;\n                for (var z = -1; z <= 1; z += 2) {\n                  var zVal = z < 0 ? min.z : max.z;\n                  positionArray[posIndex + 0] = xVal;\n                  positionArray[posIndex + 1] = yVal;\n                  positionArray[posIndex + 2] = zVal;\n                  posIndex += 3;\n                }\n              }\n            }\n            return terminate;\n          }\n        }, group);\n        var indexArray;\n        var indices;\n        if (this.displayEdges) {\n          // fill in the index buffer to point to the corner points\n          indices = new Uint8Array([\n          // x axis\n          0, 4, 1, 5, 2, 6, 3, 7,\n          // y axis\n          0, 2, 1, 3, 4, 6, 5, 7,\n          // z axis\n          0, 1, 2, 3, 4, 5, 6, 7]);\n        } else {\n          indices = new Uint8Array([\n          // X-, X+\n          0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5,\n          // Y-, Y+\n          1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6,\n          // Z-, Z+\n          0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]);\n        }\n        if (positionArray.length > 65535) {\n          indexArray = new Uint32Array(indices.length * boundsCount);\n        } else {\n          indexArray = new Uint16Array(indices.length * boundsCount);\n        }\n        var indexLength = indices.length;\n        for (var i = 0; i < boundsCount; i++) {\n          var posOffset = i * 8;\n          var indexOffset = i * indexLength;\n          for (var j = 0; j < indexLength; j++) {\n            indexArray[indexOffset + j] = posOffset + indices[j];\n          }\n        }\n\n        // update the geometry\n        geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n        geometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n        this.visible = true;\n      }\n    }\n  }]);\n  return MeshBVHRootVisualizer;\n}(Object3D);\nvar MeshBVHVisualizer = /*#__PURE__*/function (_Group) {\n  _inherits(MeshBVHVisualizer, _Group);\n  _createClass(MeshBVHVisualizer, [{\n    key: \"color\",\n    get: function get() {\n      return this.edgeMaterial.color;\n    }\n  }, {\n    key: \"opacity\",\n    get: function get() {\n      return this.edgeMaterial.opacity;\n    },\n    set: function set(v) {\n      this.edgeMaterial.opacity = v;\n      this.meshMaterial.opacity = v;\n    }\n  }]);\n  function MeshBVHVisualizer(mesh) {\n    var _this2;\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    _classCallCheck(this, MeshBVHVisualizer);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MeshBVHVisualizer).call(this));\n    _this2.name = 'MeshBVHVisualizer';\n    _this2.depth = depth;\n    _this2.mesh = mesh;\n    _this2.displayParents = false;\n    _this2.displayEdges = true;\n    _this2._roots = [];\n    var edgeMaterial = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    var meshMaterial = new MeshBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    _this2.edgeMaterial = edgeMaterial;\n    _this2.meshMaterial = meshMaterial;\n    _this2.update();\n    return _this2;\n  }\n  _createClass(MeshBVHVisualizer, [{\n    key: \"update\",\n    value: function update() {\n      var bvh = this.mesh.geometry.boundsTree;\n      var totalRoots = bvh ? bvh._roots.length : 0;\n      while (this._roots.length > totalRoots) {\n        var root = this._roots.pop();\n        root.geometry.dispose();\n        this.remove(root);\n      }\n      for (var i = 0; i < totalRoots; i++) {\n        if (i >= this._roots.length) {\n          var _root2 = new MeshBVHRootVisualizer(this.mesh, this.edgeMaterial, this.depth, i);\n          this.add(_root2);\n          this._roots.push(_root2);\n        }\n        var _root = this._roots[i];\n        _root.depth = this.depth;\n        _root.mesh = this.mesh;\n        _root.displayParents = this.displayParents;\n        _root.displayEdges = this.displayEdges;\n        _root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n        _root.update();\n      }\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld() {\n      var _get2;\n      this.position.copy(this.mesh.position);\n      this.rotation.copy(this.mesh.rotation);\n      this.scale.copy(this.mesh.scale);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_get2 = _get(_getPrototypeOf(MeshBVHVisualizer.prototype), \"updateMatrixWorld\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.depth = source.depth;\n      this.mesh = source.mesh;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new MeshBVHVisualizer(this.mesh, this.depth);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.edgeMaterial.dispose();\n      this.meshMaterial.dispose();\n      var children = this.children;\n      for (var i = 0, l = children.length; i < l; i++) {\n        children[i].geometry.dispose();\n      }\n    }\n  }]);\n  return MeshBVHVisualizer;\n}(Group);\nexport { MeshBVHVisualizer };","map":null,"metadata":{},"sourceType":"module"}