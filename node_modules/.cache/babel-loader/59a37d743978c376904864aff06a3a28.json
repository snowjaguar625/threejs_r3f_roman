{"ast":null,"code":"import { Vector3 } from 'three';\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nvar hilbert2D = function hilbert2D() {\n  var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 0);\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var v0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var v1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var v2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;\n  var v3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 3;\n  // Default Vars\n  var half = size / 2;\n  var vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\nvar hilbert3D = function hilbert3D() {\n  var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 0);\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var v0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var v1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var v2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;\n  var v3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 3;\n  var v4 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 4;\n  var v5 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 5;\n  var v6 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 6;\n  var v7 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 7;\n  // Default Vars\n  var half = size / 2;\n  var vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\nvar gosper = function gosper() {\n  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  function fractalize(config) {\n    var output = '';\n    var input = config.axiom;\n    for (var i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n      for (var j = 0, jl = input.length; j < jl; j++) {\n        var char = input[j];\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n      input = output;\n    }\n    return output;\n  }\n  function toPoints(config) {\n    var currX = 0;\n    var currY = 0;\n    var angle = 0;\n    var path = [0, 0, 0];\n    var fractal = config.fractal;\n    for (var i = 0, l = fractal.length; i < l; i++) {\n      var char = fractal[i];\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n    return path;\n  } //\n\n  var gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  var points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n  });\n\n  return points;\n};\nvar GeometryUtils = {\n  hilbert3D: hilbert3D,\n  gosper: gosper,\n  hilbert2D: hilbert2D\n};\nexport { GeometryUtils };","map":null,"metadata":{},"sourceType":"module"}