{"ast":null,"code":"import { LoaderUtils } from 'three';\nimport { LWO2Parser } from './LWO2Parser.js';\nimport { LWO3Parser } from './LWO3Parser.js';\n\n/**\n * === IFFParser ===\n * - Parses data from the IFF buffer.\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n *\n * ATOMIC DATA TYPES\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n *  float, 4 byte length: F4\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n *\n * COMPOUND DATA TYPES\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n *  Color (RGB): F4 + F4 + F4: COL12\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n *  Angle in radian F4: ANG4\n *  Filename (string) S0: FNAM0\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n *\n *  The IFF file is arranged in chunks:\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n *\n * COMPOUND DATA TYPES\n * - Chunks are combined in Forms (collections of chunks)\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n * - CHUNKS and FORMS are collectively referred to as blocks\n * - The entire file is contained in one top level FORM\n *\n **/\n\nfunction IFFParser() {\n  this.debugger = new Debugger(); // this.debugger.enable(); // un-comment to log IFF hierarchy.\n}\n\nIFFParser.prototype = {\n  constructor: IFFParser,\n  parse: function parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    }; // start out at the top level to add any data before first layer is encountered\n\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === undefined) return;\n    if (this.tree.format === 'LWO2') {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile()) {\n        this.parser.parseBlock();\n      }\n    } else if (this.tree.format === 'LWO3') {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile()) {\n        this.parser.parseBlock();\n      }\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  },\n  parseTopForm: function parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== 'FORM') {\n      console.warn('LWOLoader: Top-level FORM missing.');\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === 'LWO2') {\n      this.tree.format = type;\n    } else if (type === 'LWO3') {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  },\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm: function parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      // SKIPPED FORMS\n      // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n      case 'ISEQ': // Image sequence\n\n      case 'ANIM': // plug in animation\n\n      case 'STCC': // Color-cycling Still\n\n      case 'VPVL':\n      case 'VPRM':\n      case 'NROT':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n\n      case 'WRPH': // image wrap h\n\n      case 'FUNC':\n      case 'FALL':\n      case 'OPAC':\n      case 'GRAD': // gradient texture\n\n      case 'ENVS':\n      case 'VMOP':\n      case 'VMBG': // Car Material FORMS\n\n      case 'OMAX':\n      case 'STEX':\n      case 'CKBG':\n      case 'CKEY':\n      case 'VMLA':\n      case 'VMLB':\n        this.debugger.skipped = true;\n        this.skipForm(length); // not currently supported\n\n        break;\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n\n      case 'META':\n      case 'NNDS':\n      case 'NODS':\n      case 'NDTA':\n      case 'ADAT':\n      case 'AOVS':\n      case 'BLOK': // used by texture nodes\n\n      case 'IBGC': // imageBackgroundColor\n\n      case 'IOPC': // imageOpacity\n\n      case 'IIMG': // hold reference to image path\n\n      case 'TXTR':\n        // this.setupForm( type, length );\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case 'IFAL': // imageFallof\n\n      case 'ISCL': // imageScale\n\n      case 'IPOS': // imagePosition\n\n      case 'IROT': // imageRotation\n\n      case 'IBMP':\n      case 'IUTD':\n      case 'IVTD':\n        this.parseTextureNodeAttribute(type);\n        break;\n      case 'ENVL':\n        this.parseEnvelope(length);\n        break;\n      // CLIP FORM AND SUB FORMS\n\n      case 'CLIP':\n        if (this.tree.format === 'LWO2') {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case 'STIL':\n        this.parseImage();\n        break;\n      case 'XREF':\n        // clone of another STIL\n        this.reader.skip(8); // unknown\n\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString() // internal unique ref\n        };\n\n        break;\n      // Not in spec, used by texture nodes\n\n      case 'IMST':\n        this.parseImageStateForm(length);\n        break;\n      // SURF FORM AND SUB FORMS\n\n      case 'SURF':\n        this.parseSurfaceForm(length);\n        break;\n      case 'VALU':\n        // Not in spec\n        this.parseValueForm(length);\n        break;\n      case 'NTAG':\n        this.parseSubNode(length);\n        break;\n      case 'ATTR': // BSDF Node Attributes\n\n      case 'SATR':\n        // Standard Node Attributes\n        this.setupForm('attributes', length);\n        break;\n      case 'NCON':\n        this.parseConnections(length);\n        break;\n      case 'SSHA':\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm('surfaceShader', length);\n        break;\n      case 'SSHD':\n        this.setupForm('surfaceShaderData', length);\n        break;\n      case 'ENTR':\n        // Not in spec\n        this.parseEntryForm(length);\n        break;\n      // Image Map Layer\n\n      case 'IMAP':\n        this.parseImageMap(length);\n        break;\n      case 'TAMP':\n        this.parseXVAL('amplitude', length);\n        break;\n      //Texture Mapping Form\n\n      case 'TMAP':\n        this.setupForm('textureMap', length);\n        break;\n      case 'CNTR':\n        this.parseXVAL3('center', length);\n        break;\n      case 'SIZE':\n        this.parseXVAL3('scale', length);\n        break;\n      case 'ROTA':\n        this.parseXVAL3('rotation', length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  },\n  setupForm: function setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      // should never see this unless there's a bug in the reader\n      console.warn('LWOLoader: form already exists on parent: ', type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  },\n  skipForm: function skipForm(length) {\n    this.reader.skip(length - 4);\n  },\n  parseUnknownForm: function parseUnknownForm(type, length) {\n    console.warn('LWOLoader: unknown FORM encountered: ' + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  },\n  parseSurfaceForm: function parseSurfaceForm(length) {\n    this.reader.skip(8); // unknown Uint32 x2\n\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  },\n  parseSurfaceLwo2: function parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  },\n  parseSubNode: function parseSubNode(length) {\n    // parse the NRNM CHUNK of the subnode FORM to get\n    // a meaningful name for the subNode\n    // some subnodes can be renamed, but Input and Surface cannot\n    this.reader.skip(8); // NRNM + length\n\n    var name = this.reader.getString();\n    var node = {\n      name: name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  },\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections: function parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  },\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm: function parseEntryForm(length) {\n    this.reader.skip(8); // NAME + length\n\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  },\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm: function parseValueForm() {\n    this.reader.skip(8); // unknown + length\n\n    var valueType = this.reader.getString();\n    if (valueType === 'double') {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === 'int') {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === 'vparam') {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === 'vparam3') {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  },\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm: function parseImageStateForm() {\n    this.reader.skip(8); // unknown\n\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  },\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap: function parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps) this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10); // unknown, could be an issue if it contains a VX\n  },\n  parseTextureNodeAttribute: function parseTextureNodeAttribute(type) {\n    this.reader.skip(28); // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n    this.reader.skip(20); // FORM + length + VPVL + float32 + Uint32\n\n    switch (type) {\n      case 'ISCL':\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case 'IPOS':\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case 'IROT':\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case 'IFAL':\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case 'IBMP':\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case 'IUTD':\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case 'IVTD':\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2); // unknown\n  },\n  // ENVL forms are currently ignored\n  parseEnvelope: function parseEnvelope(length) {\n    this.reader.skip(length - 4); // skipping  entirely for now\n  },\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip: function parseClip(length) {\n    var tag = this.reader.getIDTag(); // inside surface node\n\n    if (tag === 'FORM') {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    } // otherwise top level\n\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8); // unknown\n\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  },\n  parseClipLwo2: function parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: ''\n    }; // seach STIL block\n\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === 'STIL') {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  },\n  parseImage: function parseImage() {\n    this.reader.skip(8); // unknown\n\n    this.currentForm.fileName = this.reader.getString();\n  },\n  parseXVAL: function parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset); // set end offset directly to skip optional envelope\n  },\n  parseXVAL3: function parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  },\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag: function parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  },\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer: function parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n    // if we have not reached then end of the layer block, there must be a parent defined\n\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1; // omitted or -1 for no parent\n  },\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints: function parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      // z -> -z to match three.js right handed coords\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  },\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping: function parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n      this.currentForm.UVChannel = channelName;\n      return;\n    } // otherwise reset to initial length and parse normal VMAP CHUNK\n\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16(); // dimension\n\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case 'TXUV':\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case 'MORF':\n      case 'SPOT':\n        this.parseMorphTargets(name, finalOffset, type); // can't be discontinuous\n\n        break;\n      // unsupported VMAPs\n\n      case 'APSL':\n      case 'NORM':\n      case 'WGHT':\n      case 'MNVW':\n      case 'PICK':\n      case 'RGB ':\n      case 'RGBA':\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn('LWOLoader: unknown vertex map type: ' + type);\n        this.reader.skip(remainingLength);\n    }\n  },\n  parseUVMapping: function parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices: uvIndices,\n        polyIndices: polyIndices,\n        uvs: uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices: uvIndices,\n        uvs: uvs\n      };\n    }\n  },\n  parseMorphTargets: function parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === 'MORF' ? 'relative' : 'absolute';\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex()); // z -> -z to match three.js right handed coords\n\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices: indices,\n      points: points,\n      type: type\n    };\n  },\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList: function parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = []; // hold a list of polygon sizes, to be split up later\n\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16(); //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n\n      numverts = numverts & 1023; // remaining ten low order bits are vertex num\n\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++) {\n        indices.push(this.reader.getVariableLengthIndex());\n      }\n    }\n    var geometryData = {\n      type: type,\n      vertexIndices: indices,\n      polygonDimensions: polygonDimensions,\n      points: this.currentPoints\n    }; // Note: assuming that all polys will be lines or points if the first is\n\n    if (polygonDimensions[0] === 1) geometryData.type = 'points';else if (polygonDimensions[0] === 2) geometryData.type = 'lines';\n    this.currentLayer.geometry = geometryData;\n  },\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings: function parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  },\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping: function parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === 'SURF') {\n      this.parseMaterialIndices(finalOffset);\n    } else {\n      //PART, SMGP, COLR not supported\n      this.reader.skip(length - 4);\n    }\n  },\n  parseMaterialIndices: function parseMaterialIndices(finalOffset) {\n    // array holds polygon index followed by material index\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  },\n  parseUnknownCHUNK: function parseUnknownCHUNK(blockID, length) {\n    console.warn('LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length); // print the chunk plus some bytes padding either side\n    // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n};\nfunction DataViewReader(buffer) {\n  this.dv = new DataView(buffer);\n  this.offset = 0;\n}\nDataViewReader.prototype = {\n  constructor: DataViewReader,\n  size: function size() {\n    return this.dv.buffer.byteLength;\n  },\n  setOffset: function setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error('LWOLoader: invalid buffer offset');\n    }\n  },\n  endOfFile: function endOfFile() {\n    if (this.offset >= this.size()) return true;\n    return false;\n  },\n  skip: function skip(length) {\n    this.offset += length;\n  },\n  getUint8: function getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  },\n  getUint16: function getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  },\n  getInt32: function getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  },\n  getUint32: function getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  },\n  getUint64: function getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 0x100000000 + low;\n  },\n  getFloat32: function getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  },\n  getFloat32Array: function getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  },\n  getFloat64: function getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  },\n  getFloat64Array: function getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  },\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex: function getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  },\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag: function getIDTag() {\n    return this.getString(4);\n  },\n  getString: function getString(size) {\n    if (size === 0) return; // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\n    var a = [];\n    if (size) {\n      for (var i = 0; i < size; i++) {\n        a[i] = this.getUint8();\n      }\n    } else {\n      var currentChar;\n      var len = 0;\n      while (currentChar !== 0) {\n        currentChar = this.getUint8();\n        if (currentChar !== 0) a.push(currentChar);\n        len++;\n      }\n      if (!isEven(len + 1)) this.getUint8(); // if string with terminating nullbyte is uneven, extra nullbyte is added\n    }\n\n    return LoaderUtils.decodeText(new Uint8Array(a));\n  },\n  getStringArray: function getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split('\\0');\n    return a.filter(Boolean); // return array with any empty strings removed\n  }\n}; // ************** DEBUGGER  **************\n\nfunction Debugger() {\n  this.active = false;\n  this.depth = 0;\n  this.formList = [];\n}\nDebugger.prototype = {\n  constructor: Debugger,\n  enable: function enable() {\n    this.active = true;\n  },\n  log: function log() {\n    if (!this.active) return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = 'FORM';\n        break;\n      case 1:\n        nodeType = 'CHK';\n        break;\n      case 2:\n        nodeType = 'S-CHK';\n        break;\n    }\n    console.log('| '.repeat(this.depth) + nodeType, this.nodeID, \"( \".concat(this.offset, \" ) -> ( \").concat(this.dataOffset + this.length, \" )\"), this.node == 0 ? ' {' : '', this.skipped ? 'SKIPPED' : '', this.node == 0 && this.skipped ? '}' : '');\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  },\n  closeForms: function closeForms() {\n    if (!this.active) return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log('| '.repeat(this.depth) + '}');\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}; // ************** UTILITY FUNCTIONS **************\n\nfunction isEven(num) {\n  return num % 2;\n} // calculate the length of the string in the buffer\n// this will be string.length + nullbyte + optional padbyte to make the length even\n\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n} // for testing purposes, dump buffer to console\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\n\nfunction printBuffer(buffer, from, to) {\n  console.log(LoaderUtils.decodeText(new Uint8Array(buffer, from, to)));\n}\nexport { IFFParser };","map":null,"metadata":{},"sourceType":"module"}