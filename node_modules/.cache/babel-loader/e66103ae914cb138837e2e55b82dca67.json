{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport { useThree, useFrame, createPortal } from '@react-three/fiber';\nimport { Object3D, Matrix4, Quaternion, Vector3, Scene } from 'three';\nimport { OrthographicCamera } from './OrthographicCamera.js';\nimport { useCamera } from './useCamera.js';\nvar Context = /*#__PURE__*/React.createContext({});\nvar useGizmoContext = function useGizmoContext() {\n  return React.useContext(Context);\n};\nvar turnRate = 2 * Math.PI; // turn rate in angles per second\n\nvar dummy = new Object3D();\nvar matrix = new Matrix4();\nvar q1 = new Quaternion(),\n  q2 = new Quaternion();\nvar target = new Vector3();\nvar targetPosition = new Vector3();\nvar GizmoHelper = function GizmoHelper(_ref) {\n  var _ref$alignment = _ref.alignment,\n    alignment = _ref$alignment === void 0 ? 'bottom-right' : _ref$alignment,\n    _ref$margin = _ref.margin,\n    margin = _ref$margin === void 0 ? [80, 80] : _ref$margin,\n    _ref$renderPriority = _ref.renderPriority,\n    renderPriority = _ref$renderPriority === void 0 ? 0 : _ref$renderPriority,\n    onUpdate = _ref.onUpdate,\n    onTarget = _ref.onTarget,\n    GizmoHelperComponent = _ref.children;\n  var size = useThree(function (_ref2) {\n    var size = _ref2.size;\n    return size;\n  });\n  var mainCamera = useThree(function (_ref3) {\n    var camera = _ref3.camera;\n    return camera;\n  }); // @ts-expect-error new in @react-three/fiber@7.0.5\n\n  var defaultControls = useThree(function (_ref4) {\n    var controls = _ref4.controls;\n    return controls;\n  });\n  var gl = useThree(function (_ref5) {\n    var gl = _ref5.gl;\n    return gl;\n  });\n  var scene = useThree(function (_ref6) {\n    var scene = _ref6.scene;\n    return scene;\n  });\n  var invalidate = useThree(function (_ref7) {\n    var invalidate = _ref7.invalidate;\n    return invalidate;\n  });\n  var backgroundRef = React.useRef();\n  var gizmoRef = React.useRef();\n  var virtualCam = React.useRef(null);\n  var _React$useState = React.useState(function () {\n      return new Scene();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    virtualScene = _React$useState2[0];\n  var animating = React.useRef(false);\n  var radius = React.useRef(0);\n  var focusPoint = React.useRef(new Vector3(0, 0, 0));\n  var tweenCamera = function tweenCamera(direction) {\n    animating.current = true;\n    if (defaultControls || onTarget) focusPoint.current = (defaultControls == null ? void 0 : defaultControls.target) || (onTarget == null ? void 0 : onTarget());\n    radius.current = mainCamera.position.distanceTo(target); // Rotate from current camera orientation\n\n    q1.copy(mainCamera.quaternion); // To new current camera orientation\n\n    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);\n    dummy.lookAt(targetPosition);\n    q2.copy(dummy.quaternion);\n    invalidate();\n  };\n  var animateStep = function animateStep(delta) {\n    if (!animating.current) return;\n    if (q1.angleTo(q2) < 0.01) {\n      animating.current = false;\n      return;\n    }\n    var step = delta * turnRate; // animate position by doing a slerp and then scaling the position on the unit sphere\n\n    q1.rotateTowards(q2, step); // animate orientation\n\n    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current);\n    mainCamera.up.set(0, 1, 0).applyQuaternion(q1).normalize();\n    mainCamera.quaternion.copy(q1);\n    if (onUpdate) onUpdate();else if (defaultControls) defaultControls.update();\n    invalidate();\n  };\n  React.useEffect(function () {\n    if (scene.background) {\n      //Interchange the actual scene background with the virtual scene\n      backgroundRef.current = scene.background;\n      scene.background = null;\n      virtualScene.background = backgroundRef.current;\n    }\n    return function () {\n      // reset on unmount\n      if (backgroundRef.current) {\n        scene.background = backgroundRef.current;\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var beforeRender = function beforeRender() {\n    var _gizmoRef$current;\n\n    // Sync gizmo with main camera orientation\n    matrix.copy(mainCamera.matrix).invert();\n    (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);\n  };\n  useFrame(function (_, delta) {\n    if (virtualCam.current && gizmoRef.current) {\n      animateStep(delta);\n      beforeRender();\n      gl.autoClear = false;\n      gl.clearDepth();\n      gl.render(virtualScene, virtualCam.current);\n    }\n  }, renderPriority);\n  var gizmoHelperContext = {\n    tweenCamera: tweenCamera,\n    raycast: useCamera(virtualCam)\n  }; // Position gizmo component within scene\n  var _margin = _slicedToArray(margin, 2),\n    marginX = _margin[0],\n    marginY = _margin[1];\n  var x = alignment.endsWith('-left') ? -size.width / 2 + marginX : size.width / 2 - marginX;\n  var y = alignment.startsWith('top-') ? size.height / 2 - marginY : -size.height / 2 + marginY;\n  return createPortal( /*#__PURE__*/React.createElement(Context.Provider, {\n    value: gizmoHelperContext\n  }, /*#__PURE__*/React.createElement(OrthographicCamera, {\n    ref: virtualCam,\n    makeDefault: false,\n    position: [0, 0, 200]\n  }), /*#__PURE__*/React.createElement(\"group\", {\n    ref: gizmoRef,\n    position: [x, y, 0]\n  }, GizmoHelperComponent)), virtualScene);\n};\nexport { GizmoHelper, useGizmoContext };","map":null,"metadata":{},"sourceType":"module"}