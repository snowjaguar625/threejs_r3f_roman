{"ast":null,"code":"import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\nvar boundingBox = new Box3();\nvar boxIntersection = new Vector3();\nvar xyzFields = ['x', 'y', 'z'];\nexport function raycast(nodeIndex32, geometry, side, ray, intersects) {\n  var nodeIndex16 = nodeIndex32 * 2,\n    float32Array = _float32Array,\n    uint16Array = _uint16Array,\n    uint32Array = _uint32Array;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    intersectTris(geometry, side, ray, offset, count, intersects);\n  } else {\n    var leftIndex = LEFT_NODE(nodeIndex32);\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, geometry, side, ray, intersects);\n    }\n    var rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, geometry, side, ray, intersects);\n    }\n  }\n}\nexport function raycastFirst(nodeIndex32, geometry, side, ray) {\n  var nodeIndex16 = nodeIndex32 * 2,\n    float32Array = _float32Array,\n    uint16Array = _uint16Array,\n    uint32Array = _uint32Array;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    return intersectClosestTri(geometry, side, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    var xyzAxis = xyzFields[splitAxis];\n    var rayDir = ray.direction[xyzAxis];\n    var leftToRight = rayDir >= 0;\n\n    // c1 is the child to check first\n    var c1, c2;\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n    var c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    var c1Result = c1Intersection ? raycastFirst(c1, geometry, side, ray) : null;\n\n    // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n    if (c1Result) {\n      // check if the point is within the second bounds\n      // \"point\" is in the local frame of the bvh\n      var point = c1Result.point[xyzAxis];\n      var isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] :\n      // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    }\n\n    // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n    var c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    var c2Result = c2Intersection ? raycastFirst(c2, geometry, side, ray) : null;\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nexport var shapecast = function () {\n  var _box1, _box2;\n  var boxStack = [];\n  var boxPool = new PrimitivePool(function () {\n    return new Box3();\n  });\n  return function shapecast() {\n    _box1 = boxPool.getPrimitive();\n    _box2 = boxPool.getPrimitive();\n    boxStack.push(_box1, _box2);\n    var result = shapecastTraverse.apply(void 0, arguments);\n    boxPool.releasePrimitive(_box1);\n    boxPool.releasePrimitive(_box2);\n    boxStack.pop();\n    boxStack.pop();\n    var length = boxStack.length;\n    if (length > 0) {\n      _box2 = boxStack[length - 1];\n      _box1 = boxStack[length - 2];\n    }\n    return result;\n  };\n  function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n    var nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      var nodeIndex16 = nodeIndex32 * 2,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n      return OFFSET(nodeIndex32, uint32Array);\n    }\n    function getRightEndOffset(nodeIndex32) {\n      var nodeIndex16 = nodeIndex32 * 2,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      // return the end offset of the triangle range\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    }\n    var nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n    if (isLeaf) {\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var count = COUNT(nodeIndex16, uint16Array);\n      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n    } else {\n      var left = LEFT_NODE(nodeIndex32);\n      var right = RIGHT_NODE(nodeIndex32, uint32Array);\n      var c1 = left;\n      var c2 = right;\n      var score1, score2;\n      var box1, box2;\n      if (nodeScoreFunc) {\n        box1 = _box1;\n        box2 = _box2;\n\n        // bounding data is not offset\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n        arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          var temp = score1;\n          score1 = score2;\n          score2 = temp;\n          box1 = box2;\n          // box2 is always set before use below\n        }\n      }\n\n      // Check box 1 intersection\n      if (!box1) {\n        box1 = _box1;\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      }\n      var isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n      var c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      var c1StopTraversal;\n      if (c1Intersection === CONTAINED) {\n        var _offset = getLeftOffset(c1);\n        var end = getRightEndOffset(c1);\n        var _count = end - _offset;\n        c1StopTraversal = intersectsRangeFunc(_offset, _count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n      if (c1StopTraversal) return true;\n\n      // Check box 2 intersection\n      // cached box2 will have been overwritten by previous traversal\n      box2 = _box2;\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      var isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n      var c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      var c2StopTraversal;\n      if (c2Intersection === CONTAINED) {\n        var _offset2 = getLeftOffset(c2);\n        var _end = getRightEndOffset(c2);\n        var _count2 = _end - _offset2;\n        c2StopTraversal = intersectsRangeFunc(_offset2, _count2, true, depth + 1, nodeIndexByteOffset + c2, box2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n      if (c2StopTraversal) return true;\n      return false;\n    }\n  }\n}();\nexport var intersectsGeometry = function () {\n  var triangle = new ExtendedTriangle();\n  var triangle2 = new ExtendedTriangle();\n  var invertedMat = new Matrix4();\n  var obb = new OrientedBox();\n  var obb2 = new OrientedBox();\n  return function intersectsGeometry(nodeIndex32, geometry, otherGeometry, geometryToBvh) {\n    var cachedObb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      cachedObb = obb;\n    }\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n    if (isLeaf) {\n      var thisGeometry = geometry;\n      var thisIndex = thisGeometry.index;\n      var thisPos = thisGeometry.attributes.position;\n      var index = otherGeometry.index;\n      var pos = otherGeometry.attributes.position;\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var count = COUNT(nodeIndex16, uint16Array);\n\n      // get the inverse of the geometry matrix so we can transform our triangles into the\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\n      // here.\n      invertedMat.copy(geometryToBvh).invert();\n      if (otherGeometry.boundsTree) {\n        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n        obb2.matrix.copy(invertedMat);\n        obb2.needsUpdate = true;\n        var res = otherGeometry.boundsTree.shapecast({\n          intersectsBounds: function intersectsBounds(box) {\n            return obb2.intersectsBox(box);\n          },\n          intersectsTriangle: function intersectsTriangle(tri) {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.needsUpdate = true;\n            for (var i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              // this triangle needs to be transformed into the current BVH coordinate frame\n              setTriangle(triangle2, i, thisIndex, thisPos);\n              triangle2.needsUpdate = true;\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n            return false;\n          }\n        });\n        return res;\n      } else {\n        for (var i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          // this triangle needs to be transformed into the current BVH coordinate frame\n          setTriangle(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.needsUpdate = true;\n          for (var i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, index, pos);\n            triangle2.needsUpdate = true;\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      var left = nodeIndex32 + 8;\n      var right = uint32Array[nodeIndex32 + 6];\n      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n      var leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection) return true;\n      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n      var rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection) return true;\n      return false;\n    }\n  };\n}();\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  arrayToBox(nodeIndex32, array, boundingBox);\n  return ray.intersectBox(boundingBox, target);\n}\nvar bufferStack = [];\nvar _prevBuffer;\nvar _float32Array;\nvar _uint16Array;\nvar _uint32Array;\nexport function setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\nexport function clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}","map":null,"metadata":{},"sourceType":"module"}