{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\nvar _start = new Vector3();\nvar _end = new Vector3();\nvar _start4 = new Vector4();\nvar _end4 = new Vector4();\nvar _ssOrigin = new Vector4();\nvar _ssOrigin3 = new Vector3();\nvar _mvMatrix = new Matrix4();\nvar _line = new Line3();\nvar _closestPoint = new Vector3();\nvar _box = new Box3();\nvar _sphere = new Sphere();\nvar _clipToWorldVector = new Vector4();\nvar _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (var i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n    var pointOnLine = new Vector3();\n    var point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    var isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  var projectionMatrix = camera.projectionMatrix;\n  var material = lineSegments.material;\n  var resolution = material.resolution;\n  var matrixWorld = lineSegments.matrixWorld;\n  var geometry = lineSegments.geometry;\n  var instanceStart = geometry.attributes.instanceStart;\n  var instanceEnd = geometry.attributes.instanceEnd;\n  var near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (var i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n    var isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n    if (_start4.z > near) {\n      var deltaDist = _start4.z - _end4.z;\n      var t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      var _deltaDist = _end4.z - _start4.z;\n      var _t = (_end4.z - near) / _deltaDist;\n      _end4.lerp(_start4, _t);\n    } // clip space\n\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0; // get closest point on ray to segment\n\n    var param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n    var zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    var isInClipSpace = zPos >= -1 && zPos <= 1;\n    var isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      var pointOnLine = new Vector3();\n      var point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nvar LineSegments2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(LineSegments2, _Mesh);\n  function LineSegments2() {\n    var _this;\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 0xffffff\n    });\n    _classCallCheck(this, LineSegments2);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineSegments2).call(this, geometry, material));\n    _this.isLineSegments2 = true;\n    _this.type = 'LineSegments2';\n    return _this;\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  _createClass(LineSegments2, [{\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.count);\n      for (var i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        _start.fromBufferAttribute(instanceStart, i);\n        _end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n      }\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var worldUnits = this.material.worldUnits;\n      var camera = raycaster.camera;\n      if (camera === null && !worldUnits) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n      }\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      _ray = raycaster.ray;\n      var matrixWorld = this.matrixWorld;\n      var geometry = this.geometry;\n      var material = this.material;\n      _lineWidth = material.linewidth + threshold;\n      _instanceStart = geometry.attributes.instanceStart;\n      _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n      if (geometry.boundingSphere === null) {\n        geometry.computeBoundingSphere();\n      }\n      _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n      var sphereMargin;\n      if (worldUnits) {\n        sphereMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n        sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n      }\n      _sphere.radius += sphereMargin;\n      if (_ray.intersectsSphere(_sphere) === false) {\n        return;\n      } // check if we intersect the box bounds\n\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n      _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n      var boxMargin;\n      if (worldUnits) {\n        boxMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n        boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n      }\n      _box.expandByScalar(boxMargin);\n      if (_ray.intersectsBox(_box) === false) {\n        return;\n      }\n      if (worldUnits) {\n        raycastWorldUnits(this, intersects);\n      } else {\n        raycastScreenSpace(this, camera, intersects);\n      }\n    }\n  }]);\n  return LineSegments2;\n}(Mesh);\nexport { LineSegments2 };","map":null,"metadata":{},"sourceType":"module"}