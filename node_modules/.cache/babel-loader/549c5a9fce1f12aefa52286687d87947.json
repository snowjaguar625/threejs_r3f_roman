{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\nimport { SimplexNoise } from '../math/SimplexNoise.js';\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\nvar LightningStrike = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(LightningStrike, _BufferGeometry);\n  function LightningStrike(rayParameters) {\n    var _this;\n    _classCallCheck(this, LightningStrike);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LightningStrike).call(this));\n    _this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\n\n    rayParameters = rayParameters || {};\n    _this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\n\n    _this.createMesh();\n    return _this;\n  }\n  _createClass(LightningStrike, [{\n    key: \"update\",\n    value: function update(time) {\n      if (this.isStatic) return;\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = LightningStrike.RAY_STEADY;\n        }\n        this.visible = true;\n      } else {\n        this.visible = false;\n        if (time < this.rayParameters.birthTime) {\n          this.state = LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init(rayParameters) {\n      // Init all the state from the parameters\n      this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\n\n      this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs; // Random generator\n\n      if (rayParameters.randomGenerator !== undefined) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n        if (rayParameters.noiseSeed !== undefined) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      } // Ray creation callbacks\n\n      if (rayParameters.onDecideSubrayCreation !== undefined) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n        if (rayParameters.onSubrayCreation !== undefined) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      } // Internal state\n\n      this.state = LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n      for (var i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n      this.raySegments = [];\n      for (var _i = 0; _i < this.maxRaySegments; _i++) {\n        this.raySegments.push(this.createSegment());\n      }\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new SimplexNoise(this.seedGenerator);\n      this.simplexY = new SimplexNoise(this.seedGenerator);\n      this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\n\n      this.forwards = new Vector3();\n      this.forwardsFill = new Vector3();\n      this.side = new Vector3();\n      this.down = new Vector3();\n      this.middlePos = new Vector3();\n      this.middleLinPos = new Vector3();\n      this.newPos = new Vector3();\n      this.vPos = new Vector3();\n      this.cross1 = new Vector3();\n    }\n  }, {\n    key: \"createMesh\",\n    value: function createMesh() {\n      var maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      var maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      var maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      } // Populate the mesh\n\n      this.fillMesh(0);\n      this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute('position', this.positionAttribute);\n      if (this.generateUVs) {\n        this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute('uv', this.uvsAttribute);\n      }\n      if (!this.isStatic) {\n        this.index.usage = DynamicDrawUsage;\n        this.positionAttribute.usage = DynamicDrawUsage;\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = DynamicDrawUsage;\n        }\n      } // Store buffers for later modification\n\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n  }, {\n    key: \"updateMesh\",\n    value: function updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"fillMesh\",\n    value: function fillMesh(time) {\n      var scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        var subray = scope.currentSubray;\n        if (time < subray.birthTime) {\n          //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          // Eternal rays don't propagate nor vanish, but its subrays do\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            // Ray propagation has arrived to this segment\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          // Ray is steady (nor propagating nor vanishing)\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            // Segment has not yet vanished\n            scope.createPrism(segment);\n          }\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n  }, {\n    key: \"addNewSubray\",\n    value: function addNewSubray() /*rayParameters*/{\n      return this.subrays[this.numSubrays++];\n    }\n  }, {\n    key: \"initSubray\",\n    value: function initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n  }, {\n    key: \"fractalRay\",\n    value: function fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0; // Add the top level subray\n\n      this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\n\n      for (var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        var subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        var random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        var segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n  }, {\n    key: \"fractalRayRecursive\",\n    value: function fractalRayRecursive(segment) {\n      // Leave recursion condition\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      } // Interpolation\n\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      var lForwards = this.forwards.length();\n      if (lForwards < 0.000001) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n      var middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      var middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      var timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      var p = this.middleLinPos; // Noise\n\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos); // Recursion\n\n      var newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      var newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n  }, {\n    key: \"createPrism\",\n    value: function createPrism(segment) {\n      // Creates one triangular prism and its vertices at the segment\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n      this.createPrismFaces();\n    }\n  }, {\n    key: \"createTriangleVerticesWithoutUVs\",\n    value: function createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      // Create an equilateral triangle (only vertices)\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createTriangleVerticesWithUVs\",\n    value: function createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      // Create an equilateral triangle (only vertices)\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      var uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createPrismFaces\",\n    value: function createPrismFaces(vertex\n    /*, index*/) {\n      var indices = this.indices;\n      var vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n  }, {\n    key: \"createDefaultSubrayCreationCallbacks\",\n    value: function createDefaultSubrayCreationCallbacks() {\n      var random1 = this.randomGenerator.random;\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\n        // Decide subrays creation at parent (sub)ray segment\n        var subray = lightningStrike.currentSubray;\n        var period = lightningStrike.rayParameters.subrayPeriod;\n        var dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        var phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        var phase = lightningStrike.time - phase0;\n        var currentCycle = Math.floor(phase / period);\n        var childSubraySeed = random1() * (currentCycle + 1);\n        var isActive = phase % period <= dutyCycle * period;\n        var probability = 0;\n        if (isActive) {\n          probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n        }\n\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          var childSubray = lightningStrike.addNewSubray();\n          var parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n      var vec1Pos = new Vector3();\n      var vec2Forward = new Vector3();\n      var vec3Side = new Vector3();\n      var vec4Up = new Vector3();\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n        // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n        // Just use the default cone position generator\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        // Sets childSubray pos0 and pos1 in a cone\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        // Sets childSubray pos0 and pos1 in a cylinder\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n  }, {\n    key: \"createSubray\",\n    value: function createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n  }, {\n    key: \"createSegment\",\n    value: function createSegment() {\n      return {\n        iteration: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n  }, {\n    key: \"getNewSegment\",\n    value: function getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(LightningStrike.prototype), \"copy\", this).call(this, source);\n      this.init(LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  }]);\n  return LightningStrike;\n}(BufferGeometry);\nLightningStrike.prototype.isLightningStrike = true; // Ray states\n\nLightningStrike.RAY_INITIALIZED = 0;\nLightningStrike.RAY_UNBORN = 1;\nLightningStrike.RAY_PROPAGATING = 2;\nLightningStrike.RAY_STEADY = 3;\nLightningStrike.RAY_VANISHING = 4;\nLightningStrike.RAY_EXTINGUISHED = 5;\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\nLightningStrike.createRandomGenerator = function () {\n  var numSeeds = 2053;\n  var seeds = [];\n  for (var i = 0; i < numSeeds; i++) {\n    seeds.push(Math.random());\n  }\n  var generator = {\n    currentSeed: 0,\n    random: function random() {\n      var value = seeds[generator.currentSeed];\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n      return value;\n    },\n    getSeed: function getSeed() {\n      return generator.currentSeed / numSeeds;\n    },\n    setSeed: function setSeed(seed) {\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n    }\n  };\n  return generator;\n};\nLightningStrike.copyParameters = function (dest, source) {\n  source = source || {};\n  dest = dest || {};\n  var vecCopy = function vecCopy(v) {\n    if (source === dest) {\n      return v;\n    } else {\n      return v.clone();\n    }\n  };\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2,\n  // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\n\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n  return dest;\n};\nexport { LightningStrike };","map":null,"metadata":{},"sourceType":"module"}