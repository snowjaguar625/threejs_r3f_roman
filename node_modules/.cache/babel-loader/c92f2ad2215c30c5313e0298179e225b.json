{"ast":null,"code":"import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nvar ShadowMapViewer = function ShadowMapViewer(light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function set(width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n      if (doRenderLabel) {\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n      }\n    }\n  };\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n  this.update();\n};\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\nexport { ShadowMapViewer };","map":null,"metadata":{},"sourceType":"module"}