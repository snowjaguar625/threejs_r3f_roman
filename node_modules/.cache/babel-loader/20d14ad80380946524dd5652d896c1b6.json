{"ast":null,"code":"import { Mesh, MathUtils } from 'three';\nvar MorphBlendMesh = function MorphBlendMesh(geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function createAnimation(name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function autoCreateAnimations(fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n      frameRanges = {};\n    var i = 0;\n    for (var key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n      i++;\n    }\n    for (var _name in frameRanges) {\n      var range = frameRanges[_name];\n      this.createAnimation(_name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function setAnimationDirectionForward(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function setAnimationDirectionBackward(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function setAnimationFPS(name, fps) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function setAnimationDuration(name, duration) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function setAnimationWeight(name, weight) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function setAnimationTime(name, time) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function getAnimationTime(name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  },\n  getAnimationDuration: function getAnimationDuration(name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  },\n  playAnimation: function playAnimation(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function stopAnimation(name) {\n    var animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function update(delta) {\n    for (var i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\nexport { MorphBlendMesh };","map":null,"metadata":{},"sourceType":"module"}