{"ast":null,"code":"import _construct from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nvar NodeHandler = {\n  construct: function construct(NodeClosure, params) {\n    var inputs = params.shift();\n    return NodeClosure.apply(void 0, [new ShaderNodeObjects(inputs)].concat(_toConsumableArray(params)));\n  },\n  get: function get(node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n    return node[prop];\n  }\n};\nvar nodeObjects = new WeakMap();\nvar ShaderNodeObject = function ShaderNodeObject(obj) {\n  var type = typeof obj;\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      var _nodeObject = nodeObjects.get(obj);\n      if (_nodeObject === undefined) {\n        _nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, _nodeObject);\n        nodeObjects.set(_nodeObject, _nodeObject);\n      }\n      return _nodeObject;\n    }\n  }\n  return obj;\n};\nvar ShaderNodeObjects = function ShaderNodeObjects(objects) {\n  for (var name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n  return objects;\n};\nvar getShaderNodeArray = function getShaderNodeArray(array) {\n  var len = array.length;\n  for (var i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n  return array;\n};\nvar ShaderNodeProxy = function ShaderNodeProxy(NodeClass) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (scope === null) {\n    return function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      return new ShaderNodeObject(_construct(NodeClass, _toConsumableArray(getShaderNodeArray(params))));\n    };\n  } else if (factor === null) {\n    return function () {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      return new ShaderNodeObject(_construct(NodeClass, [scope].concat(_toConsumableArray(getShaderNodeArray(params)))));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return new ShaderNodeObject(_construct(NodeClass, [scope].concat(_toConsumableArray(getShaderNodeArray(params)), [factor])));\n    };\n  }\n};\nvar ShaderNodeScript = function ShaderNodeScript(jsFunc) {\n  return function (inputs, builder) {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\nvar bools = [false, true];\nvar uints = [0, 1, 2, 3];\nvar ints = [-1, -2];\nvar floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nvar boolsCacheMap = new Map();\nfor (var _i = 0, _bools = bools; _i < _bools.length; _i++) {\n  var _bool = _bools[_i];\n  boolsCacheMap.set(_bool, new ConstNode(_bool));\n}\nvar uintsCacheMap = new Map();\nfor (var _i2 = 0, _uints = uints; _i2 < _uints.length; _i2++) {\n  var _uint = _uints[_i2];\n  uintsCacheMap.set(_uint, new ConstNode(_uint, 'uint'));\n}\nvar intsCacheMap = new Map(_toConsumableArray(uintsCacheMap).map(function (el) {\n  return new ConstNode(el.value, 'int');\n}));\nfor (var _i3 = 0, _ints = ints; _i3 < _ints.length; _i3++) {\n  var _int = _ints[_i3];\n  intsCacheMap.set(_int, new ConstNode(_int, 'int'));\n}\nvar floatsCacheMap = new Map(_toConsumableArray(intsCacheMap).map(function (el) {\n  return new ConstNode(el.value);\n}));\nfor (var _i4 = 0, _floats = floats; _i4 < _floats.length; _i4++) {\n  var _float = _floats[_i4];\n  floatsCacheMap.set(_float, new ConstNode(_float));\n}\nfor (var _i5 = 0, _floats2 = floats; _i5 < _floats2.length; _i5++) {\n  var _float2 = _floats2[_i5];\n  floatsCacheMap.set(-_float2, new ConstNode(-_float2));\n}\nvar constNodesCacheMap = new Map([].concat(_toConsumableArray(boolsCacheMap), _toConsumableArray(floatsCacheMap)));\nvar getAutoTypedConstNode = function getAutoTypedConstNode(value) {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\nvar ConvertType = function ConvertType(type) {\n  var cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      params[_key4] = arguments[_key4];\n    }\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType.apply(void 0, [type].concat(_toConsumableArray(params)))];\n      }\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n      var nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\nvar ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nvar nodeObject = function nodeObject(val) {\n  return new ShaderNodeObject(val);\n};\nvar uniform = function uniform(value) {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nvar label = function label(node, name) {\n  node = nodeObject(node);\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n  return nodeObject(new VarNode(node, name));\n};\nvar temp = function temp(node) {\n  return nodeObject(new VarNode(nodeObject(node)));\n};\nvar color = new ConvertType('color');\nvar float = new ConvertType('float', floatsCacheMap);\nvar int = new ConvertType('int', intsCacheMap);\nvar uint = new ConvertType('uint', uintsCacheMap);\nvar bool = new ConvertType('bool', boolsCacheMap);\nvar vec2 = new ConvertType('vec2');\nvar ivec2 = new ConvertType('ivec2');\nvar uvec2 = new ConvertType('uvec2');\nvar bvec2 = new ConvertType('bvec2');\nvar vec3 = new ConvertType('vec3');\nvar ivec3 = new ConvertType('ivec3');\nvar uvec3 = new ConvertType('uvec3');\nvar bvec3 = new ConvertType('bvec3');\nvar vec4 = new ConvertType('vec4');\nvar ivec4 = new ConvertType('ivec4');\nvar uvec4 = new ConvertType('uvec4');\nvar bvec4 = new ConvertType('bvec4');\nvar mat3 = new ConvertType('mat3');\nvar imat3 = new ConvertType('imat3');\nvar umat3 = new ConvertType('umat3');\nvar bmat3 = new ConvertType('bmat3');\nvar mat4 = new ConvertType('mat4');\nvar imat4 = new ConvertType('imat4');\nvar umat4 = new ConvertType('umat4');\nvar bmat4 = new ConvertType('bmat4');\nvar join = function join() {\n  for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    params[_key5] = arguments[_key5];\n  }\n  return nodeObject(new JoinNode(getShaderNodeArray(params)));\n};\nvar uv = function uv() {\n  for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    params[_key6] = arguments[_key6];\n  }\n  return nodeObject(_construct(UVNode, params));\n};\nvar attribute = function attribute() {\n  for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    params[_key7] = arguments[_key7];\n  }\n  return nodeObject(_construct(AttributeNode, params));\n};\nvar buffer = function buffer() {\n  for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    params[_key8] = arguments[_key8];\n  }\n  return nodeObject(_construct(BufferNode, params));\n};\nvar texture = function texture() {\n  for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    params[_key9] = arguments[_key9];\n  }\n  return nodeObject(_construct(TextureNode, params));\n};\nvar sampler = function sampler(texture) {\n  return nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\n};\nvar cond = function cond() {\n  for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    params[_key10] = arguments[_key10];\n  }\n  return nodeObject(_construct(CondNode, _toConsumableArray(getShaderNodeArray(params))));\n};\nvar addTo = function addTo(varNode) {\n  for (var _len11 = arguments.length, params = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    params[_key11 - 1] = arguments[_key11];\n  }\n  varNode.node = add.apply(void 0, [varNode.node].concat(_toConsumableArray(getShaderNodeArray(params))));\n  return nodeObject(varNode);\n};\nvar add = new ShaderNodeProxy(OperatorNode, '+');\nvar sub = new ShaderNodeProxy(OperatorNode, '-');\nvar mul = new ShaderNodeProxy(OperatorNode, '*');\nvar div = new ShaderNodeProxy(OperatorNode, '/');\nvar remainder = new ShaderNodeProxy(OperatorNode, '%');\nvar equal = new ShaderNodeProxy(OperatorNode, '==');\nvar assign = new ShaderNodeProxy(OperatorNode, '=');\nvar lessThan = new ShaderNodeProxy(OperatorNode, '<');\nvar greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nvar lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nvar greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nvar and = new ShaderNodeProxy(OperatorNode, '&&');\nvar or = new ShaderNodeProxy(OperatorNode, '||');\nvar xor = new ShaderNodeProxy(OperatorNode, '^^');\nvar bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nvar bitOr = new ShaderNodeProxy(OperatorNode, '|');\nvar bitXor = new ShaderNodeProxy(OperatorNode, '^');\nvar shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nvar shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nvar element = new ShaderNodeProxy(ArrayElementNode);\nvar normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nvar normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nvar normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nvar normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nvar transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nvar positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nvar positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nvar positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nvar positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nvar viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nvar cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nvar diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nvar roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nvar metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nvar alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nvar specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nvar abs = new ShaderNodeProxy(MathNode, 'abs');\nvar acos = new ShaderNodeProxy(MathNode, 'acos');\nvar asin = new ShaderNodeProxy(MathNode, 'asin');\nvar atan = new ShaderNodeProxy(MathNode, 'atan');\nvar ceil = new ShaderNodeProxy(MathNode, 'ceil');\nvar clamp = new ShaderNodeProxy(MathNode, 'clamp');\nvar cos = new ShaderNodeProxy(MathNode, 'cos');\nvar cross = new ShaderNodeProxy(MathNode, 'cross');\nvar degrees = new ShaderNodeProxy(MathNode, 'degrees');\nvar dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nvar dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nvar distance = new ShaderNodeProxy(MathNode, 'distance');\nvar dot = new ShaderNodeProxy(MathNode, 'dot');\nvar exp = new ShaderNodeProxy(MathNode, 'exp');\nvar exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nvar faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nvar floor = new ShaderNodeProxy(MathNode, 'floor');\nvar fract = new ShaderNodeProxy(MathNode, 'fract');\nvar invert = new ShaderNodeProxy(MathNode, 'invert');\nvar inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nvar length = new ShaderNodeProxy(MathNode, 'length');\nvar log = new ShaderNodeProxy(MathNode, 'log');\nvar log2 = new ShaderNodeProxy(MathNode, 'log2');\nvar max = new ShaderNodeProxy(MathNode, 'max');\nvar min = new ShaderNodeProxy(MathNode, 'min');\nvar mix = new ShaderNodeProxy(MathNode, 'mix');\nvar mod = new ShaderNodeProxy(MathNode, 'mod');\nvar negate = new ShaderNodeProxy(MathNode, 'negate');\nvar normalize = new ShaderNodeProxy(MathNode, 'normalize');\nvar pow = new ShaderNodeProxy(MathNode, 'pow');\nvar pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nvar pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nvar pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nvar radians = new ShaderNodeProxy(MathNode, 'radians');\nvar reflect = new ShaderNodeProxy(MathNode, 'reflect');\nvar refract = new ShaderNodeProxy(MathNode, 'refract');\nvar round = new ShaderNodeProxy(MathNode, 'round');\nvar saturate = new ShaderNodeProxy(MathNode, 'saturate');\nvar sign = new ShaderNodeProxy(MathNode, 'sign');\nvar sin = new ShaderNodeProxy(MathNode, 'sin');\nvar smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nvar sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nvar step = new ShaderNodeProxy(MathNode, 'step');\nvar tan = new ShaderNodeProxy(MathNode, 'tan');\nvar transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nvar EPSILON = float(1e-6);\nvar INFINITY = float(1e6);\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };","map":null,"metadata":{},"sourceType":"module"}