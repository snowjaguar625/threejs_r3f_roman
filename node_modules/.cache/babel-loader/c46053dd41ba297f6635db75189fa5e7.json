{"ast":null,"code":"import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\nvar F_Schlick = new ShaderNode(function (inputs) {\n  var f0 = inputs.f0,\n    f90 = inputs.f90,\n    dotVH = inputs.dotVH; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n  var fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nvar BRDF_Lambert = new ShaderNode(function (inputs) {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nvar getDistanceAttenuation = new ShaderNode(function (inputs) {\n  var lightDistance = inputs.lightDistance,\n    cutoffDistance = inputs.cutoffDistance,\n    decayExponent = inputs.decayExponent;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nvar V_GGX_SmithCorrelated = new ShaderNode(function (inputs) {\n  var alpha = inputs.alpha,\n    dotNL = inputs.dotNL,\n    dotNV = inputs.dotNV;\n  var a2 = pow2(alpha);\n  var gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  var gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneyâ€™s reparameterization\n\nvar D_GGX = new ShaderNode(function (inputs) {\n  var alpha = inputs.alpha,\n    dotNH = inputs.dotNH;\n  var a2 = pow2(alpha);\n  var denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nvar BRDF_GGX = new ShaderNode(function (inputs) {\n  var lightDirection = inputs.lightDirection,\n    f0 = inputs.f0,\n    f90 = inputs.f90,\n    roughness = inputs.roughness;\n  var alpha = pow2(roughness); // UE4's roughness\n\n  var halfDir = normalize(add(lightDirection, positionViewDirection));\n  var dotNL = saturate(dot(transformedNormalView, lightDirection));\n  var dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  var dotNH = saturate(dot(transformedNormalView, halfDir));\n  var dotVH = saturate(dot(positionViewDirection, halfDir));\n  var F = F_Schlick({\n    f0: f0,\n    f90: f90,\n    dotVH: dotVH\n  });\n  var V = V_GGX_SmithCorrelated({\n    alpha: alpha,\n    dotNL: dotNL,\n    dotNV: dotNV\n  });\n  var D = D_GGX({\n    alpha: alpha,\n    dotNH: dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nvar RE_Direct_Physical = new ShaderNode(function (inputs) {\n  var lightDirection = inputs.lightDirection,\n    lightColor = inputs.lightColor,\n    directDiffuse = inputs.directDiffuse,\n    directSpecular = inputs.directSpecular;\n  var dotNL = saturate(dot(transformedNormalView, lightDirection));\n  var irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection: lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness: roughness\n  })));\n});\nvar PhysicalLightingModel = new ShaderNode(function (inputs\n/*, builder*/) {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };","map":null,"metadata":{},"sourceType":"module"}