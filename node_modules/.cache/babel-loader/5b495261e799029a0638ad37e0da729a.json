{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nvar OutlinePass = /*#__PURE__*/function (_Pass) {\n  _inherits(OutlinePass, _Pass);\n  function OutlinePass(resolution, scene, camera, selectedObjects) {\n    var _this;\n    _classCallCheck(this, OutlinePass);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OutlinePass).call(this));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderScene\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderCamera\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"selectedObjects\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"visibleEdgeColor\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"hiddenEdgeColor\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"edgeGlow\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"usePatternTexture\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"edgeThickness\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"edgeStrength\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"downSampleRatio\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"pulsePeriod\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"resolution\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetMaskBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"depthMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"prepareMaskMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetDepthBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetMaskDownSampleBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetBlurBuffer1\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetBlurBuffer2\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"edgeDetectionMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetEdgeBuffer1\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTargetEdgeBuffer2\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"separableBlurMaterial1\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"separableBlurMaterial2\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"overlayMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"materialCopy\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"oldClearAlpha\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"fsQuad\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"tempPulseColor1\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"tempPulseColor2\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"textureMatrix\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"patternTexture\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_visibilityCache\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_oldClearColor\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"copyUniforms\", void 0);\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"BlurDirectionX\", new Vector2(1.0, 0.0));\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"BlurDirectionY\", new Vector2(0.0, 1.0));\n    _this.renderScene = scene;\n    _this.renderCamera = camera;\n    _this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n    _this.visibleEdgeColor = new Color(1, 1, 1);\n    _this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    _this.edgeGlow = 0.0;\n    _this.usePatternTexture = false;\n    _this.edgeThickness = 1.0;\n    _this.edgeStrength = 3.0;\n    _this.downSampleRatio = 2;\n    _this.pulsePeriod = 0;\n    _this._visibilityCache = new Map();\n    _this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    var resx = Math.round(_this.resolution.x / _this.downSampleRatio);\n    var resy = Math.round(_this.resolution.y / _this.downSampleRatio);\n    _this.renderTargetMaskBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n    _this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    _this.depthMaterial = new MeshDepthMaterial();\n    _this.depthMaterial.side = DoubleSide;\n    _this.depthMaterial.depthPacking = RGBADepthPacking;\n    _this.depthMaterial.blending = NoBlending;\n    _this.prepareMaskMaterial = _this.getPrepareMaskMaterial();\n    _this.prepareMaskMaterial.side = DoubleSide;\n    _this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(_this.prepareMaskMaterial.fragmentShader, _this.renderCamera);\n    _this.renderTargetDepthBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n    _this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    _this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n    _this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n    _this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n    _this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    _this.edgeDetectionMaterial = _this.getEdgeDetectionMaterial();\n    _this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n    _this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n    _this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    var MAX_EDGE_THICKNESS = 4;\n    var MAX_EDGE_GLOW = 4;\n    _this.separableBlurMaterial1 = _this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    _this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    _this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n    _this.separableBlurMaterial2 = _this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    _this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    _this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n    _this.overlayMaterial = _this.getOverlayMaterial(); // copy material\n\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms['opacity'].value = 1.0;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.fsQuad = new FullScreenQuad(_this.materialCopy);\n    _this.tempPulseColor1 = new Color();\n    _this.tempPulseColor2 = new Color();\n    _this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera) {\n      var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n    }\n    return _this;\n  }\n  _createClass(OutlinePass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderTargetMaskBuffer.dispose();\n      this.renderTargetDepthBuffer.dispose();\n      this.renderTargetMaskDownSampleBuffer.dispose();\n      this.renderTargetBlurBuffer1.dispose();\n      this.renderTargetBlurBuffer2.dispose();\n      this.renderTargetEdgeBuffer1.dispose();\n      this.renderTargetEdgeBuffer2.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.renderTargetMaskBuffer.setSize(width, height);\n      this.renderTargetDepthBuffer.setSize(width, height);\n      var resx = Math.round(width / this.downSampleRatio);\n      var resy = Math.round(height / this.downSampleRatio);\n      this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n      this.renderTargetBlurBuffer1.setSize(resx, resy);\n      this.renderTargetEdgeBuffer1.setSize(resx, resy);\n      this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n      this.renderTargetBlurBuffer2.setSize(resx, resy);\n      this.renderTargetEdgeBuffer2.setSize(resx, resy);\n      this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n    }\n  }, {\n    key: \"changeVisibilityOfSelectedObjects\",\n    value: function changeVisibilityOfSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n    }\n  }, {\n    key: \"changeVisibilityOfNonSelectedObjects\",\n    value: function changeVisibilityOfNonSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      var selectedMeshes = [];\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) selectedMeshes.push(object);\n      }\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n      function VisibilityChangeCallBack(object) {\n        if (object.isMesh || object.isSprite) {\n          // only meshes and sprites are supported by OutlinePass\n          var bFound = false;\n          for (var _i = 0; _i < selectedMeshes.length; _i++) {\n            var selectedObjectId = selectedMeshes[_i].id;\n            if (selectedObjectId === object.id) {\n              bFound = true;\n              break;\n            }\n          }\n          if (bFound === false) {\n            var visibility = object.visible;\n            if (bVisible === false || cache.get(object) === true) {\n              object.visible = bVisible;\n            }\n            cache.set(object, visibility);\n          }\n        } else if (object.isPoints || object.isLine) {\n          // the visibilty of points and lines is always set to false in order to\n          // not affect the outline computation\n          if (bVisible === true) {\n            object.visible = cache.get(object); // restore\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n      this.renderScene.traverse(VisibilityChangeCallBack);\n    }\n  }, {\n    key: \"updateTextureMatrix\",\n    value: function updateTextureMatrix() {\n      this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (this.selectedObjects.length > 0) {\n        renderer.getClearColor(this._oldClearColor);\n        this.oldClearAlpha = renderer.getClearAlpha();\n        var oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        if (maskActive) renderer.state.buffers.stencil.setTest(false);\n        renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n        this.changeVisibilityOfSelectedObjects(false);\n        var currentBackground = this.renderScene.background;\n        this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n        this.renderScene.overrideMaterial = this.depthMaterial;\n        renderer.setRenderTarget(this.renderTargetDepthBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n        this.changeVisibilityOfSelectedObjects(true);\n        this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n        this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n        this.changeVisibilityOfNonSelectedObjects(false);\n        this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n        this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n        this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n        this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n        renderer.setRenderTarget(this.renderTargetMaskBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.renderScene.overrideMaterial = null;\n        this.changeVisibilityOfNonSelectedObjects(true);\n        this._visibilityCache.clear();\n        this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n        renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.tempPulseColor1.copy(this.visibleEdgeColor);\n        this.tempPulseColor2.copy(this.hiddenEdgeColor);\n        if (this.pulsePeriod > 0) {\n          var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n          this.tempPulseColor1.multiplyScalar(scalar);\n          this.tempPulseColor2.multiplyScalar(scalar);\n        } // 3. Apply Edge Detection Pass\n\n        this.fsQuad.material = this.edgeDetectionMaterial;\n        this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n        this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n        this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n        this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n        this.fsQuad.material = this.separableBlurMaterial1;\n        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX;\n        this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n        this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n        this.fsQuad.material = this.separableBlurMaterial2;\n        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n        this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n        this.fsQuad.material = this.overlayMaterial;\n        this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n        this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n        this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n        this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n        this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n        this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n        this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n        if (maskActive) renderer.state.buffers.stencil.setTest(true);\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n        renderer.autoClear = oldAutoClear;\n      }\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"getPrepareMaskMaterial\",\n    value: function getPrepareMaskMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          depthTexture: {\n            value: null\n          },\n          cameraNearFar: {\n            value: new Vector2(0.5, 0.5)\n          },\n          textureMatrix: {\n            value: null\n          }\n        },\n        vertexShader: \"#include <morphtarget_pars_vertex>\\n\\t\\t\\t\\t#include <skinning_pars_vertex>\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\t#include <skinbase_vertex>\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <morphtarget_vertex>\\n\\t\\t\\t\\t\\t#include <skinning_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\t\\t\\t\\t\\tvPosition = mvPosition;\\n\\t\\t\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\t\\tprojTexCoord = textureMatrix * worldPosition;\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <packing>\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tuniform sampler2D depthTexture;\\n\\t\\t\\t\\tuniform vec2 cameraNearFar;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\\n\\t\\t\\t\\t\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\\n\\t\\t\\t\\t\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getEdgeDetectionMaterial\",\n    value: function getEdgeDetectionMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          visibleEdgeColor: {\n            value: new Vector3(1.0, 1.0, 1.0)\n          },\n          hiddenEdgeColor: {\n            value: new Vector3(1.0, 1.0, 1.0)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\n\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\n\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\n\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\n\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\n\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\n\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\n\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\n\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\n\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(maxRadius) {\n      return new ShaderMaterial({\n        defines: {\n          MAX_RADIUS: maxRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          },\n          kernelRadius: {\n            value: 1.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\t\\t\\t\\tuniform float kernelRadius;\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\n\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\n\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\n\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\n\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\n\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\n\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\n\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\n\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\n\\t\\t\\t\\t\\t\\tuvOffset += delta;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getOverlayMaterial\",\n    value: function getOverlayMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          edgeTexture1: {\n            value: null\n          },\n          edgeTexture2: {\n            value: null\n          },\n          patternTexture: {\n            value: null\n          },\n          edgeStrength: {\n            value: 1.0\n          },\n          edgeGlow: {\n            value: 1.0\n          },\n          usePatternTexture: {\n            value: 0.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\n\\t\\t\\t\\tuniform sampler2D patternTexture;\\n\\t\\t\\t\\tuniform float edgeStrength;\\n\\t\\t\\t\\tuniform float edgeGlow;\\n\\t\\t\\t\\tuniform bool usePatternTexture;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\n\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\n\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\n\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\n\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\n\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\n\\t\\t\\t\\t\\tif(usePatternTexture)\\n\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\n\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\n\\t\\t\\t\\t}\",\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true\n      });\n    }\n  }]);\n  return OutlinePass;\n}(Pass);\nexport { OutlinePass };","map":null,"metadata":{},"sourceType":"module"}