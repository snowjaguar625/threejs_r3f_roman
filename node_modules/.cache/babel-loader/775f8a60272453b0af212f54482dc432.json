{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport TempNode from '../core/TempNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport OperatorNode from './OperatorNode.js';\nvar MathNode = /*#__PURE__*/function (_TempNode) {\n  _inherits(MathNode, _TempNode);\n  // 1 input\n  // 2 inputs\n  // 3 inputs\n  function MathNode(method, aNode) {\n    var _this;\n    var bNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var cNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    _classCallCheck(this, MathNode);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MathNode).call(this));\n    _this.method = method;\n    _this.aNode = aNode;\n    _this.bNode = bNode;\n    _this.cNode = cNode;\n    return _this;\n  }\n  _createClass(MathNode, [{\n    key: \"getInputType\",\n    value: function getInputType(builder) {\n      var aType = this.aNode.getNodeType(builder);\n      var bType = this.bNode ? this.bNode.getNodeType(builder) : null;\n      var cType = this.cNode ? this.cNode.getNodeType(builder) : null;\n      var aLen = builder.getTypeLength(aType);\n      var bLen = builder.getTypeLength(bType);\n      var cLen = builder.getTypeLength(cType);\n      if (aLen > bLen && aLen > cLen) {\n        return aType;\n      } else if (bLen > cLen) {\n        return bType;\n      } else if (cLen > aLen) {\n        return cType;\n      }\n      return aType;\n    }\n  }, {\n    key: \"getNodeType\",\n    value: function getNodeType(builder) {\n      var method = this.method;\n      if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\n        return 'float';\n      } else if (method === MathNode.CROSS) {\n        return 'vec3';\n      } else {\n        return this.getInputType(builder);\n      }\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(builder, output) {\n      var method = this.method;\n      var type = this.getNodeType(builder);\n      var inputType = this.getInputType(builder);\n      var a = this.aNode;\n      var b = this.bNode;\n      var c = this.cNode;\n      var isWebGL = builder.renderer.isWebGLRenderer === true;\n      if (isWebGL && (method === MathNode.DFDX || method === MathNode.DFDY) && output === 'vec3') {\n        // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n        return new JoinNode([new MathNode(method, new SplitNode(a, 'x')), new MathNode(method, new SplitNode(a, 'y')), new MathNode(method, new SplitNode(a, 'z'))]).build(builder);\n      } else if (method === MathNode.TRANSFORM_DIRECTION) {\n        // dir can be either a direction vector or a normal vector\n        // upper-left 3x3 of matrix is assumed to be orthogonal\n        var tA = a;\n        var tB = b;\n        if (builder.isMatrix(tA.getNodeType(builder))) {\n          tB = new ExpressionNode(\"\".concat(builder.getType('vec4'), \"( \").concat(tB.build(builder, 'vec3'), \", 0.0 )\"), 'vec4');\n        } else {\n          tA = new ExpressionNode(\"\".concat(builder.getType('vec4'), \"( \").concat(tA.build(builder, 'vec3'), \", 0.0 )\"), 'vec4');\n        }\n        var mulNode = new SplitNode(new OperatorNode('*', tA, tB), 'xyz');\n        return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);\n      } else if (method === MathNode.SATURATE) {\n        return builder.format(\"clamp( \".concat(a.build(builder, inputType), \", 0.0, 1.0 )\"), type, output);\n      } else if (method === MathNode.NEGATE) {\n        return builder.format('( -' + a.build(builder, inputType) + ' )', type, output);\n      } else if (method === MathNode.INVERT) {\n        return builder.format('( 1.0 - ' + a.build(builder, inputType) + ' )', type, output);\n      } else {\n        var params = [];\n        if (method === MathNode.CROSS) {\n          params.push(a.build(builder, type), b.build(builder, type));\n        } else if (method === MathNode.STEP) {\n          params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\n        } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\n          params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\n        } else if (method === MathNode.REFRACT) {\n          params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\n        } else if (method === MathNode.MIX) {\n          params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\n        } else {\n          params.push(a.build(builder, inputType));\n          if (c !== null) {\n            params.push(b.build(builder, inputType), c.build(builder, inputType));\n          } else if (b !== null) {\n            params.push(b.build(builder, inputType));\n          }\n        }\n        return builder.format(\"\".concat(builder.getMethod(method), \"( \").concat(params.join(', '), \" )\"), type, output);\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(data) {\n      _get(_getPrototypeOf(MathNode.prototype), \"serialize\", this).call(this, data);\n      data.method = this.method;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data) {\n      _get(_getPrototypeOf(MathNode.prototype), \"deserialize\", this).call(this, data);\n      this.method = data.method;\n    }\n  }]);\n  return MathNode;\n}(TempNode);\n_defineProperty(MathNode, \"RAD\", 'radians');\n_defineProperty(MathNode, \"DEG\", 'degrees');\n_defineProperty(MathNode, \"EXP\", 'exp');\n_defineProperty(MathNode, \"EXP2\", 'exp2');\n_defineProperty(MathNode, \"LOG\", 'log');\n_defineProperty(MathNode, \"LOG2\", 'log2');\n_defineProperty(MathNode, \"SQRT\", 'sqrt');\n_defineProperty(MathNode, \"INV_SQRT\", 'inversesqrt');\n_defineProperty(MathNode, \"FLOOR\", 'floor');\n_defineProperty(MathNode, \"CEIL\", 'ceil');\n_defineProperty(MathNode, \"NORMALIZE\", 'normalize');\n_defineProperty(MathNode, \"FRACT\", 'fract');\n_defineProperty(MathNode, \"SIN\", 'sin');\n_defineProperty(MathNode, \"COS\", 'cos');\n_defineProperty(MathNode, \"TAN\", 'tan');\n_defineProperty(MathNode, \"ASIN\", 'asin');\n_defineProperty(MathNode, \"ACOS\", 'acos');\n_defineProperty(MathNode, \"ATAN\", 'atan');\n_defineProperty(MathNode, \"ABS\", 'abs');\n_defineProperty(MathNode, \"SIGN\", 'sign');\n_defineProperty(MathNode, \"LENGTH\", 'length');\n_defineProperty(MathNode, \"NEGATE\", 'negate');\n_defineProperty(MathNode, \"INVERT\", 'invert');\n_defineProperty(MathNode, \"DFDX\", 'dFdx');\n_defineProperty(MathNode, \"DFDY\", 'dFdy');\n_defineProperty(MathNode, \"SATURATE\", 'saturate');\n_defineProperty(MathNode, \"ROUND\", 'round');\n_defineProperty(MathNode, \"MIN\", 'min');\n_defineProperty(MathNode, \"MAX\", 'max');\n_defineProperty(MathNode, \"MOD\", 'mod');\n_defineProperty(MathNode, \"STEP\", 'step');\n_defineProperty(MathNode, \"REFLECT\", 'reflect');\n_defineProperty(MathNode, \"DISTANCE\", 'distance');\n_defineProperty(MathNode, \"DOT\", 'dot');\n_defineProperty(MathNode, \"CROSS\", 'cross');\n_defineProperty(MathNode, \"POW\", 'pow');\n_defineProperty(MathNode, \"TRANSFORM_DIRECTION\", 'transformDirection');\n_defineProperty(MathNode, \"MIX\", 'mix');\n_defineProperty(MathNode, \"CLAMP\", 'clamp');\n_defineProperty(MathNode, \"REFRACT\", 'refract');\n_defineProperty(MathNode, \"SMOOTHSTEP\", 'smoothstep');\n_defineProperty(MathNode, \"FACEFORWARD\", 'faceforward');\nexport default MathNode;","map":null,"metadata":{},"sourceType":"module"}