{"ast":null,"code":"import { Vector3, Color, Vector2, Vector4, Box3, Matrix4, Frustum, Matrix3, DoubleSide } from 'three';\nvar RenderableObject = function RenderableObject() {\n  this.id = 0;\n  this.object = null;\n  this.z = 0;\n  this.renderOrder = 0;\n}; //\n\nvar RenderableFace = function RenderableFace() {\n  this.id = 0;\n  this.v1 = new RenderableVertex();\n  this.v2 = new RenderableVertex();\n  this.v3 = new RenderableVertex();\n  this.normalModel = new Vector3();\n  this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];\n  this.vertexNormalsLength = 0;\n  this.color = new Color();\n  this.material = null;\n  this.uvs = [new Vector2(), new Vector2(), new Vector2()];\n  this.z = 0;\n  this.renderOrder = 0;\n}; //\n\nvar RenderableVertex = function RenderableVertex() {\n  this.position = new Vector3();\n  this.positionWorld = new Vector3();\n  this.positionScreen = new Vector4();\n  this.visible = true;\n};\nRenderableVertex.prototype.copy = function (vertex) {\n  this.positionWorld.copy(vertex.positionWorld);\n  this.positionScreen.copy(vertex.positionScreen);\n}; //\n\nvar RenderableLine = function RenderableLine() {\n  this.id = 0;\n  this.v1 = new RenderableVertex();\n  this.v2 = new RenderableVertex();\n  this.vertexColors = [new Color(), new Color()];\n  this.material = null;\n  this.z = 0;\n  this.renderOrder = 0;\n}; //\n\nvar RenderableSprite = function RenderableSprite() {\n  this.id = 0;\n  this.object = null;\n  this.x = 0;\n  this.y = 0;\n  this.z = 0;\n  this.rotation = 0;\n  this.scale = new Vector2();\n  this.material = null;\n  this.renderOrder = 0;\n}; //\n\nvar Projector = function Projector() {\n  var _object,\n    _objectCount,\n    _objectPool = [],\n    _objectPoolLength = 0,\n    _vertex,\n    _vertexCount,\n    _vertexPool = [],\n    _vertexPoolLength = 0,\n    _face,\n    _faceCount,\n    _facePool = [],\n    _facePoolLength = 0,\n    _line,\n    _lineCount,\n    _linePool = [],\n    _linePoolLength = 0,\n    _sprite,\n    _spriteCount,\n    _spritePool = [],\n    _spritePoolLength = 0,\n    _renderData = {\n      objects: [],\n      lights: [],\n      elements: []\n    },\n    _vector3 = new Vector3(),\n    _vector4 = new Vector4(),\n    _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n    _boundingBox = new Box3(),\n    _points3 = new Array(3),\n    _viewMatrix = new Matrix4(),\n    _viewProjectionMatrix = new Matrix4(),\n    _modelMatrix,\n    _modelViewProjectionMatrix = new Matrix4(),\n    _frustum = new Frustum(); //\n\n  this.projectVector = function (vector, camera) {\n    console.warn('THREE.Projector: .projectVector() is now vector.project().');\n    vector.project(camera);\n  };\n  this.unprojectVector = function (vector, camera) {\n    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\n    vector.unproject(camera);\n  };\n  this.pickingRay = function () {\n    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\n  }; //\n\n  var RenderList = function RenderList() {\n    var normals = [];\n    var colors = [];\n    var uvs = [];\n    var object = null;\n    var normalMatrix = new Matrix3();\n    function setObject(value) {\n      object = value;\n      normalMatrix.getNormalMatrix(object.matrixWorld);\n      normals.length = 0;\n      colors.length = 0;\n      uvs.length = 0;\n    }\n    function projectVertex(vertex) {\n      var position = vertex.position;\n      var positionWorld = vertex.positionWorld;\n      var positionScreen = vertex.positionScreen;\n      positionWorld.copy(position).applyMatrix4(_modelMatrix);\n      positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\n      var invW = 1 / positionScreen.w;\n      positionScreen.x *= invW;\n      positionScreen.y *= invW;\n      positionScreen.z *= invW;\n      vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\n    }\n    function pushVertex(x, y, z) {\n      _vertex = getNextVertexInPool();\n      _vertex.position.set(x, y, z);\n      projectVertex(_vertex);\n    }\n    function pushNormal(x, y, z) {\n      normals.push(x, y, z);\n    }\n    function pushColor(r, g, b) {\n      colors.push(r, g, b);\n    }\n    function pushUv(x, y) {\n      uvs.push(x, y);\n    }\n    function checkTriangleVisibility(v1, v2, v3) {\n      if (v1.visible === true || v2.visible === true || v3.visible === true) return true;\n      _points3[0] = v1.positionScreen;\n      _points3[1] = v2.positionScreen;\n      _points3[2] = v3.positionScreen;\n      return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));\n    }\n    function checkBackfaceCulling(v1, v2, v3) {\n      return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n    }\n    function pushLine(a, b) {\n      var v1 = _vertexPool[a];\n      var v2 = _vertexPool[b]; // Clip\n\n      v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);\n      v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);\n      if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n        // Perform the perspective divide\n        v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);\n        v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);\n        _line = getNextLineInPool();\n        _line.id = object.id;\n        _line.v1.copy(v1);\n        _line.v2.copy(v2);\n        _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);\n        _line.renderOrder = object.renderOrder;\n        _line.material = object.material;\n        if (object.material.vertexColors) {\n          _line.vertexColors[0].fromArray(colors, a * 3);\n          _line.vertexColors[1].fromArray(colors, b * 3);\n        }\n        _renderData.elements.push(_line);\n      }\n    }\n    function pushTriangle(a, b, c, material) {\n      var v1 = _vertexPool[a];\n      var v2 = _vertexPool[b];\n      var v3 = _vertexPool[c];\n      if (checkTriangleVisibility(v1, v2, v3) === false) return;\n      if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n        _face = getNextFaceInPool();\n        _face.id = object.id;\n        _face.v1.copy(v1);\n        _face.v2.copy(v2);\n        _face.v3.copy(v3);\n        _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n        _face.renderOrder = object.renderOrder; // face normal\n\n        _vector3.subVectors(v3.position, v2.position);\n        _vector4.subVectors(v1.position, v2.position);\n        _vector3.cross(_vector4);\n        _face.normalModel.copy(_vector3);\n        _face.normalModel.applyMatrix3(normalMatrix).normalize();\n        for (var i = 0; i < 3; i++) {\n          var normal = _face.vertexNormalsModel[i];\n          normal.fromArray(normals, arguments[i] * 3);\n          normal.applyMatrix3(normalMatrix).normalize();\n          var uv = _face.uvs[i];\n          uv.fromArray(uvs, arguments[i] * 2);\n        }\n        _face.vertexNormalsLength = 3;\n        _face.material = material;\n        if (material.vertexColors) {\n          _face.color.fromArray(colors, a * 3);\n        }\n        _renderData.elements.push(_face);\n      }\n    }\n    return {\n      setObject: setObject,\n      projectVertex: projectVertex,\n      checkTriangleVisibility: checkTriangleVisibility,\n      checkBackfaceCulling: checkBackfaceCulling,\n      pushVertex: pushVertex,\n      pushNormal: pushNormal,\n      pushColor: pushColor,\n      pushUv: pushUv,\n      pushLine: pushLine,\n      pushTriangle: pushTriangle\n    };\n  };\n  var renderList = new RenderList();\n  function projectObject(object) {\n    if (object.visible === false) return;\n    if (object.isLight) {\n      _renderData.lights.push(object);\n    } else if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material.visible === false) return;\n      if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;\n      addObject(object);\n    } else if (object.isSprite) {\n      if (object.material.visible === false) return;\n      if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;\n      addObject(object);\n    }\n    var children = object.children;\n    for (var i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i]);\n    }\n  }\n  function addObject(object) {\n    _object = getNextObjectInPool();\n    _object.id = object.id;\n    _object.object = object;\n    _vector3.setFromMatrixPosition(object.matrixWorld);\n    _vector3.applyMatrix4(_viewProjectionMatrix);\n    _object.z = _vector3.z;\n    _object.renderOrder = object.renderOrder;\n    _renderData.objects.push(_object);\n  }\n  this.projectScene = function (scene, camera, sortObjects, sortElements) {\n    _faceCount = 0;\n    _lineCount = 0;\n    _spriteCount = 0;\n    _renderData.elements.length = 0;\n    if (scene.autoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n    _viewMatrix.copy(camera.matrixWorldInverse);\n    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n    _frustum.setFromProjectionMatrix(_viewProjectionMatrix); //\n\n    _objectCount = 0;\n    _renderData.objects.length = 0;\n    _renderData.lights.length = 0;\n    projectObject(scene);\n    if (sortObjects === true) {\n      _renderData.objects.sort(painterSort);\n    } //\n\n    var objects = _renderData.objects;\n    for (var o = 0, ol = objects.length; o < ol; o++) {\n      var object = objects[o].object;\n      var geometry = object.geometry;\n      renderList.setObject(object);\n      _modelMatrix = object.matrixWorld;\n      _vertexCount = 0;\n      if (object.isMesh) {\n        if (geometry.isBufferGeometry) {\n          var material = object.material;\n          var isMultiMaterial = Array.isArray(material);\n          var attributes = geometry.attributes;\n          var groups = geometry.groups;\n          if (attributes.position === undefined) continue;\n          var positions = attributes.position.array;\n          for (var i = 0, l = positions.length; i < l; i += 3) {\n            var x = positions[i];\n            var y = positions[i + 1];\n            var z = positions[i + 2];\n            if (material.morphTargets === true) {\n              var morphTargets = geometry.morphAttributes.position;\n              var morphTargetsRelative = geometry.morphTargetsRelative;\n              var morphInfluences = object.morphTargetInfluences;\n              for (var t = 0, tl = morphTargets.length; t < tl; t++) {\n                var influence = morphInfluences[t];\n                if (influence === 0) continue;\n                var target = morphTargets[t];\n                if (morphTargetsRelative) {\n                  x += target.getX(i / 3) * influence;\n                  y += target.getY(i / 3) * influence;\n                  z += target.getZ(i / 3) * influence;\n                } else {\n                  x += (target.getX(i / 3) - positions[i]) * influence;\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence;\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence;\n                }\n              }\n            }\n            renderList.pushVertex(x, y, z);\n          }\n          if (attributes.normal !== undefined) {\n            var normals = attributes.normal.array;\n            for (var _i = 0, _l = normals.length; _i < _l; _i += 3) {\n              renderList.pushNormal(normals[_i], normals[_i + 1], normals[_i + 2]);\n            }\n          }\n          if (attributes.color !== undefined) {\n            var colors = attributes.color.array;\n            for (var _i2 = 0, _l2 = colors.length; _i2 < _l2; _i2 += 3) {\n              renderList.pushColor(colors[_i2], colors[_i2 + 1], colors[_i2 + 2]);\n            }\n          }\n          if (attributes.uv !== undefined) {\n            var uvs = attributes.uv.array;\n            for (var _i3 = 0, _l3 = uvs.length; _i3 < _l3; _i3 += 2) {\n              renderList.pushUv(uvs[_i3], uvs[_i3 + 1]);\n            }\n          }\n          if (geometry.index !== null) {\n            var indices = geometry.index.array;\n            if (groups.length > 0) {\n              for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === undefined) continue;\n                for (var _i4 = group.start, _l4 = group.start + group.count; _i4 < _l4; _i4 += 3) {\n                  renderList.pushTriangle(indices[_i4], indices[_i4 + 1], indices[_i4 + 2], material);\n                }\n              }\n            } else {\n              for (var _i5 = 0, _l5 = indices.length; _i5 < _l5; _i5 += 3) {\n                renderList.pushTriangle(indices[_i5], indices[_i5 + 1], indices[_i5 + 2], material);\n              }\n            }\n          } else {\n            if (groups.length > 0) {\n              for (var _g = 0; _g < groups.length; _g++) {\n                var group = groups[_g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === undefined) continue;\n                for (var _i6 = group.start, _l6 = group.start + group.count; _i6 < _l6; _i6 += 3) {\n                  renderList.pushTriangle(_i6, _i6 + 1, _i6 + 2, material);\n                }\n              }\n            } else {\n              for (var _i7 = 0, _l7 = positions.length / 3; _i7 < _l7; _i7 += 3) {\n                renderList.pushTriangle(_i7, _i7 + 1, _i7 + 2, material);\n              }\n            }\n          }\n        } else if (geometry.isGeometry) {\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        }\n      } else if (object.isLine) {\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n        if (geometry.isBufferGeometry) {\n          var attributes = geometry.attributes;\n          if (attributes.position !== undefined) {\n            var positions = attributes.position.array;\n            for (var _i8 = 0, _l8 = positions.length; _i8 < _l8; _i8 += 3) {\n              renderList.pushVertex(positions[_i8], positions[_i8 + 1], positions[_i8 + 2]);\n            }\n            if (attributes.color !== undefined) {\n              var colors = attributes.color.array;\n              for (var _i9 = 0, _l9 = colors.length; _i9 < _l9; _i9 += 3) {\n                renderList.pushColor(colors[_i9], colors[_i9 + 1], colors[_i9 + 2]);\n              }\n            }\n            if (geometry.index !== null) {\n              var indices = geometry.index.array;\n              for (var _i10 = 0, _l10 = indices.length; _i10 < _l10; _i10 += 2) {\n                renderList.pushLine(indices[_i10], indices[_i10 + 1]);\n              }\n            } else {\n              var step = object.isLineSegments ? 2 : 1;\n              for (var _i11 = 0, _l11 = positions.length / 3 - 1; _i11 < _l11; _i11 += step) {\n                renderList.pushLine(_i11, _i11 + 1);\n              }\n            }\n          }\n        } else if (geometry.isGeometry) {\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        }\n      } else if (object.isPoints) {\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n        if (geometry.isGeometry) {\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        } else if (geometry.isBufferGeometry) {\n          var attributes = geometry.attributes;\n          if (attributes.position !== undefined) {\n            var positions = attributes.position.array;\n            for (var _i12 = 0, _l12 = positions.length; _i12 < _l12; _i12 += 3) {\n              _vector4.set(positions[_i12], positions[_i12 + 1], positions[_i12 + 2], 1);\n              _vector4.applyMatrix4(_modelViewProjectionMatrix);\n              pushPoint(_vector4, object, camera);\n            }\n          }\n        }\n      } else if (object.isSprite) {\n        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n        _vector4.applyMatrix4(_viewProjectionMatrix);\n        pushPoint(_vector4, object, camera);\n      }\n    }\n    if (sortElements === true) {\n      _renderData.elements.sort(painterSort);\n    }\n    return _renderData;\n  };\n  function pushPoint(_vector4, object, camera) {\n    var invW = 1 / _vector4.w;\n    _vector4.z *= invW;\n    if (_vector4.z >= -1 && _vector4.z <= 1) {\n      _sprite = getNextSpriteInPool();\n      _sprite.id = object.id;\n      _sprite.x = _vector4.x * invW;\n      _sprite.y = _vector4.y * invW;\n      _sprite.z = _vector4.z;\n      _sprite.renderOrder = object.renderOrder;\n      _sprite.object = object;\n      _sprite.rotation = object.rotation;\n      _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));\n      _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));\n      _sprite.material = object.material;\n      _renderData.elements.push(_sprite);\n    }\n  } // Pools\n\n  function getNextObjectInPool() {\n    if (_objectCount === _objectPoolLength) {\n      var object = new RenderableObject();\n      _objectPool.push(object);\n      _objectPoolLength++;\n      _objectCount++;\n      return object;\n    }\n    return _objectPool[_objectCount++];\n  }\n  function getNextVertexInPool() {\n    if (_vertexCount === _vertexPoolLength) {\n      var vertex = new RenderableVertex();\n      _vertexPool.push(vertex);\n      _vertexPoolLength++;\n      _vertexCount++;\n      return vertex;\n    }\n    return _vertexPool[_vertexCount++];\n  }\n  function getNextFaceInPool() {\n    if (_faceCount === _facePoolLength) {\n      var face = new RenderableFace();\n      _facePool.push(face);\n      _facePoolLength++;\n      _faceCount++;\n      return face;\n    }\n    return _facePool[_faceCount++];\n  }\n  function getNextLineInPool() {\n    if (_lineCount === _linePoolLength) {\n      var line = new RenderableLine();\n      _linePool.push(line);\n      _linePoolLength++;\n      _lineCount++;\n      return line;\n    }\n    return _linePool[_lineCount++];\n  }\n  function getNextSpriteInPool() {\n    if (_spriteCount === _spritePoolLength) {\n      var sprite = new RenderableSprite();\n      _spritePool.push(sprite);\n      _spritePoolLength++;\n      _spriteCount++;\n      return sprite;\n    }\n    return _spritePool[_spriteCount++];\n  } //\n\n  function painterSort(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.z !== b.z) {\n      return b.z - a.z;\n    } else if (a.id !== b.id) {\n      return a.id - b.id;\n    } else {\n      return 0;\n    }\n  }\n  function clipLine(s1, s2) {\n    var alpha1 = 0,\n      alpha2 = 1,\n      // Calculate the boundary coordinate of each vertex for the near and far clip planes,\n      // Z = -1 and Z = +1, respectively.\n      bc1near = s1.z + s1.w,\n      bc2near = s2.z + s2.w,\n      bc1far = -s1.z + s1.w,\n      bc2far = -s2.z + s2.w;\n    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n      // Both vertices lie entirely within all clip planes.\n      return true;\n    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\n      // Both vertices lie entirely outside one of the clip planes.\n      return false;\n    } else {\n      // The line segment spans at least one clip plane.\n      if (bc1near < 0) {\n        // v1 lies outside the near plane, v2 inside\n        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n      } else if (bc2near < 0) {\n        // v2 lies outside the near plane, v1 inside\n        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n      }\n      if (bc1far < 0) {\n        // v1 lies outside the far plane, v2 inside\n        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n      } else if (bc2far < 0) {\n        // v2 lies outside the far plane, v2 inside\n        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n      }\n      if (alpha2 < alpha1) {\n        // The line segment spans two boundaries, but is outside both of them.\n        // (This can't happen when we're only clipping against just near/far but good\n        //  to leave the check here for future usage if other clip planes are added.)\n        return false;\n      } else {\n        // Update the s1 and s2 vertices to match the clipped line segment.\n        s1.lerp(s2, alpha1);\n        s2.lerp(s1, 1 - alpha2);\n        return true;\n      }\n    }\n  }\n};\nexport { Projector, RenderableFace, RenderableLine, RenderableObject, RenderableSprite, RenderableVertex };","map":null,"metadata":{},"sourceType":"module"}