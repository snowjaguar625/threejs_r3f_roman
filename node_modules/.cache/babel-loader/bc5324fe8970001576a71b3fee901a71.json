{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, MeshStandardMaterial, Color, TextureLoader, Object3D, Matrix4, BufferGeometryLoader, DirectionalLight, PointLight, RectAreaLight, Vector3, SpotLight, CanvasTexture, LinearFilter, ClampToEdgeWrapping, SpriteMaterial, Sprite, LineBasicMaterial, Line, Mesh, PointsMaterial, Points } from 'three';\nvar _taskCache = new WeakMap();\nvar Rhino3dmLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(Rhino3dmLoader, _Loader);\n  function Rhino3dmLoader(manager) {\n    var _this;\n    _classCallCheck(this, Rhino3dmLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rhino3dmLoader).call(this, manager));\n    _this.libraryPath = '';\n    _this.libraryPending = null;\n    _this.libraryBinary = null;\n    _this.libraryConfig = {};\n    _this.url = '';\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = '';\n    _this.workerConfig = {};\n    _this.materials = [];\n    return _this;\n  }\n  _createClass(Rhino3dmLoader, [{\n    key: \"setLibraryPath\",\n    value: function setLibraryPath(path) {\n      this.libraryPath = path;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      this.url = url;\n      loader.load(url, function (buffer) {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          var cachedTask = _taskCache.get(buffer);\n          return cachedTask.promise.then(onLoad).catch(onError);\n        }\n        _this2.decodeObjects(buffer, url).then(onLoad).catch(onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log('Task load: ', this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"decodeObjects\",\n    value: function decodeObjects(buffer, url) {\n      var _this3 = this;\n      var worker;\n      var taskID;\n      var taskCost = buffer.byteLength;\n      var objectPending = this._getWorker(taskCost).then(function (_worker) {\n        worker = _worker;\n        taskID = _this3.workerNextTaskID++; //hmmm\n\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: 'decode',\n            id: taskID,\n            buffer: buffer\n          }, [buffer]); //this.debug();\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.data);\n      }); // Remove task from the task list.\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n      objectPending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID); //this.debug();\n        }\n      }); // Cache the task result.\n\n      _taskCache.set(buffer, {\n        url: url,\n        promise: objectPending\n      });\n      return objectPending;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, onLoad, onError) {\n      this.decodeObjects(data, '').then(onLoad).catch(onError);\n    }\n  }, {\n    key: \"_compareMaterials\",\n    value: function _compareMaterials(material) {\n      var mat = {};\n      mat.name = material.name;\n      mat.color = {};\n      mat.color.r = material.color.r;\n      mat.color.g = material.color.g;\n      mat.color.b = material.color.b;\n      mat.type = material.type;\n      for (var i = 0; i < this.materials.length; i++) {\n        var m = this.materials[i];\n        var _mat = {};\n        _mat.name = m.name;\n        _mat.color = {};\n        _mat.color.r = m.color.r;\n        _mat.color.g = m.color.g;\n        _mat.color.b = m.color.b;\n        _mat.type = m.type;\n        if (JSON.stringify(mat) === JSON.stringify(_mat)) {\n          return m;\n        }\n      }\n      this.materials.push(material);\n      return material;\n    }\n  }, {\n    key: \"_createMaterial\",\n    value: function _createMaterial(material) {\n      if (material === undefined) {\n        return new MeshStandardMaterial({\n          color: new Color(1, 1, 1),\n          metalness: 0.8,\n          name: 'default',\n          side: 2\n        });\n      }\n      var _diffuseColor = material.diffuseColor;\n      var diffusecolor = new Color(_diffuseColor.r / 255.0, _diffuseColor.g / 255.0, _diffuseColor.b / 255.0);\n      if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {\n        diffusecolor.r = 1;\n        diffusecolor.g = 1;\n        diffusecolor.b = 1;\n      } // console.log( material );\n\n      var mat = new MeshStandardMaterial({\n        color: diffusecolor,\n        name: material.name,\n        side: 2,\n        transparent: material.transparency > 0 ? true : false,\n        opacity: 1.0 - material.transparency\n      });\n      var textureLoader = new TextureLoader();\n      for (var i = 0; i < material.textures.length; i++) {\n        var texture = material.textures[i];\n        if (texture.image !== null) {\n          var map = textureLoader.load(texture.image);\n          switch (texture.type) {\n            case 'Diffuse':\n              mat.map = map;\n              break;\n            case 'Bump':\n              mat.bumpMap = map;\n              break;\n            case 'Transparency':\n              mat.alphaMap = map;\n              mat.transparent = true;\n              break;\n            case 'Emap':\n              mat.envMap = map;\n              break;\n          }\n        }\n      }\n      return mat;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(data) {\n      // console.log(data);\n      var object = new Object3D();\n      var instanceDefinitionObjects = [];\n      var instanceDefinitions = [];\n      var instanceReferences = [];\n      object.userData['layers'] = data.layers;\n      object.userData['groups'] = data.groups;\n      object.userData['settings'] = data.settings;\n      object.userData['objectType'] = 'File3dm';\n      object.userData['materials'] = null;\n      object.name = this.url;\n      var objects = data.objects;\n      var materials = data.materials;\n      for (var i = 0; i < objects.length; i++) {\n        var obj = objects[i];\n        var attributes = obj.attributes;\n        switch (obj.objectType) {\n          case 'InstanceDefinition':\n            instanceDefinitions.push(obj);\n            break;\n          case 'InstanceReference':\n            instanceReferences.push(obj);\n            break;\n          default:\n            var _object = void 0;\n            if (attributes.materialIndex >= 0) {\n              var rMaterial = materials[attributes.materialIndex];\n              var material = this._createMaterial(rMaterial);\n              material = this._compareMaterials(material);\n              _object = this._createObject(obj, material);\n            } else {\n              var _material2 = this._createMaterial();\n              _object = this._createObject(obj, _material2);\n            }\n            if (_object === undefined) {\n              continue;\n            }\n            var layer = data.layers[attributes.layerIndex];\n            _object.visible = layer ? data.layers[attributes.layerIndex].visible : true;\n            if (attributes.isInstanceDefinitionObject) {\n              instanceDefinitionObjects.push(_object);\n            } else {\n              object.add(_object);\n            }\n            break;\n        }\n      }\n      for (var _i = 0; _i < instanceDefinitions.length; _i++) {\n        var iDef = instanceDefinitions[_i];\n        objects = [];\n        for (var j = 0; j < iDef.attributes.objectIds.length; j++) {\n          var objId = iDef.attributes.objectIds[j];\n          for (var p = 0; p < instanceDefinitionObjects.length; p++) {\n            var idoId = instanceDefinitionObjects[p].userData.attributes.id;\n            if (objId === idoId) {\n              objects.push(instanceDefinitionObjects[p]);\n            }\n          }\n        } // Currently clones geometry and does not take advantage of instancing\n\n        for (var _j = 0; _j < instanceReferences.length; _j++) {\n          var iRef = instanceReferences[_j];\n          if (iRef.geometry.parentIdefId === iDef.attributes.id) {\n            var iRefObject = new Object3D();\n            var xf = iRef.geometry.xform.array;\n            var matrix = new Matrix4();\n            matrix.set(xf[0], xf[1], xf[2], xf[3], xf[4], xf[5], xf[6], xf[7], xf[8], xf[9], xf[10], xf[11], xf[12], xf[13], xf[14], xf[15]);\n            iRefObject.applyMatrix4(matrix);\n            for (var _p = 0; _p < objects.length; _p++) {\n              iRefObject.add(objects[_p].clone(true));\n            }\n            object.add(iRefObject);\n          }\n        }\n      }\n      object.userData['materials'] = this.materials;\n      return object;\n    }\n  }, {\n    key: \"_createObject\",\n    value: function _createObject(obj, mat) {\n      var loader = new BufferGeometryLoader();\n      var attributes = obj.attributes;\n      var geometry, material, _color, color;\n      switch (obj.objectType) {\n        case 'Point':\n        case 'PointSet':\n          geometry = loader.parse(obj.geometry);\n          if (geometry.attributes.hasOwnProperty('color')) {\n            material = new PointsMaterial({\n              vertexColors: true,\n              sizeAttenuation: false,\n              size: 2\n            });\n          } else {\n            _color = attributes.drawColor;\n            color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0);\n            material = new PointsMaterial({\n              color: color,\n              sizeAttenuation: false,\n              size: 2\n            });\n          }\n          material = this._compareMaterials(material);\n          var points = new Points(geometry, material);\n          points.userData['attributes'] = attributes;\n          points.userData['objectType'] = obj.objectType;\n          if (attributes.name) {\n            points.name = attributes.name;\n          }\n          return points;\n        case 'Mesh':\n        case 'Extrusion':\n        case 'SubD':\n        case 'Brep':\n          if (obj.geometry === null) return;\n          geometry = loader.parse(obj.geometry);\n          if (geometry.attributes.hasOwnProperty('color')) {\n            mat.vertexColors = true;\n          }\n          if (mat === null) {\n            mat = this._createMaterial();\n            mat = this._compareMaterials(mat);\n          }\n          var mesh = new Mesh(geometry, mat);\n          mesh.castShadow = attributes.castsShadows;\n          mesh.receiveShadow = attributes.receivesShadows;\n          mesh.userData['attributes'] = attributes;\n          mesh.userData['objectType'] = obj.objectType;\n          if (attributes.name) {\n            mesh.name = attributes.name;\n          }\n          return mesh;\n        case 'Curve':\n          geometry = loader.parse(obj.geometry);\n          _color = attributes.drawColor;\n          color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0);\n          material = new LineBasicMaterial({\n            color: color\n          });\n          material = this._compareMaterials(material);\n          var lines = new Line(geometry, material);\n          lines.userData['attributes'] = attributes;\n          lines.userData['objectType'] = obj.objectType;\n          if (attributes.name) {\n            lines.name = attributes.name;\n          }\n          return lines;\n        case 'TextDot':\n          geometry = obj.geometry;\n          var ctx = document.createElement('canvas').getContext('2d');\n          var font = \"\".concat(geometry.fontHeight, \"px \").concat(geometry.fontFace);\n          ctx.font = font;\n          var width = ctx.measureText(geometry.text).width + 10;\n          var height = geometry.fontHeight + 10;\n          var r = window.devicePixelRatio;\n          ctx.canvas.width = width * r;\n          ctx.canvas.height = height * r;\n          ctx.canvas.style.width = width + 'px';\n          ctx.canvas.style.height = height + 'px';\n          ctx.setTransform(r, 0, 0, r, 0, 0);\n          ctx.font = font;\n          ctx.textBaseline = 'middle';\n          ctx.textAlign = 'center';\n          color = attributes.drawColor;\n          ctx.fillStyle = \"rgba(\".concat(color.r, \",\").concat(color.g, \",\").concat(color.b, \",\").concat(color.a, \")\");\n          ctx.fillRect(0, 0, width, height);\n          ctx.fillStyle = 'white';\n          ctx.fillText(geometry.text, width / 2, height / 2);\n          var texture = new CanvasTexture(ctx.canvas);\n          texture.minFilter = LinearFilter;\n          texture.wrapS = ClampToEdgeWrapping;\n          texture.wrapT = ClampToEdgeWrapping;\n          material = new SpriteMaterial({\n            map: texture,\n            depthTest: false\n          });\n          var sprite = new Sprite(material);\n          sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2]);\n          sprite.scale.set(width / 10, height / 10, 1.0);\n          sprite.userData['attributes'] = attributes;\n          sprite.userData['objectType'] = obj.objectType;\n          if (attributes.name) {\n            sprite.name = attributes.name;\n          }\n          return sprite;\n        case 'Light':\n          geometry = obj.geometry;\n          var light;\n          if (geometry.isDirectionalLight) {\n            light = new DirectionalLight();\n            light.castShadow = attributes.castsShadows;\n            light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n            light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);\n            light.shadow.normalBias = 0.1;\n          } else if (geometry.isPointLight) {\n            light = new PointLight();\n            light.castShadow = attributes.castsShadows;\n            light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n            light.shadow.normalBias = 0.1;\n          } else if (geometry.isRectangularLight) {\n            light = new RectAreaLight();\n            var _width = Math.abs(geometry.width[2]);\n            var _height = Math.abs(geometry.length[0]);\n            light.position.set(geometry.location[0] - _height / 2, geometry.location[1], geometry.location[2] - _width / 2);\n            light.height = _height;\n            light.width = _width;\n            light.lookAt(new Vector3(geometry.direction[0], geometry.direction[1], geometry.direction[2]));\n          } else if (geometry.isSpotLight) {\n            light = new SpotLight();\n            light.castShadow = attributes.castsShadows;\n            light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n            light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);\n            light.angle = geometry.spotAngleRadians;\n            light.shadow.normalBias = 0.1;\n          } else if (geometry.isLinearLight) {\n            console.warn('THREE.3DMLoader:  No conversion exists for linear lights.');\n            return;\n          }\n          if (light) {\n            light.intensity = geometry.intensity;\n            _color = geometry.diffuse;\n            color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0);\n            light.color = color;\n            light.userData['attributes'] = attributes;\n            light.userData['objectType'] = obj.objectType;\n          }\n          return light;\n      }\n    }\n  }, {\n    key: \"_initLibrary\",\n    value: function _initLibrary() {\n      var _this4 = this;\n      if (!this.libraryPending) {\n        // Load rhino3dm wrapper.\n        var jsLoader = new FileLoader(this.manager);\n        jsLoader.setPath(this.libraryPath);\n        var jsContent = new Promise(function (resolve, reject) {\n          jsLoader.load('rhino3dm.js', resolve, undefined, reject);\n        }); // Load rhino3dm WASM binary.\n\n        var binaryLoader = new FileLoader(this.manager);\n        binaryLoader.setPath(this.libraryPath);\n        binaryLoader.setResponseType('arraybuffer');\n        var binaryContent = new Promise(function (resolve, reject) {\n          binaryLoader.load('rhino3dm.wasm', resolve, undefined, reject);\n        });\n        this.libraryPending = Promise.all([jsContent, binaryContent]).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            jsContent = _ref2[0],\n            binaryContent = _ref2[1];\n          //this.libraryBinary = binaryContent;\n          _this4.libraryConfig.wasmBinary = binaryContent;\n          var fn = Rhino3dmWorker.toString();\n          var body = ['/* rhino3dm.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n          _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        });\n      }\n      return this.libraryPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskCost) {\n      var _this5 = this;\n      return this._initLibrary().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var _worker2 = new Worker(_this5.workerSourceURL);\n          _worker2._callbacks = {};\n          _worker2._taskCosts = {};\n          _worker2._taskLoad = 0;\n          _worker2.postMessage({\n            type: 'init',\n            libraryConfig: _this5.libraryConfig\n          });\n          _worker2.onmessage = function (e) {\n            var message = e.data;\n            switch (message.type) {\n              case 'decode':\n                _worker2._callbacks[message.id].resolve(message);\n                break;\n              case 'error':\n                _worker2._callbacks[message.id].reject(message);\n                break;\n              default:\n                console.error('THREE.Rhino3dmLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n          _this5.workerPool.push(_worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n  return Rhino3dmLoader;\n}(Loader);\n/* WEB WORKER */\nfunction Rhino3dmWorker() {\n  var libraryPending;\n  var libraryConfig;\n  var rhino;\n  onmessage = function onmessage(e) {\n    var message = e.data;\n    switch (message.type) {\n      case 'init':\n        libraryConfig = message.libraryConfig;\n        var wasmBinary = libraryConfig.wasmBinary;\n        var RhinoModule;\n        libraryPending = new Promise(function (resolve) {\n          /* Like Basis Loader */\n          RhinoModule = {\n            wasmBinary: wasmBinary,\n            onRuntimeInitialized: resolve\n          };\n          rhino3dm(RhinoModule); // eslint-disable-line no-undef\n        }).then(function () {\n          rhino = RhinoModule;\n        });\n        break;\n      case 'decode':\n        var buffer = message.buffer;\n        libraryPending.then(function () {\n          var data = decodeObjects(rhino, buffer);\n          self.postMessage({\n            type: 'decode',\n            id: message.id,\n            data: data\n          });\n        });\n        break;\n    }\n  };\n  function decodeObjects(rhino, buffer) {\n    var arr = new Uint8Array(buffer);\n    var doc = rhino.File3dm.fromByteArray(arr);\n    var objects = [];\n    var materials = [];\n    var layers = [];\n    var views = [];\n    var namedViews = [];\n    var groups = []; //Handle objects\n\n    var objs = doc.objects();\n    var cnt = objs.count;\n    for (var i = 0; i < cnt; i++) {\n      var _object = objs.get(i);\n      var object = extractObjectData(_object, doc);\n      _object.delete();\n      if (object) {\n        objects.push(object);\n      }\n    } // Handle instance definitions\n    // console.log( `Instance Definitions Count: ${doc.instanceDefinitions().count()}` );\n\n    for (var _i2 = 0; _i2 < doc.instanceDefinitions().count(); _i2++) {\n      var idef = doc.instanceDefinitions().get(_i2);\n      var idefAttributes = extractProperties(idef);\n      idefAttributes.objectIds = idef.getObjectIds();\n      objects.push({\n        geometry: null,\n        attributes: idefAttributes,\n        objectType: 'InstanceDefinition'\n      });\n    } // Handle materials\n\n    var textureTypes = [\n    // rhino.TextureType.Bitmap,\n    rhino.TextureType.Diffuse, rhino.TextureType.Bump, rhino.TextureType.Transparency, rhino.TextureType.Opacity, rhino.TextureType.Emap];\n    var pbrTextureTypes = [rhino.TextureType.PBR_BaseColor, rhino.TextureType.PBR_Subsurface, rhino.TextureType.PBR_SubsurfaceScattering, rhino.TextureType.PBR_SubsurfaceScatteringRadius, rhino.TextureType.PBR_Metallic, rhino.TextureType.PBR_Specular, rhino.TextureType.PBR_SpecularTint, rhino.TextureType.PBR_Roughness, rhino.TextureType.PBR_Anisotropic, rhino.TextureType.PBR_Anisotropic_Rotation, rhino.TextureType.PBR_Sheen, rhino.TextureType.PBR_SheenTint, rhino.TextureType.PBR_Clearcoat, rhino.TextureType.PBR_ClearcoatBump, rhino.TextureType.PBR_ClearcoatRoughness, rhino.TextureType.PBR_OpacityIor, rhino.TextureType.PBR_OpacityRoughness, rhino.TextureType.PBR_Emission, rhino.TextureType.PBR_AmbientOcclusion, rhino.TextureType.PBR_Displacement];\n    for (var _i3 = 0; _i3 < doc.materials().count(); _i3++) {\n      var _material = doc.materials().get(_i3);\n      var _pbrMaterial = _material.physicallyBased();\n      var material = extractProperties(_material);\n      var textures = [];\n      for (var j = 0; j < textureTypes.length; j++) {\n        var _texture = _material.getTexture(textureTypes[j]);\n        if (_texture) {\n          var textureType = textureTypes[j].constructor.name;\n          textureType = textureType.substring(12, textureType.length);\n          var texture = {\n            type: textureType\n          };\n          var image = doc.getEmbeddedFileAsBase64(_texture.fileName);\n          if (image) {\n            texture.image = 'data:image/png;base64,' + image;\n          } else {\n            console.warn(\"THREE.3DMLoader: Image for \".concat(textureType, \" texture not embedded in file.\"));\n            texture.image = null;\n          }\n          textures.push(texture);\n          _texture.delete();\n        }\n      }\n      material.textures = textures;\n      if (_pbrMaterial.supported) {\n        console.log('pbr true');\n        for (var _j2 = 0; _j2 < pbrTextureTypes.length; _j2++) {\n          var _texture2 = _material.getTexture(textureTypes[_j2]);\n          if (_texture2) {\n            var _image = doc.getEmbeddedFileAsBase64(_texture2.fileName);\n            var _textureType = textureTypes[_j2].constructor.name;\n            _textureType = _textureType.substring(12, _textureType.length);\n            var _texture3 = {\n              type: _textureType,\n              image: 'data:image/png;base64,' + _image\n            };\n            textures.push(_texture3);\n            _texture2.delete();\n          }\n        }\n        var pbMaterialProperties = extractProperties(_material.physicallyBased());\n        material = Object.assign(pbMaterialProperties, material);\n      }\n      materials.push(material);\n      _material.delete();\n      _pbrMaterial.delete();\n    } // Handle layers\n\n    for (var _i4 = 0; _i4 < doc.layers().count(); _i4++) {\n      var _layer = doc.layers().get(_i4);\n      var layer = extractProperties(_layer);\n      layers.push(layer);\n      _layer.delete();\n    } // Handle views\n\n    for (var _i5 = 0; _i5 < doc.views().count(); _i5++) {\n      var _view = doc.views().get(_i5);\n      var view = extractProperties(_view);\n      views.push(view);\n      _view.delete();\n    } // Handle named views\n\n    for (var _i6 = 0; _i6 < doc.namedViews().count(); _i6++) {\n      var _namedView = doc.namedViews().get(_i6);\n      var namedView = extractProperties(_namedView);\n      namedViews.push(namedView);\n      _namedView.delete();\n    } // Handle groups\n\n    for (var _i7 = 0; _i7 < doc.groups().count(); _i7++) {\n      var _group = doc.groups().get(_i7);\n      var group = extractProperties(_group);\n      groups.push(group);\n      _group.delete();\n    } // Handle settings\n\n    var settings = extractProperties(doc.settings()); //TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.\n    // Handle dimstyles\n    // console.log( `Dimstyle Count: ${doc.dimstyles().count()}` );\n    // Handle bitmaps\n    // console.log( `Bitmap Count: ${doc.bitmaps().count()}` );\n    // Handle strings -- this seems to be broken at the moment in rhino3dm\n    // console.log( `Document Strings Count: ${doc.strings().count()}` );\n\n    /*\n    for( var i = 0; i < doc.strings().count(); i++ ){\n    var _string= doc.strings().get( i );\n    console.log(_string);\n    var string = extractProperties( _group );\n    strings.push( string );\n    _string.delete();\n    }\n    */\n\n    doc.delete();\n    return {\n      objects: objects,\n      materials: materials,\n      layers: layers,\n      views: views,\n      namedViews: namedViews,\n      groups: groups,\n      settings: settings\n    };\n  }\n  function extractObjectData(object, doc) {\n    var _geometry = object.geometry();\n    var _attributes = object.attributes();\n    var objectType = _geometry.objectType;\n    var geometry, attributes, position, data, mesh; // skip instance definition objects\n    //if( _attributes.isInstanceDefinitionObject ) { continue; }\n    // TODO: handle other geometry types\n\n    switch (objectType) {\n      case rhino.ObjectType.Curve:\n        var pts = curveToPoints(_geometry, 100);\n        position = {};\n        attributes = {};\n        data = {};\n        position.itemSize = 3;\n        position.type = 'Float32Array';\n        position.array = [];\n        for (var j = 0; j < pts.length; j++) {\n          position.array.push(pts[j][0]);\n          position.array.push(pts[j][1]);\n          position.array.push(pts[j][2]);\n        }\n        attributes.position = position;\n        data.attributes = attributes;\n        geometry = {\n          data: data\n        };\n        break;\n      case rhino.ObjectType.Point:\n        var pt = _geometry.location;\n        position = {};\n        var color = {};\n        attributes = {};\n        data = {};\n        position.itemSize = 3;\n        position.type = 'Float32Array';\n        position.array = [pt[0], pt[1], pt[2]];\n        var _color = _attributes.drawColor(doc);\n        color.itemSize = 3;\n        color.type = 'Float32Array';\n        color.array = [_color.r / 255.0, _color.g / 255.0, _color.b / 255.0];\n        attributes.position = position;\n        attributes.color = color;\n        data.attributes = attributes;\n        geometry = {\n          data: data\n        };\n        break;\n      case rhino.ObjectType.PointSet:\n      case rhino.ObjectType.Mesh:\n        geometry = _geometry.toThreejsJSON();\n        break;\n      case rhino.ObjectType.Brep:\n        var faces = _geometry.faces();\n        mesh = new rhino.Mesh();\n        for (var faceIndex = 0; faceIndex < faces.count; faceIndex++) {\n          var face = faces.get(faceIndex);\n          var _mesh = face.getMesh(rhino.MeshType.Any);\n          if (_mesh) {\n            mesh.append(_mesh);\n            _mesh.delete();\n          }\n          face.delete();\n        }\n        if (mesh.faces().count > 0) {\n          mesh.compact();\n          geometry = mesh.toThreejsJSON();\n          faces.delete();\n        }\n        mesh.delete();\n        break;\n      case rhino.ObjectType.Extrusion:\n        mesh = _geometry.getMesh(rhino.MeshType.Any);\n        if (mesh) {\n          geometry = mesh.toThreejsJSON();\n          mesh.delete();\n        }\n        break;\n      case rhino.ObjectType.TextDot:\n        geometry = extractProperties(_geometry);\n        break;\n      case rhino.ObjectType.Light:\n        geometry = extractProperties(_geometry);\n        break;\n      case rhino.ObjectType.InstanceReference:\n        geometry = extractProperties(_geometry);\n        geometry.xform = extractProperties(_geometry.xform);\n        geometry.xform.array = _geometry.xform.toFloatArray(true);\n        break;\n      case rhino.ObjectType.SubD:\n        // TODO: precalculate resulting vertices and faces and warn on excessive results\n        _geometry.subdivide(3);\n        mesh = rhino.Mesh.createFromSubDControlNet(_geometry);\n        if (mesh) {\n          geometry = mesh.toThreejsJSON();\n          mesh.delete();\n        }\n        break;\n\n      /*\n      case rhino.ObjectType.Annotation:\n      case rhino.ObjectType.Hatch:\n      case rhino.ObjectType.ClipPlane:\n      */\n\n      default:\n        console.warn(\"THREE.3DMLoader: TODO: Implement \".concat(objectType.constructor.name));\n        break;\n    }\n    if (geometry) {\n      attributes = extractProperties(_attributes);\n      attributes.geometry = extractProperties(_geometry);\n      if (_attributes.groupCount > 0) {\n        attributes.groupIds = _attributes.getGroupList();\n      }\n      if (_attributes.userStringCount > 0) {\n        attributes.userStrings = _attributes.getUserStrings();\n      }\n      if (_geometry.userStringCount > 0) {\n        attributes.geometry.userStrings = _geometry.getUserStrings();\n      }\n      attributes.drawColor = _attributes.drawColor(doc);\n      objectType = objectType.constructor.name;\n      objectType = objectType.substring(11, objectType.length);\n      return {\n        geometry: geometry,\n        attributes: attributes,\n        objectType: objectType\n      };\n    } else {\n      console.warn(\"THREE.3DMLoader: \".concat(objectType.constructor.name, \" has no associated mesh geometry.\"));\n    }\n  }\n  function extractProperties(object) {\n    var result = {};\n    for (var property in object) {\n      var value = object[property];\n      if (typeof value !== 'function') {\n        if (typeof value === 'object' && value !== null && value.hasOwnProperty('constructor')) {\n          result[property] = {\n            name: value.constructor.name,\n            value: value.value\n          };\n        } else {\n          result[property] = value;\n        }\n      }\n    }\n    return result;\n  }\n  function curveToPoints(curve, pointLimit) {\n    var pointCount = pointLimit;\n    var rc = [];\n    var ts = [];\n    if (curve instanceof rhino.LineCurve) {\n      return [curve.pointAtStart, curve.pointAtEnd];\n    }\n    if (curve instanceof rhino.PolylineCurve) {\n      pointCount = curve.pointCount;\n      for (var i = 0; i < pointCount; i++) {\n        rc.push(curve.point(i));\n      }\n      return rc;\n    }\n    if (curve instanceof rhino.PolyCurve) {\n      var segmentCount = curve.segmentCount;\n      for (var _i8 = 0; _i8 < segmentCount; _i8++) {\n        var segment = curve.segmentCurve(_i8);\n        var segmentArray = curveToPoints(segment, pointCount);\n        rc = rc.concat(segmentArray);\n        segment.delete();\n      }\n      return rc;\n    }\n    if (curve instanceof rhino.ArcCurve) {\n      pointCount = Math.floor(curve.angleDegrees / 5);\n      pointCount = pointCount < 2 ? 2 : pointCount; // alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399\n    }\n\n    if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {\n      var pLine = curve.tryGetPolyline();\n      for (var _i9 = 0; _i9 < pLine.count; _i9++) {\n        rc.push(pLine.get(_i9));\n      }\n      pLine.delete();\n      return rc;\n    }\n    var domain = curve.domain;\n    var divisions = pointCount - 1.0;\n    for (var j = 0; j < pointCount; j++) {\n      var t = domain[0] + j / divisions * (domain[1] - domain[0]);\n      if (t === domain[0] || t === domain[1]) {\n        ts.push(t);\n        continue;\n      }\n      var tan = curve.tangentAt(t);\n      var prevTan = curve.tangentAt(ts.slice(-1)[0]); // Duplicated from THREE.Vector3\n      // How to pass imports to worker?\n\n      var tS = tan[0] * tan[0] + tan[1] * tan[1] + tan[2] * tan[2];\n      var ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2];\n      var denominator = Math.sqrt(tS * ptS);\n      var angle = void 0;\n      if (denominator === 0) {\n        angle = Math.PI / 2;\n      } else {\n        var theta = (tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z) / denominator;\n        angle = Math.acos(Math.max(-1, Math.min(1, theta)));\n      }\n      if (angle < 0.1) continue;\n      ts.push(t);\n    }\n    rc = ts.map(function (t) {\n      return curve.pointAt(t);\n    });\n    return rc;\n  }\n}\nexport { Rhino3dmLoader };","map":null,"metadata":{},"sourceType":"module"}