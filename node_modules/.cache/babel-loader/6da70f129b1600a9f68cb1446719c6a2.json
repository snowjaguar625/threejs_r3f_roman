{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Matrix4, Vector3 } from 'three';\nvar inverseProjectionMatrix = new Matrix4();\nvar CSMFrustum = /*#__PURE__*/function () {\n  function CSMFrustum(data) {\n    _classCallCheck(this, CSMFrustum);\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n  _createClass(CSMFrustum, [{\n    key: \"setFromProjectionMatrix\",\n    value: function setFromProjectionMatrix(projectionMatrix, maxFar) {\n      var isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n      inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\n      // |     |\n      // 2 --- 1\n      // clip space spans from [-1, 1]\n\n      this.vertices.near[0].set(1, 1, -1);\n      this.vertices.near[1].set(1, -1, -1);\n      this.vertices.near[2].set(-1, -1, -1);\n      this.vertices.near[3].set(-1, 1, -1);\n      this.vertices.near.forEach(function (v) {\n        v.applyMatrix4(inverseProjectionMatrix);\n      });\n      this.vertices.far[0].set(1, 1, 1);\n      this.vertices.far[1].set(1, -1, 1);\n      this.vertices.far[2].set(-1, -1, 1);\n      this.vertices.far[3].set(-1, 1, 1);\n      this.vertices.far.forEach(function (v) {\n        v.applyMatrix4(inverseProjectionMatrix);\n        var absZ = Math.abs(v.z);\n        if (isOrthographic) {\n          v.z *= Math.min(maxFar / absZ, 1.0);\n        } else {\n          v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n        }\n      });\n      return this.vertices;\n    }\n  }, {\n    key: \"split\",\n    value: function split(breaks, target) {\n      while (breaks.length > target.length) {\n        target.push(new CSMFrustum());\n      }\n      target.length = breaks.length;\n      for (var i = 0; i < breaks.length; i++) {\n        var cascade = target[i];\n        if (i === 0) {\n          for (var j = 0; j < 4; j++) {\n            cascade.vertices.near[j].copy(this.vertices.near[j]);\n          }\n        } else {\n          for (var _j = 0; _j < 4; _j++) {\n            cascade.vertices.near[_j].lerpVectors(this.vertices.near[_j], this.vertices.far[_j], breaks[i - 1]);\n          }\n        }\n        if (i === breaks.length - 1) {\n          for (var _j2 = 0; _j2 < 4; _j2++) {\n            cascade.vertices.far[_j2].copy(this.vertices.far[_j2]);\n          }\n        } else {\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            cascade.vertices.far[_j3].lerpVectors(this.vertices.near[_j3], this.vertices.far[_j3], breaks[i]);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"toSpace\",\n    value: function toSpace(cameraMatrix, target) {\n      for (var i = 0; i < 4; i++) {\n        target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n        target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n      }\n    }\n  }]);\n  return CSMFrustum;\n}();\nexport { CSMFrustum };","map":null,"metadata":{},"sourceType":"module"}