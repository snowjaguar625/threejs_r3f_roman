{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Administrator\\\\Videos\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from 'three';\nimport potpack from 'potpack';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer) {\n    var _this = this;\n    var res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    _classCallCheck(this, ProgressiveLightMap);\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false; // Create the Progressive LightMap Texture\n\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = function (shader) {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      var bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\\n\\t\\t\\t\\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n\\t\\t\\t}\"; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: _this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      _this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\n\n      _this.uvMat.userData.shader = shader;\n      _this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  _createClass(ProgressiveLightMap, [{\n    key: \"addObjectsToLightMap\",\n    value: function addObjectsToLightMap(objects) {\n      // Prepare list of UV bounding boxes for packing later...\n      this.uv_boxes = [];\n      var padding = 3 / this.res;\n      for (var ob = 0; ob < objects.length; ob++) {\n        var object = objects[ob]; // If this object is a light, simply add it to the internal scene\n\n        if (object.isLight) {\n          this.scene.attach(object);\n          continue;\n        }\n        if (!object.geometry.hasAttribute('uv')) {\n          console.warn('All lightmap objects need UVs!');\n          continue;\n        }\n        if (this.blurringPlane == null) {\n          this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n        } // Apply the lightmap to the object\n\n        object.material.lightMap = this.progressiveLightMap2.texture;\n        object.material.dithering = true;\n        object.castShadow = true;\n        object.receiveShadow = true;\n        object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\n        // TODO: Size these by object surface area\n\n        this.uv_boxes.push({\n          w: 1 + padding * 2,\n          h: 1 + padding * 2,\n          index: ob\n        });\n        this.lightMapContainers.push({\n          basicMat: object.material,\n          object: object\n        });\n        this.compiled = false;\n      } // Pack the objects' lightmap UVs into the same global space\n\n      var dimensions = potpack(this.uv_boxes);\n      this.uv_boxes.forEach(function (box) {\n        var uv2 = objects[box.index].geometry.getAttribute('uv').clone();\n        for (var i = 0; i < uv2.array.length; i += uv2.itemSize) {\n          uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n          uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n        }\n        objects[box.index].geometry.setAttribute('uv2', uv2);\n        objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\n      });\n    }\n    /**\n     * This function renders each mesh one at a time into their respective surface maps\n     * @param {Camera} camera Standard Rendering Camera\n     * @param {number} blendWindow When >1, samples will accumulate over time.\n     * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n     */\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (this.blurringPlane == null) {\n        return;\n      } // Store the original Render Target\n\n      var oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\n\n      this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\n\n      for (var l = 0; l < this.lightMapContainers.length; l++) {\n        this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n        this.scene.attach(this.lightMapContainers[l].object);\n      } // Render once normally to initialize everything\n\n      if (this.firstUpdate) {\n        this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n\n        this.renderer.render(this.scene, camera);\n        this.firstUpdate = false;\n      } // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n      for (var _l = 0; _l < this.lightMapContainers.length; _l++) {\n        this.uvMat.uniforms.averagingWindow = {\n          value: blendWindow\n        };\n        this.lightMapContainers[_l].object.material = this.uvMat;\n        this.lightMapContainers[_l].object.oldFrustumCulled = this.lightMapContainers[_l].object.frustumCulled;\n        this.lightMapContainers[_l].object.frustumCulled = false;\n      } // Ping-pong two surface buffers for reading/writing\n\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n      this.renderer.setRenderTarget(activeMap);\n      this.uvMat.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.blurringPlane.material.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\n\n      for (var _l2 = 0; _l2 < this.lightMapContainers.length; _l2++) {\n        this.lightMapContainers[_l2].object.frustumCulled = this.lightMapContainers[_l2].object.oldFrustumCulled;\n        this.lightMapContainers[_l2].object.material = this.lightMapContainers[_l2].basicMat;\n        this.lightMapContainers[_l2].object.oldScene.attach(this.lightMapContainers[_l2].object);\n      } // Restore the original Render Target\n\n      this.renderer.setRenderTarget(oldTarget);\n    }\n    /** DEBUG\n     * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n     * @param {boolean} visible Whether the debug plane should be visible\n     * @param {Vector3} position Where the debug plane should be drawn\n     */\n  }, {\n    key: \"showDebugLightmap\",\n    value: function showDebugLightmap(visible) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (this.lightMapContainers.length == 0) {\n        if (!this.warned) {\n          console.warn('Call this after adding the objects!');\n          this.warned = true;\n        }\n        return;\n      }\n      if (this.labelMesh == null) {\n        this.labelMaterial = new MeshBasicMaterial({\n          map: this.progressiveLightMap1.texture,\n          side: DoubleSide\n        });\n        this.labelPlane = new PlaneGeometry(100, 100);\n        this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n        this.labelMesh.position.y = 250;\n        this.lightMapContainers[0].object.parent.add(this.labelMesh);\n      }\n      if (position != undefined) {\n        this.labelMesh.position.copy(position);\n      }\n      this.labelMesh.visible = visible;\n    }\n    /**\n     * INTERNAL Creates the Blurring Plane\n     * @param {number} res The square resolution of this object's lightMap.\n     * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n     */\n  }, {\n    key: \"_initializeBlurPlane\",\n    value: function _initializeBlurPlane(res) {\n      var _this2 = this;\n      var lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var blurMaterial = new MeshBasicMaterial();\n      blurMaterial.uniforms = {\n        previousShadowMap: {\n          value: null\n        },\n        pixelOffset: {\n          value: 1.0 / res\n        },\n        polygonOffset: true,\n        polygonOffsetFactor: -1,\n        polygonOffsetUnits: 3.0\n      };\n      blurMaterial.onBeforeCompile = function (shader) {\n        // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n        shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\n        var bodyStart = shader.fragmentShader.indexOf('void main() {');\n        shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\tgl_FragColor.rgb = (\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\n\\t\\t}\"; // Set the LightMap Accumulation Buffer\n\n        shader.uniforms.previousShadowMap = {\n          value: lightMap.texture\n        };\n        shader.uniforms.pixelOffset = {\n          value: 0.5 / res\n        };\n        blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\n\n        blurMaterial.userData.shader = shader;\n        _this2.compiled = true;\n      };\n      this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n      this.blurringPlane.name = 'Blurring Plane';\n      this.blurringPlane.frustumCulled = false;\n      this.blurringPlane.renderOrder = 0;\n      this.blurringPlane.material.depthWrite = false;\n      this.scene.add(this.blurringPlane);\n    }\n  }]);\n  return ProgressiveLightMap;\n}();\nexport { ProgressiveLightMap };","map":null,"metadata":{},"sourceType":"module"}