{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, NumberKeyframeTrack, AnimationClip, BufferAttribute } from 'three';\n\n/**\n * MDD is a special format that stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * number of frames (a single uint32)\n * number of vertices (a single uint32)\n * time values for each frame (sequence of float32)\n * vertex data for each frame (sequence of float32)\n */\nvar MDDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(MDDLoader, _Loader);\n  function MDDLoader(manager) {\n    _classCallCheck(this, MDDLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MDDLoader).call(this, manager));\n  }\n  _createClass(MDDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (data) {\n        onLoad(scope.parse(data));\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var view = new DataView(data);\n      var totalFrames = view.getUint32(0);\n      var totalPoints = view.getUint32(4);\n      var offset = 8; // animation clip\n\n      var times = new Float32Array(totalFrames);\n      var values = new Float32Array(totalFrames * totalFrames).fill(0);\n      for (var i = 0; i < totalFrames; i++) {\n        times[i] = view.getFloat32(offset);\n        offset += 4;\n        values[totalFrames * i + i] = 1;\n      }\n      var track = new NumberKeyframeTrack('.morphTargetInfluences', times, values);\n      var clip = new AnimationClip('default', times[times.length - 1], [track]); // morph targets\n\n      var morphTargets = [];\n      for (var _i = 0; _i < totalFrames; _i++) {\n        var morphTarget = new Float32Array(totalPoints * 3);\n        for (var j = 0; j < totalPoints; j++) {\n          var stride = j * 3;\n          morphTarget[stride + 0] = view.getFloat32(offset);\n          offset += 4; // x\n\n          morphTarget[stride + 1] = view.getFloat32(offset);\n          offset += 4; // y\n\n          morphTarget[stride + 2] = view.getFloat32(offset);\n          offset += 4; // z\n        }\n\n        var attribute = new BufferAttribute(morphTarget, 3);\n        attribute.name = 'morph_' + _i;\n        morphTargets.push(attribute);\n      }\n      return {\n        morphTargets: morphTargets,\n        clip: clip\n      };\n    }\n  }]);\n  return MDDLoader;\n}(Loader);\nexport { MDDLoader };","map":null,"metadata":{},"sourceType":"module"}