{"ast":null,"code":"import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nvar ray = /* @__PURE__ */new Ray();\nvar tmpInverseMatrix = /* @__PURE__ */new Matrix4();\nvar origMeshRaycastFunc = Mesh.prototype.raycast;\nexport function acceleratedRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    var bvh = this.geometry.boundsTree;\n    if (raycaster.firstHitOnly === true) {\n      var hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      var hits = bvh.raycast(ray, this.material);\n      for (var i = 0, l = hits.length; i < l; i++) {\n        var _hit = convertRaycastIntersect(hits[i], this, raycaster);\n        if (_hit) {\n          intersects.push(_hit);\n        }\n      }\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nexport function computeBoundsTree(options) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nexport function disposeBoundsTree() {\n  this.boundsTree = null;\n}","map":null,"metadata":{},"sourceType":"module"}