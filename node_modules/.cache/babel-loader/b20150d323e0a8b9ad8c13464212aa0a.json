{"ast":null,"code":"import { Object3D, Box3, MathUtils, TextureLoader, UVMapping, sRGBEncoding, MeshLambertMaterial } from 'three';\nimport { MD2Loader } from '../loaders/MD2Loader.js';\nimport { MorphBlendMesh } from './MorphBlendMesh.js';\nvar MD2CharacterComplex = function MD2CharacterComplex() {\n  var scope = this;\n  this.scale = 1; // animation parameters\n\n  this.animationFPS = 6;\n  this.transitionFrames = 15; // movement model parameters\n\n  this.maxSpeed = 275;\n  this.maxReverseSpeed = -275;\n  this.frontAcceleration = 600;\n  this.backAcceleration = 600;\n  this.frontDecceleration = 600;\n  this.angularSpeed = 2.5; // rig\n\n  this.root = new Object3D();\n  this.meshBody = null;\n  this.meshWeapon = null;\n  this.controls = null; // skins\n\n  this.skinsBody = [];\n  this.skinsWeapon = [];\n  this.weapons = [];\n  this.currentSkin = undefined; //\n\n  this.onLoadComplete = function () {}; // internals\n\n  this.meshes = [];\n  this.animations = {};\n  this.loadCounter = 0; // internal movement control variables\n\n  this.speed = 0;\n  this.bodyOrientation = 0;\n  this.walkSpeed = this.maxSpeed;\n  this.crouchSpeed = this.maxSpeed * 0.5; // internal animation parameters\n\n  this.activeAnimation = null;\n  this.oldAnimation = null; // API\n\n  this.enableShadows = function (enable) {\n    for (var i = 0; i < this.meshes.length; i++) {\n      this.meshes[i].castShadow = enable;\n      this.meshes[i].receiveShadow = enable;\n    }\n  };\n  this.setVisible = function (enable) {\n    for (var i = 0; i < this.meshes.length; i++) {\n      this.meshes[i].visible = enable;\n      this.meshes[i].visible = enable;\n    }\n  };\n  this.shareParts = function (original) {\n    this.animations = original.animations;\n    this.walkSpeed = original.walkSpeed;\n    this.crouchSpeed = original.crouchSpeed;\n    this.skinsBody = original.skinsBody;\n    this.skinsWeapon = original.skinsWeapon; // BODY\n\n    var mesh = createPart(original.meshBody.geometry, this.skinsBody[0]);\n    mesh.scale.set(this.scale, this.scale, this.scale);\n    this.root.position.y = original.root.position.y;\n    this.root.add(mesh);\n    this.meshBody = mesh;\n    this.meshes.push(mesh); // WEAPONS\n\n    for (var i = 0; i < original.weapons.length; i++) {\n      var meshWeapon = createPart(original.weapons[i].geometry, this.skinsWeapon[i]);\n      meshWeapon.scale.set(this.scale, this.scale, this.scale);\n      meshWeapon.visible = false;\n      meshWeapon.name = original.weapons[i].name;\n      this.root.add(meshWeapon);\n      this.weapons[i] = meshWeapon;\n      this.meshWeapon = meshWeapon;\n      this.meshes.push(meshWeapon);\n    }\n  };\n  this.loadParts = function (config) {\n    this.animations = config.animations;\n    this.walkSpeed = config.walkSpeed;\n    this.crouchSpeed = config.crouchSpeed;\n    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;\n    var weaponsTextures = [];\n    for (var i = 0; i < config.weapons.length; i++) {\n      weaponsTextures[i] = config.weapons[i][1];\n    } // SKINS\n\n    this.skinsBody = loadTextures(config.baseUrl + 'skins/', config.skins);\n    this.skinsWeapon = loadTextures(config.baseUrl + 'skins/', weaponsTextures); // BODY\n\n    var loader = new MD2Loader();\n    loader.load(config.baseUrl + config.body, function (geo) {\n      var boundingBox = new Box3();\n      boundingBox.setFromBufferAttribute(geo.attributes.position);\n      scope.root.position.y = -scope.scale * boundingBox.min.y;\n      var mesh = createPart(geo, scope.skinsBody[0]);\n      mesh.scale.set(scope.scale, scope.scale, scope.scale);\n      scope.root.add(mesh);\n      scope.meshBody = mesh;\n      scope.meshes.push(mesh);\n      checkLoadingComplete();\n    }); // WEAPONS\n\n    var generateCallback = function generateCallback(index, name) {\n      return function (geo) {\n        var mesh = createPart(geo, scope.skinsWeapon[index]);\n        mesh.scale.set(scope.scale, scope.scale, scope.scale);\n        mesh.visible = false;\n        mesh.name = name;\n        scope.root.add(mesh);\n        scope.weapons[index] = mesh;\n        scope.meshWeapon = mesh;\n        scope.meshes.push(mesh);\n        checkLoadingComplete();\n      };\n    };\n    for (var _i = 0; _i < config.weapons.length; _i++) {\n      loader.load(config.baseUrl + config.weapons[_i][0], generateCallback(_i, config.weapons[_i][0]));\n    }\n  };\n  this.setPlaybackRate = function (rate) {\n    if (this.meshBody) this.meshBody.duration = this.meshBody.baseDuration / rate;\n    if (this.meshWeapon) this.meshWeapon.duration = this.meshWeapon.baseDuration / rate;\n  };\n  this.setWireframe = function (wireframeEnabled) {\n    if (wireframeEnabled) {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe;\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe;\n    } else {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture;\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture;\n    }\n  };\n  this.setSkin = function (index) {\n    if (this.meshBody && this.meshBody.material.wireframe === false) {\n      this.meshBody.material.map = this.skinsBody[index];\n      this.currentSkin = index;\n    }\n  };\n  this.setWeapon = function (index) {\n    for (var i = 0; i < this.weapons.length; i++) {\n      this.weapons[i].visible = false;\n    }\n    var activeWeapon = this.weapons[index];\n    if (activeWeapon) {\n      activeWeapon.visible = true;\n      this.meshWeapon = activeWeapon;\n      if (this.activeAnimation) {\n        activeWeapon.playAnimation(this.activeAnimation);\n        this.meshWeapon.setAnimationTime(this.activeAnimation, this.meshBody.getAnimationTime(this.activeAnimation));\n      }\n    }\n  };\n  this.setAnimation = function (animationName) {\n    if (animationName === this.activeAnimation || !animationName) return;\n    if (this.meshBody) {\n      this.meshBody.setAnimationWeight(animationName, 0);\n      this.meshBody.playAnimation(animationName);\n      this.oldAnimation = this.activeAnimation;\n      this.activeAnimation = animationName;\n      this.blendCounter = this.transitionFrames;\n    }\n    if (this.meshWeapon) {\n      this.meshWeapon.setAnimationWeight(animationName, 0);\n      this.meshWeapon.playAnimation(animationName);\n    }\n  };\n  this.update = function (delta) {\n    if (this.controls) this.updateMovementModel(delta);\n    if (this.animations) {\n      this.updateBehaviors();\n      this.updateAnimations(delta);\n    }\n  };\n  this.updateAnimations = function (delta) {\n    var mix = 1;\n    if (this.blendCounter > 0) {\n      mix = (this.transitionFrames - this.blendCounter) / this.transitionFrames;\n      this.blendCounter -= 1;\n    }\n    if (this.meshBody) {\n      this.meshBody.update(delta);\n      this.meshBody.setAnimationWeight(this.activeAnimation, mix);\n      this.meshBody.setAnimationWeight(this.oldAnimation, 1 - mix);\n    }\n    if (this.meshWeapon) {\n      this.meshWeapon.update(delta);\n      this.meshWeapon.setAnimationWeight(this.activeAnimation, mix);\n      this.meshWeapon.setAnimationWeight(this.oldAnimation, 1 - mix);\n    }\n  };\n  this.updateBehaviors = function () {\n    var controls = this.controls;\n    var animations = this.animations;\n    var moveAnimation, idleAnimation; // crouch vs stand\n\n    if (controls.crouch) {\n      moveAnimation = animations['crouchMove'];\n      idleAnimation = animations['crouchIdle'];\n    } else {\n      moveAnimation = animations['move'];\n      idleAnimation = animations['idle'];\n    } // actions\n\n    if (controls.jump) {\n      moveAnimation = animations['jump'];\n      idleAnimation = animations['jump'];\n    }\n    if (controls.attack) {\n      if (controls.crouch) {\n        moveAnimation = animations['crouchAttack'];\n        idleAnimation = animations['crouchAttack'];\n      } else {\n        moveAnimation = animations['attack'];\n        idleAnimation = animations['attack'];\n      }\n    } // set animations\n\n    if (controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight) {\n      if (this.activeAnimation !== moveAnimation) {\n        this.setAnimation(moveAnimation);\n      }\n    }\n    if (Math.abs(this.speed) < 0.2 * this.maxSpeed && !(controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward)) {\n      if (this.activeAnimation !== idleAnimation) {\n        this.setAnimation(idleAnimation);\n      }\n    } // set animation direction\n\n    if (controls.moveForward) {\n      if (this.meshBody) {\n        this.meshBody.setAnimationDirectionForward(this.activeAnimation);\n        this.meshBody.setAnimationDirectionForward(this.oldAnimation);\n      }\n      if (this.meshWeapon) {\n        this.meshWeapon.setAnimationDirectionForward(this.activeAnimation);\n        this.meshWeapon.setAnimationDirectionForward(this.oldAnimation);\n      }\n    }\n    if (controls.moveBackward) {\n      if (this.meshBody) {\n        this.meshBody.setAnimationDirectionBackward(this.activeAnimation);\n        this.meshBody.setAnimationDirectionBackward(this.oldAnimation);\n      }\n      if (this.meshWeapon) {\n        this.meshWeapon.setAnimationDirectionBackward(this.activeAnimation);\n        this.meshWeapon.setAnimationDirectionBackward(this.oldAnimation);\n      }\n    }\n  };\n  this.updateMovementModel = function (delta) {\n    var controls = this.controls; // speed based on controls\n\n    if (controls.crouch) this.maxSpeed = this.crouchSpeed;else this.maxSpeed = this.walkSpeed;\n    this.maxReverseSpeed = -this.maxSpeed;\n    if (controls.moveForward) {\n      this.speed = MathUtils.clamp(this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);\n    }\n    if (controls.moveBackward) {\n      this.speed = MathUtils.clamp(this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed);\n    } // orientation based on controls\n    // (don't just stand while turning)\n\n    var dir = 1;\n    if (controls.moveLeft) {\n      this.bodyOrientation += delta * this.angularSpeed;\n      this.speed = MathUtils.clamp(this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);\n    }\n    if (controls.moveRight) {\n      this.bodyOrientation -= delta * this.angularSpeed;\n      this.speed = MathUtils.clamp(this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);\n    } // speed decay\n\n    if (!(controls.moveForward || controls.moveBackward)) {\n      if (this.speed > 0) {\n        var k = exponentialEaseOut(this.speed / this.maxSpeed);\n        this.speed = MathUtils.clamp(this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed);\n      } else {\n        var k = exponentialEaseOut(this.speed / this.maxReverseSpeed);\n        this.speed = MathUtils.clamp(this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0);\n      }\n    } // displacement\n\n    var forwardDelta = this.speed * delta;\n    this.root.position.x += Math.sin(this.bodyOrientation) * forwardDelta;\n    this.root.position.z += Math.cos(this.bodyOrientation) * forwardDelta; // steering\n\n    this.root.rotation.y = this.bodyOrientation;\n  }; // internal helpers\n\n  function loadTextures(baseUrl, textureUrls) {\n    var textureLoader = new TextureLoader();\n    var textures = [];\n    for (var i = 0; i < textureUrls.length; i++) {\n      textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete);\n      textures[i].mapping = UVMapping;\n      textures[i].name = textureUrls[i];\n      textures[i].encoding = sRGBEncoding;\n    }\n    return textures;\n  }\n  function createPart(geometry, skinMap) {\n    var materialWireframe = new MeshLambertMaterial({\n      color: 0xffaa00,\n      wireframe: true,\n      morphTargets: true,\n      morphNormals: true\n    });\n    var materialTexture = new MeshLambertMaterial({\n      color: 0xffffff,\n      wireframe: false,\n      map: skinMap,\n      morphTargets: true,\n      morphNormals: true\n    }); //\n\n    var mesh = new MorphBlendMesh(geometry, materialTexture);\n    mesh.rotation.y = -Math.PI / 2; //\n\n    mesh.materialTexture = materialTexture;\n    mesh.materialWireframe = materialWireframe; //\n\n    mesh.autoCreateAnimations(scope.animationFPS);\n    return mesh;\n  }\n  function checkLoadingComplete() {\n    scope.loadCounter -= 1;\n    if (scope.loadCounter === 0) scope.onLoadComplete();\n  }\n  function exponentialEaseOut(k) {\n    return k === 1 ? 1 : -Math.pow(2, -10 * k) + 1;\n  }\n};\nexport { MD2CharacterComplex };","map":null,"metadata":{},"sourceType":"module"}