{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\nvar EXRLoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(EXRLoader, _DataTextureLoader);\n  function EXRLoader(manager) {\n    var _this;\n    _classCallCheck(this, EXRLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EXRLoader).call(this, manager));\n    _this.type = HalfFloatType;\n    return _this;\n  }\n  _createClass(EXRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var USHORT_RANGE = 1 << 16;\n      var BITMAP_SIZE = USHORT_RANGE >> 3;\n      var HUF_ENCBITS = 16; // literal (value) bit length\n\n      var HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n      var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n      var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n      var HUF_DECMASK = HUF_DECSIZE - 1;\n      var NBITS = 16;\n      var A_OFFSET = 1 << NBITS - 1;\n      var MOD_MASK = (1 << NBITS) - 1;\n      var SHORT_ZEROCODE_RUN = 59;\n      var LONG_ZEROCODE_RUN = 63;\n      var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n      var ULONG_SIZE = 8;\n      var FLOAT32_SIZE = 4;\n      var INT32_SIZE = 4;\n      var INT16_SIZE = 2;\n      var INT8_SIZE = 1;\n      var STATIC_HUFFMAN = 0;\n      var DEFLATE = 1;\n      var UNKNOWN = 0;\n      var LOSSY_DCT = 1;\n      var RLE = 2;\n      var logBase = Math.pow(2.7182818, 2.2);\n      function reverseLutFromBitmap(bitmap, lut) {\n        var k = 0;\n        for (var i = 0; i < USHORT_RANGE; ++i) {\n          if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n            lut[k++] = i;\n          }\n        }\n        var n = k - 1;\n        while (k < USHORT_RANGE) {\n          lut[k++] = 0;\n        }\n        return n;\n      }\n      function hufClearDecTable(hdec) {\n        for (var i = 0; i < HUF_DECSIZE; i++) {\n          hdec[i] = {};\n          hdec[i].len = 0;\n          hdec[i].lit = 0;\n          hdec[i].p = null;\n        }\n      }\n      var getBitsReturn = {\n        l: 0,\n        c: 0,\n        lc: 0\n      };\n      function getBits(nBits, c, lc, uInt8Array, inOffset) {\n        while (lc < nBits) {\n          c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n          lc += 8;\n        }\n        lc -= nBits;\n        getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n        getBitsReturn.c = c;\n        getBitsReturn.lc = lc;\n      }\n      var hufTableBuffer = new Array(59);\n      function hufCanonicalCodeTable(hcode) {\n        for (var i = 0; i <= 58; ++i) {\n          hufTableBuffer[i] = 0;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          hufTableBuffer[hcode[i]] += 1;\n        }\n        var c = 0;\n        for (var i = 58; i > 0; --i) {\n          var nc = c + hufTableBuffer[i] >> 1;\n          hufTableBuffer[i] = c;\n          c = nc;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          var l = hcode[i];\n          if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n        }\n      }\n      function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n        var p = inOffset;\n        var c = 0;\n        var lc = 0;\n        for (; im <= iM; im++) {\n          if (p.value - inOffset.value > ni) return false;\n          getBits(6, c, lc, uInt8Array, p);\n          var l = getBitsReturn.l;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          hcode[im] = l;\n          if (l == LONG_ZEROCODE_RUN) {\n            if (p.value - inOffset.value > ni) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            getBits(8, c, lc, uInt8Array, p);\n            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n            c = getBitsReturn.c;\n            lc = getBitsReturn.lc;\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            while (zerun--) {\n              hcode[im++] = 0;\n            }\n            im--;\n          } else if (l >= SHORT_ZEROCODE_RUN) {\n            var zerun = l - SHORT_ZEROCODE_RUN + 2;\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            while (zerun--) {\n              hcode[im++] = 0;\n            }\n            im--;\n          }\n        }\n        hufCanonicalCodeTable(hcode);\n      }\n      function hufLength(code) {\n        return code & 63;\n      }\n      function hufCode(code) {\n        return code >> 6;\n      }\n      function hufBuildDecTable(hcode, im, iM, hdecod) {\n        for (; im <= iM; im++) {\n          var c = hufCode(hcode[im]);\n          var l = hufLength(hcode[im]);\n          if (c >> l) {\n            throw 'Invalid table entry';\n          }\n          if (l > HUF_DECBITS) {\n            var pl = hdecod[c >> l - HUF_DECBITS];\n            if (pl.len) {\n              throw 'Invalid table entry';\n            }\n            pl.lit++;\n            if (pl.p) {\n              var p = pl.p;\n              pl.p = new Array(pl.lit);\n              for (var i = 0; i < pl.lit - 1; ++i) {\n                pl.p[i] = p[i];\n              }\n            } else {\n              pl.p = new Array(1);\n            }\n            pl.p[pl.lit - 1] = im;\n          } else if (l) {\n            var plOffset = 0;\n            for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n              var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n              if (pl.len || pl.p) {\n                throw 'Invalid table entry';\n              }\n              pl.len = l;\n              pl.lit = im;\n              plOffset++;\n            }\n          }\n        }\n        return true;\n      }\n      var getCharReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getChar(c, lc, uInt8Array, inOffset) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n        getCharReturn.c = c;\n        getCharReturn.lc = lc;\n      }\n      var getCodeReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n        if (po == rlc) {\n          if (lc < 8) {\n            getChar(c, lc, uInt8Array, inOffset);\n            c = getCharReturn.c;\n            lc = getCharReturn.lc;\n          }\n          lc -= 8;\n          var cs = c >> lc;\n          var cs = new Uint8Array([cs])[0];\n          if (outBufferOffset.value + cs > outBufferEndOffset) {\n            return false;\n          }\n          var s = outBuffer[outBufferOffset.value - 1];\n          while (cs-- > 0) {\n            outBuffer[outBufferOffset.value++] = s;\n          }\n        } else if (outBufferOffset.value < outBufferEndOffset) {\n          outBuffer[outBufferOffset.value++] = po;\n        } else {\n          return false;\n        }\n        getCodeReturn.c = c;\n        getCodeReturn.lc = lc;\n      }\n      function UInt16(value) {\n        return value & 0xffff;\n      }\n      function Int16(value) {\n        var ref = UInt16(value);\n        return ref > 0x7fff ? ref - 0x10000 : ref;\n      }\n      var wdec14Return = {\n        a: 0,\n        b: 0\n      };\n      function wdec14(l, h) {\n        var ls = Int16(l);\n        var hs = Int16(h);\n        var hi = hs;\n        var ai = ls + (hi & 1) + (hi >> 1);\n        var as = ai;\n        var bs = ai - hi;\n        wdec14Return.a = as;\n        wdec14Return.b = bs;\n      }\n      function wdec16(l, h) {\n        var m = UInt16(l);\n        var d = UInt16(h);\n        var bb = m - (d >> 1) & MOD_MASK;\n        var aa = d + bb - A_OFFSET & MOD_MASK;\n        wdec14Return.a = aa;\n        wdec14Return.b = bb;\n      }\n      function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n        var w14 = mx < 1 << 14;\n        var n = nx > ny ? ny : nx;\n        var p = 1;\n        var p2;\n        while (p <= n) {\n          p <<= 1;\n        }\n        p >>= 1;\n        p2 = p;\n        p >>= 1;\n        while (p >= 1) {\n          var py = 0;\n          var ey = py + oy * (ny - p2);\n          var oy1 = oy * p;\n          var oy2 = oy * p2;\n          var ox1 = ox * p;\n          var ox2 = ox * p2;\n          var i00, i01, i10, i11;\n          for (; py <= ey; py += oy2) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              var p10 = px + oy1;\n              var p11 = p10 + ox1;\n              if (w14) {\n                wdec14(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec14(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec14(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec14(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              } else {\n                wdec16(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec16(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec16(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec16(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              }\n            }\n            if (nx & p) {\n              var p10 = px + oy1;\n              if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              buffer[p10 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n          if (ny & p) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n              i00 = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n          p2 = p;\n          p >>= 1;\n        }\n        return py;\n      }\n      function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n        var c = 0;\n        var lc = 0;\n        var outBufferEndOffset = no;\n        var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n        while (inOffset.value < inOffsetEnd) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n          while (lc >= HUF_DECBITS) {\n            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n            var pl = decodingTable[index];\n            if (pl.len) {\n              lc -= pl.len;\n              getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n              c = getCodeReturn.c;\n              lc = getCodeReturn.lc;\n            } else {\n              if (!pl.p) {\n                throw 'hufDecode issues';\n              }\n              var j;\n              for (j = 0; j < pl.lit; j++) {\n                var l = hufLength(encodingTable[pl.p[j]]);\n                while (lc < l && inOffset.value < inOffsetEnd) {\n                  getChar(c, lc, uInt8Array, inOffset);\n                  c = getCharReturn.c;\n                  lc = getCharReturn.lc;\n                }\n                if (lc >= l) {\n                  if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                    lc -= l;\n                    getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                    break;\n                  }\n                }\n              }\n              if (j == pl.lit) {\n                throw 'hufDecode issues';\n              }\n            }\n          }\n        }\n        var i = 8 - ni & 7;\n        c >>= i;\n        lc -= i;\n        while (lc > 0) {\n          var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            throw 'hufDecode issues';\n          }\n        }\n        return true;\n      }\n      function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n        var outOffset = {\n          value: 0\n        };\n        var initialInOffset = inOffset.value;\n        var im = parseUint32(inDataView, inOffset);\n        var iM = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        var nBits = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n          throw 'Something wrong with HUF_ENCSIZE';\n        }\n        var freq = new Array(HUF_ENCSIZE);\n        var hdec = new Array(HUF_DECSIZE);\n        hufClearDecTable(hdec);\n        var ni = nCompressed - (inOffset.value - initialInOffset);\n        hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n        if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n          throw 'Something wrong with hufUncompress';\n        }\n        hufBuildDecTable(freq, im, iM, hdec);\n        hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n      }\n      function applyLut(lut, data, nData) {\n        for (var i = 0; i < nData; ++i) {\n          data[i] = lut[data[i]];\n        }\n      }\n      function predictor(source) {\n        for (var t = 1; t < source.length; t++) {\n          var d = source[t - 1] + source[t] - 128;\n          source[t] = d;\n        }\n      }\n      function interleaveScalar(source, out) {\n        var t1 = 0;\n        var t2 = Math.floor((source.length + 1) / 2);\n        var s = 0;\n        var stop = source.length - 1;\n        while (true) {\n          if (s > stop) break;\n          out[s++] = source[t1++];\n          if (s > stop) break;\n          out[s++] = source[t2++];\n        }\n      }\n      function decodeRunLength(source) {\n        var size = source.byteLength;\n        var out = new Array();\n        var p = 0;\n        var reader = new DataView(source);\n        while (size > 0) {\n          var l = reader.getInt8(p++);\n          if (l < 0) {\n            var count = -l;\n            size -= count + 1;\n            for (var i = 0; i < count; i++) {\n              out.push(reader.getUint8(p++));\n            }\n          } else {\n            var count = l;\n            size -= 2;\n            var value = reader.getUint8(p++);\n            for (var i = 0; i < count + 1; i++) {\n              out.push(value);\n            }\n          }\n        }\n        return out;\n      }\n      function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n        var dataView = new DataView(outBuffer.buffer);\n        var width = channelData[cscSet.idx[0]].width;\n        var height = channelData[cscSet.idx[0]].height;\n        var numComp = 3;\n        var numFullBlocksX = Math.floor(width / 8.0);\n        var numBlocksX = Math.ceil(width / 8.0);\n        var numBlocksY = Math.ceil(height / 8.0);\n        var leftoverX = width - (numBlocksX - 1) * 8;\n        var leftoverY = height - (numBlocksY - 1) * 8;\n        var currAcComp = {\n          value: 0\n        };\n        var currDcComp = new Array(numComp);\n        var dctData = new Array(numComp);\n        var halfZigBlock = new Array(numComp);\n        var rowBlock = new Array(numComp);\n        var rowOffsets = new Array(numComp);\n        for (var _comp = 0; _comp < numComp; ++_comp) {\n          rowOffsets[_comp] = rowPtrs[cscSet.idx[_comp]];\n          currDcComp[_comp] = _comp < 1 ? 0 : currDcComp[_comp - 1] + numBlocksX * numBlocksY;\n          dctData[_comp] = new Float32Array(64);\n          halfZigBlock[_comp] = new Uint16Array(64);\n          rowBlock[_comp] = new Uint16Array(numBlocksX * 64);\n        }\n        for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n          var maxY = 8;\n          if (blocky == numBlocksY - 1) maxY = leftoverY;\n          var maxX = 8;\n          for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n            if (blockx == numBlocksX - 1) maxX = leftoverX;\n            for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n              halfZigBlock[_comp2].fill(0); // set block DC component\n\n              halfZigBlock[_comp2][0] = dcBuffer[currDcComp[_comp2]++]; // set block AC components\n\n              unRleAC(currAcComp, acBuffer, halfZigBlock[_comp2]); // UnZigZag block to float\n\n              unZigZag(halfZigBlock[_comp2], dctData[_comp2]); // decode float dct\n\n              dctInverse(dctData[_comp2]);\n            }\n            {\n              csc709Inverse(dctData);\n            }\n            for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n              convertToHalf(dctData[_comp3], rowBlock[_comp3], blockx * 64);\n            }\n          } // blockx\n\n          var _offset = 0;\n          for (var _comp4 = 0; _comp4 < numComp; ++_comp4) {\n            var _type = channelData[cscSet.idx[_comp4]].type;\n            for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n              _offset = rowOffsets[_comp4][_y];\n              for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n                var src = _blockx * 64 + (_y & 0x7) * 8;\n                dataView.setUint16(_offset + 0 * INT16_SIZE * _type, rowBlock[_comp4][src + 0], true);\n                dataView.setUint16(_offset + 1 * INT16_SIZE * _type, rowBlock[_comp4][src + 1], true);\n                dataView.setUint16(_offset + 2 * INT16_SIZE * _type, rowBlock[_comp4][src + 2], true);\n                dataView.setUint16(_offset + 3 * INT16_SIZE * _type, rowBlock[_comp4][src + 3], true);\n                dataView.setUint16(_offset + 4 * INT16_SIZE * _type, rowBlock[_comp4][src + 4], true);\n                dataView.setUint16(_offset + 5 * INT16_SIZE * _type, rowBlock[_comp4][src + 5], true);\n                dataView.setUint16(_offset + 6 * INT16_SIZE * _type, rowBlock[_comp4][src + 6], true);\n                dataView.setUint16(_offset + 7 * INT16_SIZE * _type, rowBlock[_comp4][src + 7], true);\n                _offset += 8 * INT16_SIZE * _type;\n              }\n            } // handle partial X blocks\n\n            if (numFullBlocksX != numBlocksX) {\n              for (var _y2 = 8 * blocky; _y2 < 8 * blocky + maxY; ++_y2) {\n                var _offset2 = rowOffsets[_comp4][_y2] + 8 * numFullBlocksX * INT16_SIZE * _type;\n                var _src = numFullBlocksX * 64 + (_y2 & 0x7) * 8;\n                for (var _x = 0; _x < maxX; ++_x) {\n                  dataView.setUint16(_offset2 + _x * INT16_SIZE * _type, rowBlock[_comp4][_src + _x], true);\n                }\n              }\n            }\n          } // comp\n        } // blocky\n\n        var halfRow = new Uint16Array(width);\n        var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n        for (var comp = 0; comp < numComp; ++comp) {\n          channelData[cscSet.idx[comp]].decoded = true;\n          var type = channelData[cscSet.idx[comp]].type;\n          if (channelData[comp].type != 2) continue;\n          for (var y = 0; y < height; ++y) {\n            var _offset3 = rowOffsets[comp][y];\n            for (var x = 0; x < width; ++x) {\n              halfRow[x] = dataView.getUint16(_offset3 + x * INT16_SIZE * type, true);\n            }\n            for (var x = 0; x < width; ++x) {\n              dataView.setFloat32(_offset3 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n            }\n          }\n        }\n      }\n      function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n        var acValue;\n        var dctComp = 1;\n        while (dctComp < 64) {\n          acValue = acBuffer[currAcComp.value];\n          if (acValue == 0xff00) {\n            dctComp = 64;\n          } else if (acValue >> 8 == 0xff) {\n            dctComp += acValue & 0xff;\n          } else {\n            halfZigBlock[dctComp] = acValue;\n            dctComp++;\n          }\n          currAcComp.value++;\n        }\n      }\n      function unZigZag(src, dst) {\n        dst[0] = decodeFloat16(src[0]);\n        dst[1] = decodeFloat16(src[1]);\n        dst[2] = decodeFloat16(src[5]);\n        dst[3] = decodeFloat16(src[6]);\n        dst[4] = decodeFloat16(src[14]);\n        dst[5] = decodeFloat16(src[15]);\n        dst[6] = decodeFloat16(src[27]);\n        dst[7] = decodeFloat16(src[28]);\n        dst[8] = decodeFloat16(src[2]);\n        dst[9] = decodeFloat16(src[4]);\n        dst[10] = decodeFloat16(src[7]);\n        dst[11] = decodeFloat16(src[13]);\n        dst[12] = decodeFloat16(src[16]);\n        dst[13] = decodeFloat16(src[26]);\n        dst[14] = decodeFloat16(src[29]);\n        dst[15] = decodeFloat16(src[42]);\n        dst[16] = decodeFloat16(src[3]);\n        dst[17] = decodeFloat16(src[8]);\n        dst[18] = decodeFloat16(src[12]);\n        dst[19] = decodeFloat16(src[17]);\n        dst[20] = decodeFloat16(src[25]);\n        dst[21] = decodeFloat16(src[30]);\n        dst[22] = decodeFloat16(src[41]);\n        dst[23] = decodeFloat16(src[43]);\n        dst[24] = decodeFloat16(src[9]);\n        dst[25] = decodeFloat16(src[11]);\n        dst[26] = decodeFloat16(src[18]);\n        dst[27] = decodeFloat16(src[24]);\n        dst[28] = decodeFloat16(src[31]);\n        dst[29] = decodeFloat16(src[40]);\n        dst[30] = decodeFloat16(src[44]);\n        dst[31] = decodeFloat16(src[53]);\n        dst[32] = decodeFloat16(src[10]);\n        dst[33] = decodeFloat16(src[19]);\n        dst[34] = decodeFloat16(src[23]);\n        dst[35] = decodeFloat16(src[32]);\n        dst[36] = decodeFloat16(src[39]);\n        dst[37] = decodeFloat16(src[45]);\n        dst[38] = decodeFloat16(src[52]);\n        dst[39] = decodeFloat16(src[54]);\n        dst[40] = decodeFloat16(src[20]);\n        dst[41] = decodeFloat16(src[22]);\n        dst[42] = decodeFloat16(src[33]);\n        dst[43] = decodeFloat16(src[38]);\n        dst[44] = decodeFloat16(src[46]);\n        dst[45] = decodeFloat16(src[51]);\n        dst[46] = decodeFloat16(src[55]);\n        dst[47] = decodeFloat16(src[60]);\n        dst[48] = decodeFloat16(src[21]);\n        dst[49] = decodeFloat16(src[34]);\n        dst[50] = decodeFloat16(src[37]);\n        dst[51] = decodeFloat16(src[47]);\n        dst[52] = decodeFloat16(src[50]);\n        dst[53] = decodeFloat16(src[56]);\n        dst[54] = decodeFloat16(src[59]);\n        dst[55] = decodeFloat16(src[61]);\n        dst[56] = decodeFloat16(src[35]);\n        dst[57] = decodeFloat16(src[36]);\n        dst[58] = decodeFloat16(src[48]);\n        dst[59] = decodeFloat16(src[49]);\n        dst[60] = decodeFloat16(src[57]);\n        dst[61] = decodeFloat16(src[58]);\n        dst[62] = decodeFloat16(src[62]);\n        dst[63] = decodeFloat16(src[63]);\n      }\n      function dctInverse(data) {\n        var a = 0.5 * Math.cos(3.14159 / 4.0);\n        var b = 0.5 * Math.cos(3.14159 / 16.0);\n        var c = 0.5 * Math.cos(3.14159 / 8.0);\n        var d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n        var e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n        var f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n        var g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n        var alpha = new Array(4);\n        var beta = new Array(4);\n        var theta = new Array(4);\n        var gamma = new Array(4);\n        for (var row = 0; row < 8; ++row) {\n          var rowPtr = row * 8;\n          alpha[0] = c * data[rowPtr + 2];\n          alpha[1] = f * data[rowPtr + 2];\n          alpha[2] = c * data[rowPtr + 6];\n          alpha[3] = f * data[rowPtr + 6];\n          beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n          beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n          beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n          beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n          theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n          theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[rowPtr + 0] = gamma[0] + beta[0];\n          data[rowPtr + 1] = gamma[1] + beta[1];\n          data[rowPtr + 2] = gamma[2] + beta[2];\n          data[rowPtr + 3] = gamma[3] + beta[3];\n          data[rowPtr + 4] = gamma[3] - beta[3];\n          data[rowPtr + 5] = gamma[2] - beta[2];\n          data[rowPtr + 6] = gamma[1] - beta[1];\n          data[rowPtr + 7] = gamma[0] - beta[0];\n        }\n        for (var column = 0; column < 8; ++column) {\n          alpha[0] = c * data[16 + column];\n          alpha[1] = f * data[16 + column];\n          alpha[2] = c * data[48 + column];\n          alpha[3] = f * data[48 + column];\n          beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n          beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n          beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n          beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n          theta[0] = a * (data[column] + data[32 + column]);\n          theta[3] = a * (data[column] - data[32 + column]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[0 + column] = gamma[0] + beta[0];\n          data[8 + column] = gamma[1] + beta[1];\n          data[16 + column] = gamma[2] + beta[2];\n          data[24 + column] = gamma[3] + beta[3];\n          data[32 + column] = gamma[3] - beta[3];\n          data[40 + column] = gamma[2] - beta[2];\n          data[48 + column] = gamma[1] - beta[1];\n          data[56 + column] = gamma[0] - beta[0];\n        }\n      }\n      function csc709Inverse(data) {\n        for (var i = 0; i < 64; ++i) {\n          var y = data[0][i];\n          var cb = data[1][i];\n          var cr = data[2][i];\n          data[0][i] = y + 1.5747 * cr;\n          data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n          data[2][i] = y + 1.8556 * cb;\n        }\n      }\n      function convertToHalf(src, dst, idx) {\n        for (var i = 0; i < 64; ++i) {\n          dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n        }\n      }\n      function toLinear(float) {\n        if (float <= 1) {\n          return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n        } else {\n          return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n        }\n      }\n      function uncompressRAW(info) {\n        return new DataView(info.array.buffer, info.offset.value, info.size);\n      }\n      function uncompressRLE(info) {\n        var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressZIP(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPIZ(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n        var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n        var outBufferEnd = 0;\n        var pizChannelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; i++) {\n          pizChannelData[i] = {};\n          pizChannelData[i]['start'] = outBufferEnd;\n          pizChannelData[i]['end'] = pizChannelData[i]['start'];\n          pizChannelData[i]['nx'] = info.width;\n          pizChannelData[i]['ny'] = info.lines;\n          pizChannelData[i]['size'] = info.type;\n          outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n        } // Read range compression data\n\n        var minNonZero = parseUint16(inDataView, inOffset);\n        var maxNonZero = parseUint16(inDataView, inOffset);\n        if (maxNonZero >= BITMAP_SIZE) {\n          throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n        }\n        if (minNonZero <= maxNonZero) {\n          for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n          }\n        } // Reverse LUT\n\n        var lut = new Uint16Array(USHORT_RANGE);\n        var maxValue = reverseLutFromBitmap(bitmap, lut);\n        var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n        hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = pizChannelData[i];\n          for (var j = 0; j < pizChannelData[i].size; ++j) {\n            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n          }\n        } // Expand the pixel data to their original range\n\n        applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n        var tmpOffset = 0;\n        var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var cd = pizChannelData[c];\n            var n = cd.nx * cd.size;\n            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset);\n            tmpOffset += n * INT16_SIZE;\n            cd.end += n;\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPXR(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var sz = info.lines * info.channels * info.width;\n        var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n        var tmpBufferEnd = 0;\n        var writePtr = 0;\n        var ptr = new Array(4);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var pixel = 0;\n            switch (info.type) {\n              case 1:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                tmpBufferEnd = ptr[1] + info.width;\n                for (var j = 0; j < info.width; ++j) {\n                  var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                  pixel += diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n              case 2:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                ptr[2] = ptr[1] + info.width;\n                tmpBufferEnd = ptr[2] + info.width;\n                for (var _j = 0; _j < info.width; ++_j) {\n                  var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                  pixel += _diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n            }\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressDWA(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n        var dwaHeader = {\n          version: parseInt64(inDataView, inOffset),\n          unknownUncompressedSize: parseInt64(inDataView, inOffset),\n          unknownCompressedSize: parseInt64(inDataView, inOffset),\n          acCompressedSize: parseInt64(inDataView, inOffset),\n          dcCompressedSize: parseInt64(inDataView, inOffset),\n          rleCompressedSize: parseInt64(inDataView, inOffset),\n          rleUncompressedSize: parseInt64(inDataView, inOffset),\n          rleRawSize: parseInt64(inDataView, inOffset),\n          totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n          totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n          acCompression: parseInt64(inDataView, inOffset)\n        };\n        if (dwaHeader.version < 2) {\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n        } // Read channel ruleset information\n\n        var channelRules = new Array();\n        var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n        while (ruleSize > 0) {\n          var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n          var value = parseUint8(inDataView, inOffset);\n          var compression = value >> 2 & 3;\n          var csc = (value >> 4) - 1;\n          var index = new Int8Array([csc])[0];\n          var type = parseUint8(inDataView, inOffset);\n          channelRules.push({\n            name: name,\n            index: index,\n            type: type,\n            compression: compression\n          });\n          ruleSize -= name.length + 3;\n        } // Classify channels\n\n        var channels = EXRHeader.channels;\n        var channelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = channelData[i] = {};\n          var channel = channels[i];\n          cd.name = channel.name;\n          cd.compression = UNKNOWN;\n          cd.decoded = false;\n          cd.type = channel.pixelType;\n          cd.pLinear = channel.pLinear;\n          cd.width = info.width;\n          cd.height = info.lines;\n        }\n        var cscSet = {\n          idx: new Array(3)\n        };\n        for (var offset = 0; offset < info.channels; ++offset) {\n          var cd = channelData[offset];\n          for (var i = 0; i < channelRules.length; ++i) {\n            var rule = channelRules[i];\n            if (cd.name == rule.name) {\n              cd.compression = rule.compression;\n              if (rule.index >= 0) {\n                cscSet.idx[rule.index] = offset;\n              }\n              cd.offset = offset;\n            }\n          }\n        } // Read DCT - AC component data\n\n        if (dwaHeader.acCompressedSize > 0) {\n          switch (dwaHeader.acCompression) {\n            case STATIC_HUFFMAN:\n              var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n              hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n              break;\n            case DEFLATE:\n              var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n              var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n              var acBuffer = new Uint16Array(data.buffer);\n              inOffset.value += dwaHeader.totalAcUncompressedCount;\n              break;\n          }\n        } // Read DCT - DC component data\n\n        if (dwaHeader.dcCompressedSize > 0) {\n          var zlibInfo = {\n            array: info.array,\n            offset: inOffset,\n            size: dwaHeader.dcCompressedSize\n          };\n          var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n          inOffset.value += dwaHeader.dcCompressedSize;\n        } // Read RLE compressed data\n\n        if (dwaHeader.rleRawSize > 0) {\n          var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n          var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n          var rleBuffer = decodeRunLength(data.buffer);\n          inOffset.value += dwaHeader.rleCompressedSize;\n        } // Prepare outbuffer data offset\n\n        var outBufferEnd = 0;\n        var rowOffsets = new Array(channelData.length);\n        for (var i = 0; i < rowOffsets.length; ++i) {\n          rowOffsets[i] = new Array();\n        }\n        for (var y = 0; y < info.lines; ++y) {\n          for (var chan = 0; chan < channelData.length; ++chan) {\n            rowOffsets[chan].push(outBufferEnd);\n            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n          }\n        } // Lossy DCT decode RGB channels\n\n        lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n        for (var i = 0; i < channelData.length; ++i) {\n          var cd = channelData[i];\n          if (cd.decoded) continue;\n          switch (cd.compression) {\n            case RLE:\n              var row = 0;\n              var rleOffset = 0;\n              for (var y = 0; y < info.lines; ++y) {\n                var rowOffsetBytes = rowOffsets[i][row];\n                for (var x = 0; x < cd.width; ++x) {\n                  for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                  }\n                  rleOffset++;\n                }\n                row++;\n              }\n              break;\n            case LOSSY_DCT: // skip\n\n            default:\n              throw 'EXRLoader.parse: unsupported channel compression';\n          }\n        }\n        return new DataView(outBuffer.buffer);\n      }\n      function parseNullTerminatedString(buffer, offset) {\n        var uintBuffer = new Uint8Array(buffer);\n        var endOffset = 0;\n        while (uintBuffer[offset.value + endOffset] != 0) {\n          endOffset += 1;\n        }\n        var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n        offset.value = offset.value + endOffset + 1;\n        return stringValue;\n      }\n      function parseFixedLengthString(buffer, offset, size) {\n        var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n        offset.value = offset.value + size;\n        return stringValue;\n      }\n      function parseRational(dataView, offset) {\n        var x = parseInt32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n      function parseTimecode(dataView, offset) {\n        var x = parseUint32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n      function parseInt32(dataView, offset) {\n        var Int32 = dataView.getInt32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Int32;\n      }\n      function parseUint32(dataView, offset) {\n        var Uint32 = dataView.getUint32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Uint32;\n      }\n      function parseUint8Array(uInt8Array, offset) {\n        var Uint8 = uInt8Array[offset.value];\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n      function parseUint8(dataView, offset) {\n        var Uint8 = dataView.getUint8(offset.value);\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n      var parseInt64 = function parseInt64(dataView, offset) {\n        var int;\n        if ('getBigInt64' in DataView.prototype) {\n          int = Number(dataView.getBigInt64(offset.value, true));\n        } else {\n          int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n        }\n        offset.value += ULONG_SIZE;\n        return int;\n      };\n      function parseFloat32(dataView, offset) {\n        var float = dataView.getFloat32(offset.value, true);\n        offset.value += FLOAT32_SIZE;\n        return float;\n      }\n      function decodeFloat32(dataView, offset) {\n        return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n      } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n      function decodeFloat16(binary) {\n        var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n        return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n      }\n      function parseUint16(dataView, offset) {\n        var Uint16 = dataView.getUint16(offset.value, true);\n        offset.value += INT16_SIZE;\n        return Uint16;\n      }\n      function parseFloat16(buffer, offset) {\n        return decodeFloat16(parseUint16(buffer, offset));\n      }\n      function parseChlist(dataView, buffer, offset, size) {\n        var startOffset = offset.value;\n        var channels = [];\n        while (offset.value < startOffset + size - 1) {\n          var name = parseNullTerminatedString(buffer, offset);\n          var pixelType = parseInt32(dataView, offset);\n          var pLinear = parseUint8(dataView, offset);\n          offset.value += 3; // reserved, three chars\n\n          var xSampling = parseInt32(dataView, offset);\n          var ySampling = parseInt32(dataView, offset);\n          channels.push({\n            name: name,\n            pixelType: pixelType,\n            pLinear: pLinear,\n            xSampling: xSampling,\n            ySampling: ySampling\n          });\n        }\n        offset.value += 1;\n        return channels;\n      }\n      function parseChromaticities(dataView, offset) {\n        var redX = parseFloat32(dataView, offset);\n        var redY = parseFloat32(dataView, offset);\n        var greenX = parseFloat32(dataView, offset);\n        var greenY = parseFloat32(dataView, offset);\n        var blueX = parseFloat32(dataView, offset);\n        var blueY = parseFloat32(dataView, offset);\n        var whiteX = parseFloat32(dataView, offset);\n        var whiteY = parseFloat32(dataView, offset);\n        return {\n          redX: redX,\n          redY: redY,\n          greenX: greenX,\n          greenY: greenY,\n          blueX: blueX,\n          blueY: blueY,\n          whiteX: whiteX,\n          whiteY: whiteY\n        };\n      }\n      function parseCompression(dataView, offset) {\n        var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n        var compression = parseUint8(dataView, offset);\n        return compressionCodes[compression];\n      }\n      function parseBox2i(dataView, offset) {\n        var xMin = parseUint32(dataView, offset);\n        var yMin = parseUint32(dataView, offset);\n        var xMax = parseUint32(dataView, offset);\n        var yMax = parseUint32(dataView, offset);\n        return {\n          xMin: xMin,\n          yMin: yMin,\n          xMax: xMax,\n          yMax: yMax\n        };\n      }\n      function parseLineOrder(dataView, offset) {\n        var lineOrders = ['INCREASING_Y'];\n        var lineOrder = parseUint8(dataView, offset);\n        return lineOrders[lineOrder];\n      }\n      function parseV2f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        return [x, y];\n      }\n      function parseV3f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        var z = parseFloat32(dataView, offset);\n        return [x, y, z];\n      }\n      function parseValue(dataView, buffer, offset, type, size) {\n        if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n          return parseFixedLengthString(buffer, offset, size);\n        } else if (type === 'chlist') {\n          return parseChlist(dataView, buffer, offset, size);\n        } else if (type === 'chromaticities') {\n          return parseChromaticities(dataView, offset);\n        } else if (type === 'compression') {\n          return parseCompression(dataView, offset);\n        } else if (type === 'box2i') {\n          return parseBox2i(dataView, offset);\n        } else if (type === 'lineOrder') {\n          return parseLineOrder(dataView, offset);\n        } else if (type === 'float') {\n          return parseFloat32(dataView, offset);\n        } else if (type === 'v2f') {\n          return parseV2f(dataView, offset);\n        } else if (type === 'v3f') {\n          return parseV3f(dataView, offset);\n        } else if (type === 'int') {\n          return parseInt32(dataView, offset);\n        } else if (type === 'rational') {\n          return parseRational(dataView, offset);\n        } else if (type === 'timecode') {\n          return parseTimecode(dataView, offset);\n        } else if (type === 'preview') {\n          offset.value += size;\n          return 'skipped';\n        } else {\n          offset.value += size;\n          return undefined;\n        }\n      }\n      function parseHeader(dataView, buffer, offset) {\n        var EXRHeader = {};\n        if (dataView.getUint32(0, true) != 20000630) {\n          // magic\n          throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n        }\n        EXRHeader.version = dataView.getUint8(4);\n        var spec = dataView.getUint8(5); // fullMask\n\n        EXRHeader.spec = {\n          singleTile: !!(spec & 2),\n          longName: !!(spec & 4),\n          deepFormat: !!(spec & 8),\n          multiPart: !!(spec & 16)\n        }; // start of header\n\n        offset.value = 8; // start at 8 - after pre-amble\n\n        var keepReading = true;\n        while (keepReading) {\n          var attributeName = parseNullTerminatedString(buffer, offset);\n          if (attributeName == 0) {\n            keepReading = false;\n          } else {\n            var attributeType = parseNullTerminatedString(buffer, offset);\n            var attributeSize = parseUint32(dataView, offset);\n            var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n            if (attributeValue === undefined) {\n              console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n            } else {\n              EXRHeader[attributeName] = attributeValue;\n            }\n          }\n        }\n        if (spec != 0) {\n          console.error('EXRHeader:', EXRHeader);\n          throw 'THREE.EXRLoader: provided file is currently unsupported.';\n        }\n        return EXRHeader;\n      }\n      function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n        var EXRDecoder = {\n          size: 0,\n          viewer: dataView,\n          array: uInt8Array,\n          offset: offset,\n          width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n          height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n          channels: EXRHeader.channels.length,\n          bytesPerLine: null,\n          lines: null,\n          inputSize: null,\n          type: EXRHeader.channels[0].pixelType,\n          uncompress: null,\n          getter: null,\n          format: null,\n          encoding: null\n        };\n        switch (EXRHeader.compression) {\n          case 'NO_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRAW;\n            break;\n          case 'RLE_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRLE;\n            break;\n          case 'ZIPS_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n          case 'ZIP_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n          case 'PIZ_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressPIZ;\n            break;\n          case 'PXR24_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressPXR;\n            break;\n          case 'DWAA_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n          case 'DWAB_COMPRESSION':\n            EXRDecoder.lines = 256;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n          default:\n            throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n        }\n        EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n        if (EXRDecoder.type == 1) {\n          // half\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder.getter = parseUint16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n          }\n        } else if (EXRDecoder.type == 2) {\n          // float\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder.getter = decodeFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n          }\n        } else {\n          throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n        }\n        EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n        for (var i = 0; i < EXRDecoder.blockCount; i++) {\n          parseInt64(dataView, offset);\n        } // scanlineOffset\n        // we should be passed the scanline offset table, ready to start reading pixel data.\n        // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n        EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n        var size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n            break;\n          case HalfFloatType:\n            EXRDecoder.byteArray = new Uint16Array(size);\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n            break;\n          default:\n            console.error('THREE.EXRLoader: unsupported type: ', outputType);\n            break;\n        }\n        EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n        if (EXRDecoder.outputChannels == 4) {\n          EXRDecoder.format = RGBAFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        } else {\n          EXRDecoder.format = RedFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        }\n        return EXRDecoder;\n      } // start parsing file [START]\n\n      var bufferDataView = new DataView(buffer);\n      var uInt8Array = new Uint8Array(buffer);\n      var offset = {\n        value: 0\n      }; // get header information and validate format.\n\n      var EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n      var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n      var tmpOffset = {\n        value: 0\n      };\n      var channelOffsets = {\n        R: 0,\n        G: 1,\n        B: 2,\n        A: 3,\n        Y: 0\n      };\n      for (var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n        var line = parseUint32(bufferDataView, offset); // line_no\n\n        EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n        EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n        var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n        var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n          var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n          if (true_y >= EXRDecoder.height) break;\n          for (var channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n            var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n            for (var x = 0; x < EXRDecoder.width; x++) {\n              tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n              var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n      return {\n        header: EXRHeader,\n        width: EXRDecoder.width,\n        height: EXRDecoder.height,\n        data: EXRDecoder.byteArray,\n        format: EXRDecoder.format,\n        encoding: EXRDecoder.encoding,\n        type: this.type\n      };\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        texture.encoding = texData.encoding;\n        texture.minFilter = LinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.flipY = false;\n        if (onLoad) onLoad(texture, texData);\n      }\n      return _get(_getPrototypeOf(EXRLoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n  return EXRLoader;\n}(DataTextureLoader);\nexport { EXRLoader };","map":null,"metadata":{},"sourceType":"module"}