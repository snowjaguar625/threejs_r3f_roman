{"ast":null,"code":"import { Triangle, Vector3 } from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nvar MeshSurfaceSampler = function () {\n  var _face = new Triangle();\n  var _color = new Vector3();\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function setWeightAttribute(name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function build() {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (var i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n        _face.a.fromBufferAttribute(positionAttribute, i);\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n      for (var _i = 0; _i < faceWeights.length; _i++) {\n        cumulativeTotal += faceWeights[_i];\n        this.distribution[_i] = cumulativeTotal;\n      }\n      return this;\n    },\n    setRandomGenerator: function setRandomGenerator(randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function sample(targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function binarySearch(x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n      return index;\n    },\n    sampleFace: function sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\nexport { MeshSurfaceSampler };","map":null,"metadata":{},"sourceType":"module"}