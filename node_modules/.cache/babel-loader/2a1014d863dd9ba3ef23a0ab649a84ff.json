{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll_mid\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { CompressedTextureLoader, RGBAFormat, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_S3TC_DXT3_Format, RGB_S3TC_DXT1_Format } from 'three';\nvar DDSLoader = /*#__PURE__*/function (_CompressedTextureLoa) {\n  _inherits(DDSLoader, _CompressedTextureLoa);\n  function DDSLoader(manager) {\n    _classCallCheck(this, DDSLoader);\n    return _possibleConstructorReturn(this, _getPrototypeOf(DDSLoader).call(this, manager));\n  }\n  _createClass(DDSLoader, [{\n    key: \"parse\",\n    value: function parse(buffer, loadMipmaps) {\n      var dds = {\n        mipmaps: [],\n        width: 0,\n        height: 0,\n        format: null,\n        mipmapCount: 1\n      }; // Adapted from @toji's DDS utils\n      // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n      // All values and structures referenced from:\n      // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n      var DDS_MAGIC = 0x20534444; // let DDSD_CAPS = 0x1;\n      // let DDSD_HEIGHT = 0x2;\n      // let DDSD_WIDTH = 0x4;\n      // let DDSD_PITCH = 0x8;\n      // let DDSD_PIXELFORMAT = 0x1000;\n\n      var DDSD_MIPMAPCOUNT = 0x20000; // let DDSD_LINEARSIZE = 0x80000;\n      // let DDSD_DEPTH = 0x800000;\n      // let DDSCAPS_COMPLEX = 0x8;\n      // let DDSCAPS_MIPMAP = 0x400000;\n      // let DDSCAPS_TEXTURE = 0x1000;\n\n      var DDSCAPS2_CUBEMAP = 0x200;\n      var DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n      var DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n      var DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n      var DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n      var DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n      var DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000; // let DDSCAPS2_VOLUME = 0x200000;\n      // let DDPF_ALPHAPIXELS = 0x1;\n      // let DDPF_ALPHA = 0x2;\n\n      var DDPF_FOURCC = 0x4; // let DDPF_RGB = 0x40;\n      // let DDPF_YUV = 0x200;\n      // let DDPF_LUMINANCE = 0x20000;\n\n      function fourCCToInt32(value) {\n        return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n      }\n      function int32ToFourCC(value) {\n        return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n      }\n      function loadARGBMip(buffer, dataOffset, width, height) {\n        var dataLength = width * height * 4;\n        var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n        var byteArray = new Uint8Array(dataLength);\n        var dst = 0;\n        var src = 0;\n        for (var y = 0; y < height; y++) {\n          for (var x = 0; x < width; x++) {\n            var b = srcBuffer[src];\n            src++;\n            var g = srcBuffer[src];\n            src++;\n            var r = srcBuffer[src];\n            src++;\n            var a = srcBuffer[src];\n            src++;\n            byteArray[dst] = r;\n            dst++; //r\n\n            byteArray[dst] = g;\n            dst++; //g\n\n            byteArray[dst] = b;\n            dst++; //b\n\n            byteArray[dst] = a;\n            dst++; //a\n          }\n        }\n\n        return byteArray;\n      }\n      var FOURCC_DXT1 = fourCCToInt32('DXT1');\n      var FOURCC_DXT3 = fourCCToInt32('DXT3');\n      var FOURCC_DXT5 = fourCCToInt32('DXT5');\n      var FOURCC_ETC1 = fourCCToInt32('ETC1');\n      var headerLengthInt = 31; // The header length in 32 bit ints\n      // Offsets into the header array\n\n      var off_magic = 0;\n      var off_size = 1;\n      var off_flags = 2;\n      var off_height = 3;\n      var off_width = 4;\n      var off_mipmapCount = 7;\n      var off_pfFlags = 20;\n      var off_pfFourCC = 21;\n      var off_RGBBitCount = 22;\n      var off_RBitMask = 23;\n      var off_GBitMask = 24;\n      var off_BBitMask = 25;\n      var off_ABitMask = 26; // let off_caps = 27;\n\n      var off_caps2 = 28; // let off_caps3 = 29;\n      // let off_caps4 = 30;\n      // Parse header\n\n      var header = new Int32Array(buffer, 0, headerLengthInt);\n      if (header[off_magic] !== DDS_MAGIC) {\n        console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n        return dds;\n      }\n      if (!header[off_pfFlags] & DDPF_FOURCC) {\n        console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');\n        return dds;\n      }\n      var blockBytes;\n      var fourCC = header[off_pfFourCC];\n      var isRGBAUncompressed = false;\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          dds.format = RGB_S3TC_DXT1_Format;\n          break;\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          dds.format = RGBA_S3TC_DXT3_Format;\n          break;\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          dds.format = RGBA_S3TC_DXT5_Format;\n          break;\n        case FOURCC_ETC1:\n          blockBytes = 8;\n          dds.format = RGB_ETC1_Format;\n          break;\n        default:\n          if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n            isRGBAUncompressed = true;\n            blockBytes = 64;\n            dds.format = RGBAFormat;\n          } else {\n            console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n            return dds;\n          }\n      }\n      dds.mipmapCount = 1;\n      if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n        dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n      }\n      var caps2 = header[off_caps2];\n      dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n      if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n        console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n        return dds;\n      }\n      dds.width = header[off_width];\n      dds.height = header[off_height];\n      var dataOffset = header[off_size] + 4; // Extract mipmaps buffers\n\n      var faces = dds.isCubemap ? 6 : 1;\n      for (var face = 0; face < faces; face++) {\n        var width = dds.width;\n        var height = dds.height;\n        for (var i = 0; i < dds.mipmapCount; i++) {\n          var byteArray = void 0,\n            dataLength = void 0;\n          if (isRGBAUncompressed) {\n            byteArray = loadARGBMip(buffer, dataOffset, width, height);\n            dataLength = byteArray.length;\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n          }\n          var mipmap = {\n            data: byteArray,\n            width: width,\n            height: height\n          };\n          dds.mipmaps.push(mipmap);\n          dataOffset += dataLength;\n          width = Math.max(width >> 1, 1);\n          height = Math.max(height >> 1, 1);\n        }\n      }\n      return dds;\n    }\n  }]);\n  return DDSLoader;\n}(CompressedTextureLoader);\nexport { DDSLoader };","map":null,"metadata":{},"sourceType":"module"}