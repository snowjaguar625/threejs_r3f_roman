{"ast":null,"code":"import _classCallCheck from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\Train\\\\Three.js\\\\New folder\\\\infinite-scroll\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Loader, FileLoader, LineBasicMaterial, Group, Euler, BufferGeometry, Float32BufferAttribute, LineSegments } from 'three';\n\n/**\n * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n *\n * Gcode files are composed by commands used by machines to create objects.\n *\n * @class GCodeLoader\n * @param {Manager} manager Loading manager.\n */\nvar GCodeLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(GCodeLoader, _Loader);\n  function GCodeLoader(manager) {\n    var _this;\n    _classCallCheck(this, GCodeLoader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GCodeLoader).call(this, manager));\n    _this.splitLayer = false;\n    return _this;\n  }\n  _createClass(GCodeLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var state = {\n        x: 0,\n        y: 0,\n        z: 0,\n        e: 0,\n        f: 0,\n        extruding: false,\n        relative: false\n      };\n      var layers = [];\n      var currentLayer = undefined;\n      var pathMaterial = new LineBasicMaterial({\n        color: 0xff0000\n      });\n      pathMaterial.name = 'path';\n      var extrudingMaterial = new LineBasicMaterial({\n        color: 0x00ff00\n      });\n      extrudingMaterial.name = 'extruded';\n      function newLayer(line) {\n        currentLayer = {\n          vertex: [],\n          pathVertex: [],\n          z: line.z\n        };\n        layers.push(currentLayer);\n      } //Create lie segment between p1 and p2\n\n      function addSegment(p1, p2) {\n        if (currentLayer === undefined) {\n          newLayer(p1);\n        }\n        if (state.extruding) {\n          currentLayer.vertex.push(p1.x, p1.y, p1.z);\n          currentLayer.vertex.push(p2.x, p2.y, p2.z);\n        } else {\n          currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n          currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n        }\n      }\n      function delta(v1, v2) {\n        return state.relative ? v2 : v2 - v1;\n      }\n      function absolute(v1, v2) {\n        return state.relative ? v1 + v2 : v2;\n      }\n      var lines = data.replace(/;.+/g, '').split('\\n');\n      var _loop = function _loop(i) {\n        var tokens = lines[i].split(' ');\n        var cmd = tokens[0].toUpperCase(); //Argumments\n\n        var args = {};\n        tokens.splice(1).forEach(function (token) {\n          if (token[0] !== undefined) {\n            var key = token[0].toLowerCase();\n            var value = parseFloat(token.substring(1));\n            args[key] = value;\n          }\n        }); //Process commands\n        //G0/G1 â€“ Linear Movement\n\n        if (cmd === 'G0' || cmd === 'G1') {\n          var line = {\n            x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n            y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n            z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n            e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n            f: args.f !== undefined ? absolute(state.f, args.f) : state.f\n          }; //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\n          if (delta(state.e, line.e) > 0) {\n            line.extruding = delta(state.e, line.e) > 0;\n            if (currentLayer == undefined || line.z != currentLayer.z) {\n              newLayer(line);\n            }\n          }\n          addSegment(state, line);\n          state = line;\n        } else if (cmd === 'G2' || cmd === 'G3') ;else if (cmd === 'G90') {\n          //G90: Set to Absolute Positioning\n          state.relative = false;\n        } else if (cmd === 'G91') {\n          //G91: Set to state.relative Positioning\n          state.relative = true;\n        } else if (cmd === 'G92') {\n          //G92: Set Position\n          var _line = state;\n          _line.x = args.x !== undefined ? args.x : _line.x;\n          _line.y = args.y !== undefined ? args.y : _line.y;\n          _line.z = args.z !== undefined ? args.z : _line.z;\n          _line.e = args.e !== undefined ? args.e : _line.e;\n          state = _line;\n        } else ;\n      };\n      for (var i = 0; i < lines.length; i++) {\n        _loop(i);\n      }\n      function addObject(vertex, extruding, i) {\n        var geometry = new BufferGeometry();\n        geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3));\n        var segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n        segments.name = 'layer' + i;\n        object.add(segments);\n      }\n      var object = new Group();\n      object.name = 'gcode';\n      if (this.splitLayer) {\n        for (var _i = 0; _i < layers.length; _i++) {\n          var layer = layers[_i];\n          addObject(layer.vertex, true, _i);\n          addObject(layer.pathVertex, false, _i);\n        }\n      } else {\n        var vertex = [],\n          pathVertex = [];\n        for (var _i2 = 0; _i2 < layers.length; _i2++) {\n          var _layer = layers[_i2];\n          var layerVertex = _layer.vertex;\n          var layerPathVertex = _layer.pathVertex;\n          for (var j = 0; j < layerVertex.length; j++) {\n            vertex.push(layerVertex[j]);\n          }\n          for (var _j = 0; _j < layerPathVertex.length; _j++) {\n            pathVertex.push(layerPathVertex[_j]);\n          }\n        }\n        addObject(vertex, true, layers.length);\n        addObject(pathVertex, false, layers.length);\n      }\n      object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      return object;\n    }\n  }]);\n  return GCodeLoader;\n}(Loader);\nexport { GCodeLoader };","map":null,"metadata":{},"sourceType":"module"}